{
  "imports": {
    "class": "imports",
    "SNMPv2-CONF": [
      "MODULE-COMPLIANCE",
      "NOTIFICATION-GROUP"
    ],
    "SNMPv2-SMI": [
      "Gauge32",
      "Integer32",
      "Bits",
      "OBJECT-TYPE",
      "iso",
      "MODULE-IDENTITY",
      "NOTIFICATION-TYPE",
      "IpAddress",
      "Counter32",
      "enterprises",
      "Unsigned32",
      "Counter64",
      "MibIdentifier",
      "OBJECT-IDENTITY",
      "TimeTicks"
    ],
    "SNMPv2-TC": [
      "TEXTUAL-CONVENTION",
      "DisplayString"
    ]
  },
  "UShortReal": {
    "name": "UShortReal",
    "class": "type",
    "type": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "range": [
          {
            "min": 0,
            "max": 65535
          }
        ]
      }
    }
  },
  "CimDateTime": {
    "name": "CimDateTime",
    "class": "type",
    "type": {
      "type": "OCTET STRING",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 24,
            "max": 24
          }
        ]
      }
    }
  },
  "UINT64": {
    "name": "UINT64",
    "class": "type",
    "type": {
      "type": "OCTET STRING",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 8,
            "max": 8
          }
        ]
      }
    }
  },
  "UINT32": {
    "name": "UINT32",
    "class": "type",
    "type": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "range": [
          {
            "min": 0,
            "max": 2147483647
          }
        ]
      }
    }
  },
  "UINT16": {
    "name": "UINT16",
    "class": "type",
    "type": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "range": [
          {
            "min": 0,
            "max": 65535
          }
        ]
      }
    }
  },
  "snia": {
    "name": "snia",
    "oid": "1.3.6.1.4.1.14851",
    "class": "objectidentity"
  },
  "experimental": {
    "name": "experimental",
    "oid": "1.3.6.1.4.1.14851.1",
    "class": "objectidentity"
  },
  "common": {
    "name": "common",
    "oid": "1.3.6.1.4.1.14851.2",
    "class": "objectidentity"
  },
  "libraries": {
    "name": "libraries",
    "oid": "1.3.6.1.4.1.14851.3",
    "class": "objectidentity"
  },
  "smlRoot": {
    "name": "smlRoot",
    "oid": "1.3.6.1.4.1.14851.3.1",
    "class": "objectidentity"
  },
  "smlMibVersion": {
    "name": "smlMibVersion",
    "oid": "1.3.6.1.4.1.14851.3.1.1",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 4
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "This string contains version information for the MIB file"
  },
  "smlCimVersion": {
    "name": "smlCimVersion",
    "oid": "1.3.6.1.4.1.14851.3.1.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 4
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "This string contains information about the CIM version that corresponds to the MIB. The decriptions in this MIB file are based on CIM version 2.8"
  },
  "productGroup": {
    "name": "productGroup",
    "oid": "1.3.6.1.4.1.14851.3.1.3",
    "class": "objectidentity"
  },
  "product_Name": {
    "name": "product_Name",
    "oid": "1.3.6.1.4.1.14851.3.1.3.1",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Commonly used Product name."
  },
  "product_IdentifyingNumber": {
    "name": "product_IdentifyingNumber",
    "oid": "1.3.6.1.4.1.14851.3.1.3.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Product identification such as a serial number on software, a die number on a hardware chip, or (for non-commercial Products) a project number."
  },
  "product_Vendor": {
    "name": "product_Vendor",
    "oid": "1.3.6.1.4.1.14851.3.1.3.3",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The name of the Product's supplier, or entity selling the Product (the manufacturer, reseller, OEM, etc.). Corresponds to the Vendor property in the Product object in the DMTF Solution Exchange Standard."
  },
  "product_Version": {
    "name": "product_Version",
    "oid": "1.3.6.1.4.1.14851.3.1.3.4",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Product version information. Corresponds to the Version property in the Product object in the DMTF Solution Exchange Standard."
  },
  "product_ElementName": {
    "name": "product_ElementName",
    "oid": "1.3.6.1.4.1.14851.3.1.3.5",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A user-friendly name for the object. This property allows each instance to define a user-friendly name IN ADDITION TO its key properties/identity data, and description information. Note that ManagedSystemElement's Name property is also defined as a user-friendly name. But, it is often subclassed to be a Key. It is not reasonable that the same property can convey both identity and a user friendly name, without inconsistencies. Where Name exists and is not a Key (such as for instances of LogicalDevice), the same information MAY be present in both the Name and ElementName properties."
  },
  "chassisGroup": {
    "name": "chassisGroup",
    "oid": "1.3.6.1.4.1.14851.3.1.4",
    "class": "objectidentity"
  },
  "chassis_Manufacturer": {
    "name": "chassis_Manufacturer",
    "oid": "1.3.6.1.4.1.14851.3.1.4.1",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The name of the organization responsible for producing the PhysicalElement. This may be the entity from whom the Element is purchased, but this is not necessarily true. The latter information is contained in the Vendor property of CIM_Product."
  },
  "chassis_Model": {
    "name": "chassis_Model",
    "oid": "1.3.6.1.4.1.14851.3.1.4.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The name by which the PhysicalElement is generally known."
  },
  "chassis_SerialNumber": {
    "name": "chassis_SerialNumber",
    "oid": "1.3.6.1.4.1.14851.3.1.4.3",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A manufacturer-allocated number used to identify the Physical Element."
  },
  "chassis_LockPresent": {
    "name": "chassis_LockPresent",
    "oid": "1.3.6.1.4.1.14851.3.1.4.4",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "true": 1,
          "false": 2
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Boolean indicating whether the Frame is protected with a lock."
  },
  "chassis_SecurityBreach": {
    "name": "chassis_SecurityBreach",
    "oid": "1.3.6.1.4.1.14851.3.1.4.5",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 1,
          "other": 2,
          "noBreach": 3,
          "breachAttempted": 4,
          "breachSuccessful": 5
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "SecurityBreach is an enumerated, integer-valued property indicating whether a physical breach of the Frame was attempted but unsuccessful (value=4) or attempted and successful (5). Also, the values, 'Unknown', 'Other' or 'No Breach', can be specified."
  },
  "chassis_IsLocked": {
    "name": "chassis_IsLocked",
    "oid": "1.3.6.1.4.1.14851.3.1.4.6",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "true": 1,
          "false": 2
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Boolean indicating that the Frame is currently locked."
  },
  "chassis_Tag": {
    "name": "chassis_Tag",
    "oid": "1.3.6.1.4.1.14851.3.1.4.7",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "An arbitrary string that uniquely identifies the Physical Element and serves as the Element's key. The Tag property can contain information such as asset tag or serial number data. The key for PhysicalElement is placed very high in the object hierarchy in order to independently identify the hardware/entity, regardless of physical placement in or on Cabinets, Adapters, etc. For example, a hotswappable or removeable component may be taken from its containing (scoping) Package and be temporarily unused. The object still continues to exist - and may even be inserted into a different scoping container. Therefore, the key for Physical Element is an arbitrary string and is defined independently of any placement or location-oriented hierarchy."
  },
  "chassis_ElementName": {
    "name": "chassis_ElementName",
    "oid": "1.3.6.1.4.1.14851.3.1.4.8",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A user-friendly name for the object. This property allows each instance to define a user-friendly name IN ADDITION TO its key properties/identity data, and description information. Note that ManagedSystemElement's Name property is also defined as a user-friendly name. But, it is often subclassed to be a Key. It is not reasonable that the same property can convey both identity and a user friendly name, without inconsistencies. Where Name exists and is not a Key (such as for instances of LogicalDevice), the same information MAY be present in both the Name and ElementName properties."
  },
  "numberOfsubChassis": {
    "name": "numberOfsubChassis",
    "oid": "1.3.6.1.4.1.14851.3.1.4.9",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "Integer32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "This value specifies the number of sub Chassis that are present."
  },
  "subChassisTable": {
    "name": "subChassisTable",
    "oid": "1.3.6.1.4.1.14851.3.1.4.10",
    "nodetype": "table",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "status": "mandatory",
    "description": "The SubChassis class represents the physical frames in the library"
  },
  "subChassisEntry": {
    "name": "subChassisEntry",
    "oid": "1.3.6.1.4.1.14851.3.1.4.10.1",
    "nodetype": "row",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "indices": [
      {
        "module": "SNIA-SML-MIB",
        "object": "subChassisIndex",
        "implied": 0
      }
    ],
    "status": "mandatory",
    "description": "Each entry in the table contains information about a frame that is present in the library."
  },
  "subChassisIndex": {
    "name": "subChassisIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.4.10.1.1",
    "nodetype": "column",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the subChassis."
  },
  "subChassis_Manufacturer": {
    "name": "subChassis_Manufacturer",
    "oid": "1.3.6.1.4.1.14851.3.1.4.10.1.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The name of the organization responsible for producing the PhysicalElement. This may be the entity from whom the Element is purchased, but this is not necessarily true. The latter information is contained in the Vendor property of CIM_Product."
  },
  "subChassis_Model": {
    "name": "subChassis_Model",
    "oid": "1.3.6.1.4.1.14851.3.1.4.10.1.3",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The name by which the PhysicalElement is generally known."
  },
  "subChassis_SerialNumber": {
    "name": "subChassis_SerialNumber",
    "oid": "1.3.6.1.4.1.14851.3.1.4.10.1.4",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A manufacturer-allocated number used to identify the Physical Element."
  },
  "subChassis_LockPresent": {
    "name": "subChassis_LockPresent",
    "oid": "1.3.6.1.4.1.14851.3.1.4.10.1.5",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "true": 1,
          "false": 2
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Boolean indicating whether the Frame is protected with a lock."
  },
  "subChassis_SecurityBreach": {
    "name": "subChassis_SecurityBreach",
    "oid": "1.3.6.1.4.1.14851.3.1.4.10.1.6",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 1,
          "other": 2,
          "noBreach": 3,
          "breachAttempted": 4,
          "breachSuccessful": 5
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "SecurityBreach is an enumerated, integer-valued property indicating whether a physical breach of the Frame was attempted but unsuccessful (value=4) or attempted and successful (5). Also, the values, 'Unknown', 'Other' or 'No Breach', can be specified."
  },
  "subChassis_IsLocked": {
    "name": "subChassis_IsLocked",
    "oid": "1.3.6.1.4.1.14851.3.1.4.10.1.7",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "true": 1,
          "false": 2
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Boolean indicating that the Frame is currently locked."
  },
  "subChassis_Tag": {
    "name": "subChassis_Tag",
    "oid": "1.3.6.1.4.1.14851.3.1.4.10.1.8",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "An arbitrary string that uniquely identifies the Physical Element and serves as the Element's key. The Tag property can contain information such as asset tag or serial number data. The key for PhysicalElement is placed very high in the object hierarchy in order to independently identify the hardware/entity, regardless of physical placement in or on Cabinets, Adapters, etc. For example, a hotswappable or removeable component may be taken from its containing (scoping) Package and be temporarily unused. The object still continues to exist - and may even be inserted into a different scoping container. Therefore, the key for Physical Element is an arbitrary string and is defined independently of any placement or location-oriented hierarchy."
  },
  "subChassis_ElementName": {
    "name": "subChassis_ElementName",
    "oid": "1.3.6.1.4.1.14851.3.1.4.10.1.9",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A user-friendly name for the object. This property allows each instance to define a user-friendly name IN ADDITION TO its key properties/identity data, and description information. Note that ManagedSystemElement's Name property is also defined as a user-friendly name. But, it is often subclassed to be a Key. It is not reasonable that the same property can convey both identity and a user friendly name, without inconsistencies. Where Name exists and is not a Key (such as for instances of LogicalDevice), the same information MAY be present in both the Name and ElementName properties."
  },
  "subChassis_OperationalStatus": {
    "name": "subChassis_OperationalStatus",
    "oid": "1.3.6.1.4.1.14851.3.1.4.10.1.10",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "other": 1,
          "ok": 2,
          "degraded": 3,
          "stressed": 4,
          "predictiveFailure": 5,
          "error": 6,
          "non-RecoverableError": 7,
          "starting": 8,
          "stopping": 9,
          "stopped": 10,
          "inService": 11,
          "noContact": 12,
          "lostCommunication": 13,
          "aborted": 14,
          "dormant": 15,
          "supportingEntityInError": 16,
          "completed": 17,
          "powerMode": 18,
          "dMTFReserved": 19,
          "vendorReserved": 32768
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Indicates the current status(es) of the element. Various health and operational statuses are defined. Many of the enumeration's values are self- explanatory. However, a few are not and are described in more detail. \\n 'Stressed' indicates that the element is functioning, but needs attention. Examples of 'Stressed' states are overload, overheated, etc. \\n 'Predictive Failure' indicates that an element is functioning nominally but predicting a failure in the near future. \\n 'In Service' describes an element being configured, maintained, cleaned, or otherwise administered. \\n 'No Contact' indicates that the monitoring system has knowledge of this element, but has never been able to establish communications with it. \\n 'Lost Communication' indicates that the ManagedSystem Element is known to exist and has been contacted successfully in the past, but is currently unreachable. \\n 'Stopped' and 'Aborted' are similar, although the former implies a clean and orderly stop, while the latter implies an abrupt stop where the element's state and configuration may need to be updated. \\n 'Dormant' indicates that the element is inactive or quiesced. \\n 'Supporting Entity in Error' describes that this element may be 'OK' but that another element, on which it is dependent, is in error. An example is a network service or endpoint that cannot function due to lower layer networking problems. \\n 'Completed' indicates the element has completed its operation. This value should be combined with either OK, Error, or Degraded so that a client can till if the complete operation passed (Completed with OK), and failure (Completed with Error). Completed with Degraded would imply the operation finished, but did not complete OK or report an error. \\n 'Power Mode' indicates the element has additional power model information contained in the Associated PowerManagementService association. \\n OperationalStatus replaces the Status property on ManagedSystemElement to provide a consistent approach to enumerations, to address implementation needs for an array property, and to provide a migration path from today's environment to the future. This change was not made earlier since it required the DEPRECATED qualifier. Due to the widespread use of the existing Status property in management applications, it is strongly RECOMMENDED that providers/instrumentation provide BOTH the Status and OperationalStatus properties. Further, the first value of OperationalStatus SHOULD contain the primary status for the element. When instrumented, Status (since it is single-valued) SHOULD also provide the primary status of the element."
  },
  "subChassis_PackageType": {
    "name": "subChassis_PackageType",
    "oid": "1.3.6.1.4.1.14851.3.1.4.10.1.11",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "mainSystemChassis": 17,
          "expansionChassis": 18,
          "subChassis": 19,
          "serviceBay": 32769
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Package type of the subChassis. The enumeration values for this variable should be the same as the DMTF CIM_Chassis.ChassisPackageType property. Use the Vendor reserved values for vendor-specific types."
  },
  "storageLibraryGroup": {
    "name": "storageLibraryGroup",
    "oid": "1.3.6.1.4.1.14851.3.1.5",
    "class": "objectidentity"
  },
  "storageLibrary_Name": {
    "name": "storageLibrary_Name",
    "oid": "1.3.6.1.4.1.14851.3.1.5.1",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "deprecated",
    "description": "The inherited Name serves as key of a System instance in an enterprise environment."
  },
  "storageLibrary_Description": {
    "name": "storageLibrary_Description",
    "oid": "1.3.6.1.4.1.14851.3.1.5.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "deprecated",
    "description": "The Description property provides a textual description of the object."
  },
  "storageLibrary_Caption": {
    "name": "storageLibrary_Caption",
    "oid": "1.3.6.1.4.1.14851.3.1.5.3",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "deprecated",
    "description": "The Caption property is a short textual description (one- line string) of the object."
  },
  "storageLibrary_Status": {
    "name": "storageLibrary_Status",
    "oid": "1.3.6.1.4.1.14851.3.1.5.4",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 10
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "deprecated",
    "description": "A string indicating the current status of the object. Various operational and non-operational statuses are defined. This property is deprecated in lieu of OperationalStatus, which includes the same semantics in its enumeration. This change is made for three reasons: 1) Status is more correctly defined as an array property. This overcomes the limitation of describing status via a single value, when it is really a multi-valued property (for example, an element may be OK AND Stopped. 2) A MaxLen of 10 is too restrictive and leads to unclear enumerated values. And, 3) The change to a uint16 data type was discussed when CIM V2.0 was defined. However, existing V1.0 implementations used the string property and did not want to modify their code. Therefore, Status was grandfathered into the Schema. Use of the Deprecated qualifier allows the maintenance of the existing property, but also permits an improved definition using OperationalStatus."
  },
  "storageLibrary_InstallDate": {
    "name": "storageLibrary_InstallDate",
    "oid": "1.3.6.1.4.1.14851.3.1.5.5",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "CimDateTime",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "deprecated",
    "description": "A datetime value indicating when the object was installed. A lack of a value does not indicate that the object is not installed."
  },
  "mediaAccessDeviceGroup": {
    "name": "mediaAccessDeviceGroup",
    "oid": "1.3.6.1.4.1.14851.3.1.6",
    "class": "objectidentity"
  },
  "numberOfMediaAccessDevices": {
    "name": "numberOfMediaAccessDevices",
    "oid": "1.3.6.1.4.1.14851.3.1.6.1",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "Integer32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "This value specifies the number of MediaAccessDevices that are present."
  },
  "mediaAccessDeviceTable": {
    "name": "mediaAccessDeviceTable",
    "oid": "1.3.6.1.4.1.14851.3.1.6.2",
    "nodetype": "table",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "status": "mandatory",
    "description": "A MediaAccessDevice represents the ability to access one or more media and use this media to store and retrieve data."
  },
  "mediaAccessDeviceEntry": {
    "name": "mediaAccessDeviceEntry",
    "oid": "1.3.6.1.4.1.14851.3.1.6.2.1",
    "nodetype": "row",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "indices": [
      {
        "module": "SNIA-SML-MIB",
        "object": "mediaAccessDeviceIndex",
        "implied": 0
      }
    ],
    "status": "mandatory",
    "description": "Each entry in the table contains information about a MediaAccessDevice that is present in the library."
  },
  "mediaAccessDeviceIndex": {
    "name": "mediaAccessDeviceIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.6.2.1.1",
    "nodetype": "column",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the MediaAccessDevice."
  },
  "mediaAccessDeviceObjectType": {
    "name": "mediaAccessDeviceObjectType",
    "oid": "1.3.6.1.4.1.14851.3.1.6.2.1.2",
    "nodetype": "column",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "wormDrive": 1,
          "magnetoOpticalDrive": 2,
          "tapeDrive": 3,
          "dvdDrive": 4,
          "cdromDrive": 5
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "In the 2.7 CIM Schema a Type property is no longer associated with MediaAccessDevice. However, it can be used here to specify the type of drive that is present."
  },
  "mediaAccessDevice_Name": {
    "name": "mediaAccessDevice_Name",
    "oid": "1.3.6.1.4.1.14851.3.1.6.2.1.3",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "deprecated",
    "description": "Deprecated"
  },
  "mediaAccessDevice_Status": {
    "name": "mediaAccessDevice_Status",
    "oid": "1.3.6.1.4.1.14851.3.1.6.2.1.4",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 10
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "deprecated",
    "description": "A string indicating the current status of the object. Various operational and non-operational statuses are defined. This property is deprecated in lieu of OperationalStatus, which includes the same semantics in its enumeration. This change is made for three reasons: 1) Status is more correctly defined as an array property. This overcomes the limitation of describing status via a single value, when it is really a multi-valued property (for example, an element may be OK AND Stopped. 2) A MaxLen of 10 is too restrictive and leads to unclear enumerated values. And, 3) The change to a uint16 data type was discussed when CIM V2.0 was defined. However, existing V1.0 implementations used the string property and did not want to modify their code. Therefore, Status was grandfathered into the Schema. Use of the Deprecated qualifier allows the maintenance of the existing property, but also permits an improved definition using OperationalStatus."
  },
  "mediaAccessDevice_Availability": {
    "name": "mediaAccessDevice_Availability",
    "oid": "1.3.6.1.4.1.14851.3.1.6.2.1.5",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "other": 1,
          "unknown": 2,
          "runningFullPower": 3,
          "warning": 4,
          "inTest": 5,
          "notApplicable": 6,
          "powerOff": 7,
          "offLine": 8,
          "offDuty": 9,
          "degraded": 10,
          "notInstalled": 11,
          "installError": 12,
          "powerSaveUnknown": 13,
          "powerSaveLowPowerMode": 14,
          "powerSaveStandby": 15,
          "powerCycle": 16,
          "powerSaveWarning": 17,
          "paused": 18,
          "notReady": 19,
          "notConfigured": 20,
          "quiesced": 21
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Inherited from CIM_LogicalDevice The primary availability and status of the Device. (Additional status information can be specified using the Additional Availability array property.) For example, the Availability property indicates that the Device is running and has full power (value=3), or is in a warning (4), test (5), degraded (10) or power save state (values 13-15 and 17). Regarding the Power Save states, these are defined as follows: Value 13 (Power Save - Unknown) indicates that the Device is known to be in a power save mode, but its exact status in this mode is unknown; 14 (Power Save - Low Power Mode) indicates that the Device is in a power save state but still functioning, and may exhibit degraded performance; 15 (Power Save - Standby) describes that the Device is not functioning but could be brought to full power 'quickly'; and value 17 (Power Save - Warning) indicates that the Device is in a warning state, though also in a power save mode."
  },
  "mediaAccessDevice_NeedsCleaning": {
    "name": "mediaAccessDevice_NeedsCleaning",
    "oid": "1.3.6.1.4.1.14851.3.1.6.2.1.6",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "true": 1,
          "false": 2
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Boolean indicating that the MediaAccessDevice needs cleaning. Whether manual or automatic cleaning is possible is indicated in the Capabilities array property. "
  },
  "mediaAccessDevice_MountCount": {
    "name": "mediaAccessDevice_MountCount",
    "oid": "1.3.6.1.4.1.14851.3.1.6.2.1.7",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT64",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "For a MediaAccessDevice that supports removable Media, the number of times that Media have been mounted for data transfer or to clean the Device. For Devices accessing nonremovable Media, such as hard disks, this property is not applicable and should be set to 0."
  },
  "mediaAccessDevice_DeviceID": {
    "name": "mediaAccessDevice_DeviceID",
    "oid": "1.3.6.1.4.1.14851.3.1.6.2.1.8",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "An address or other identifying information to uniquely name the LogicalDevice."
  },
  "mediaAccessDevice_PowerOnHours": {
    "name": "mediaAccessDevice_PowerOnHours",
    "oid": "1.3.6.1.4.1.14851.3.1.6.2.1.9",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT64",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The number of consecutive hours that this Device has been powered, since its last power cycle."
  },
  "mediaAccessDevice_TotalPowerOnHours": {
    "name": "mediaAccessDevice_TotalPowerOnHours",
    "oid": "1.3.6.1.4.1.14851.3.1.6.2.1.10",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT64",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The total number of hours that this Device has been powered."
  },
  "mediaAccessDevice_OperationalStatus": {
    "name": "mediaAccessDevice_OperationalStatus",
    "oid": "1.3.6.1.4.1.14851.3.1.6.2.1.11",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "other": 1,
          "ok": 2,
          "degraded": 3,
          "stressed": 4,
          "predictiveFailure": 5,
          "error": 6,
          "non-RecoverableError": 7,
          "starting": 8,
          "stopping": 9,
          "stopped": 10,
          "inService": 11,
          "noContact": 12,
          "lostCommunication": 13,
          "aborted": 14,
          "dormant": 15,
          "supportingEntityInError": 16,
          "completed": 17,
          "powerMode": 18,
          "dMTFReserved": 19,
          "vendorReserved": 32768
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Indicates the current status(es) of the element. Various health and operational statuses are defined. Many of the enumeration's values are self- explanatory. However, a few are not and are described in more detail. \\n 'Stressed' indicates that the element is functioning, but needs attention. Examples of 'Stressed' states are overload, overheated, etc. \\n 'Predictive Failure' indicates that an element is functioning nominally but predicting a failure in the near future. \\n 'In Service' describes an element being configured, maintained, cleaned, or otherwise administered. \\n 'No Contact' indicates that the monitoring system has knowledge of this element, but has never been able to establish communications with it. \\n 'Lost Communication' indicates that the ManagedSystem Element is known to exist and has been contacted successfully in the past, but is currently unreachable. \\n 'Stopped' and 'Aborted' are similar, although the former implies a clean and orderly stop, while the latter implies an abrupt stop where the element's state and configuration may need to be updated. \\n 'Dormant' indicates that the element is inactive or quiesced. \\n 'Supporting Entity in Error' describes that this element may be 'OK' but that another element, on which it is dependent, is in error. An example is a network service or endpoint that cannot function due to lower layer networking problems. \\n 'Completed' indicates the element has completed its operation. This value should be combined with either OK, Error, or Degraded so that a client can till if the complete operation passed (Completed with OK), and failure (Completed with Error). Completed with Degraded would imply the operation finished, but did not complete OK or report an error. \\n 'Power Mode' indicates the element has additional power model information contained in the Associated PowerManagementService association. \\n OperationalStatus replaces the Status property on ManagedSystemElement to provide a consistent approach to enumerations, to address implementation needs for an array property, and to provide a migration path from today's environment to the future. This change was not made earlier since it required the DEPRECATED qualifier. Due to the widespread use of the existing Status property in management applications, it is strongly RECOMMENDED that providers/instrumentation provide BOTH the Status and OperationalStatus properties. Further, the first value of OperationalStatus SHOULD contain the primary status for the element. When instrumented, Status (since it is single-valued) SHOULD also provide the primary status of the element."
  },
  "mediaAccessDevice_Realizes_StorageLocationIndex": {
    "name": "mediaAccessDevice_Realizes_StorageLocationIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.6.2.1.12",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the storageMediaLocationIndex that this MediaAccessDevice is associated with. If no association exists an index of 0 may be returned."
  },
  "mediaAccessDevice_Realizes_softwareElementIndex": {
    "name": "mediaAccessDevice_Realizes_softwareElementIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.6.2.1.13",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the softwareElementIndex that this MediaAccessDevice is associated with. If no association exists an index of 0 may be returned."
  },
  "physicalPackageGroup": {
    "name": "physicalPackageGroup",
    "oid": "1.3.6.1.4.1.14851.3.1.8",
    "class": "objectidentity"
  },
  "numberOfPhysicalPackages": {
    "name": "numberOfPhysicalPackages",
    "oid": "1.3.6.1.4.1.14851.3.1.8.1",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "Integer32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "This value specifies the number of PhysicalPackages that are present."
  },
  "physicalPackageTable": {
    "name": "physicalPackageTable",
    "oid": "1.3.6.1.4.1.14851.3.1.8.2",
    "nodetype": "table",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "status": "mandatory",
    "description": "The PhysicalPackage class represents PhysicalElements that contain or host other components. Examples are a Rack enclosure or an adapter Card. (also a tape magazine inside an auto-loader)"
  },
  "physicalPackageEntry": {
    "name": "physicalPackageEntry",
    "oid": "1.3.6.1.4.1.14851.3.1.8.2.1",
    "nodetype": "row",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "indices": [
      {
        "module": "SNIA-SML-MIB",
        "object": "physicalPackageIndex",
        "implied": 0
      }
    ],
    "status": "mandatory",
    "description": "Each entry in the table contains information about a PhysicalPackage that is present in the library."
  },
  "physicalPackageIndex": {
    "name": "physicalPackageIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.8.2.1.1",
    "nodetype": "column",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the PhysicalPackage."
  },
  "physicalPackage_Manufacturer": {
    "name": "physicalPackage_Manufacturer",
    "oid": "1.3.6.1.4.1.14851.3.1.8.2.1.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The name of the organization responsible for producing the PhysicalElement. This may be the entity from whom the Element is purchased, but this is not necessarily true. The latter information is contained in the Vendor property of CIM_Product."
  },
  "physicalPackage_Model": {
    "name": "physicalPackage_Model",
    "oid": "1.3.6.1.4.1.14851.3.1.8.2.1.3",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The name by which the PhysicalElement is generally known."
  },
  "physicalPackage_SerialNumber": {
    "name": "physicalPackage_SerialNumber",
    "oid": "1.3.6.1.4.1.14851.3.1.8.2.1.4",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A manufacturer-allocated number used to identify the Physical Element."
  },
  "physicalPackage_Realizes_MediaAccessDeviceIndex": {
    "name": "physicalPackage_Realizes_MediaAccessDeviceIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.8.2.1.5",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "Integer32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The index value of the the MediaAccess device that is associated with this physical package.'"
  },
  "physicalPackage_Tag": {
    "name": "physicalPackage_Tag",
    "oid": "1.3.6.1.4.1.14851.3.1.8.2.1.6",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "An arbitrary string that uniquely identifies the Physical Element and serves as the Element's key. The Tag property can contain information such as asset tag or serial number data. The key for PhysicalElement is placed very high in the object hierarchy in order to independently identify the hardware/entity, regardless of physical placement in or on Cabinets, Adapters, etc. For example, a hotswappable or removeable component may be taken from its containing (scoping) Package and be temporarily unused. The object still continues to exist - and may even be inserted into a different scoping container. Therefore, the key for Physical Element is an arbitrary string and is defined independently of any placement or location-oriented hierarchy."
  },
  "softwareElementGroup": {
    "name": "softwareElementGroup",
    "oid": "1.3.6.1.4.1.14851.3.1.9",
    "class": "objectidentity"
  },
  "numberOfSoftwareElements": {
    "name": "numberOfSoftwareElements",
    "oid": "1.3.6.1.4.1.14851.3.1.9.1",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "Integer32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "This value specifies the number of SoftwareElements that are present."
  },
  "softwareElementTable": {
    "name": "softwareElementTable",
    "oid": "1.3.6.1.4.1.14851.3.1.9.2",
    "nodetype": "table",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "status": "mandatory",
    "description": "The CIM_SoftwareElement class is used to decompose a CIM_SoftwareFeature object into a set of individually manageable or deployable parts for a particular platform. A software element's platform is uniquely identified by its underlying hardware architecture and operating system (for example Sun Solaris on Sun Sparc or Windows NT on Intel). As such, to understand the details of how the functionality of a particular software feature is provided on a particular platform, the CIM_SoftwareElement objects referenced by CIM_SoftwareFeatureSoftwareElement associations are organized in disjoint sets based on the TargetOperatingSystem property. A CIM_SoftwareElement object captures the management details of a part or component in one of four states characterized by the SoftwareElementState property. "
  },
  "softwareElementEntry": {
    "name": "softwareElementEntry",
    "oid": "1.3.6.1.4.1.14851.3.1.9.2.1",
    "nodetype": "row",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "indices": [
      {
        "module": "SNIA-SML-MIB",
        "object": "softwareElementIndex",
        "implied": 0
      }
    ],
    "status": "mandatory",
    "description": "Each entry in the table contains information about a SoftwareElement that is present in the library."
  },
  "softwareElementIndex": {
    "name": "softwareElementIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.9.2.1.1",
    "nodetype": "column",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the SoftwareElement."
  },
  "softwareElement_Name": {
    "name": "softwareElement_Name",
    "oid": "1.3.6.1.4.1.14851.3.1.9.2.1.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "deprecated",
    "description": "deprecated"
  },
  "softwareElement_Version": {
    "name": "softwareElement_Version",
    "oid": "1.3.6.1.4.1.14851.3.1.9.2.1.3",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Version should be in the form .. or . "
  },
  "softwareElement_SoftwareElementID": {
    "name": "softwareElement_SoftwareElementID",
    "oid": "1.3.6.1.4.1.14851.3.1.9.2.1.4",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "SoftwareIdentity represents software, viewed as an asset and/or individually identifiable entity (similar to Physical Element). It does NOT indicate whether the software is installed, executing, etc. (The latter is the role of the SoftwareFeature/ SoftwareElement classes and the Application Model.) Since software may be acquired, SoftwareIdentity can be associated with a Product using the ProductSoftwareComponent relationship. Note that the Application Model manages the deployment and installation of software via the classes, SoftwareFeatures and SoftwareElements. The deployment/installation concepts are related to the asset/identity one. In fact, a SoftwareIdentity may correspond to a Product, or to one or more SoftwareFeatures or SoftwareElements - depending on the granularity of these classes and the deployment model. The correspondence of Software Identity to Product, SoftwareFeature or SoftwareElement is indicated using the ConcreteIdentity association. Note that there may not be sufficient detail or instrumentation to instantiate ConcreteIdentity. And, if the association is instantiated, some duplication of information may result. For example, the Vendor described in the instances of Product and SoftwareIdentity MAY be the same. However, this is not necessarily true, and it is why vendor and similar information are duplicated in this class. Note that ConcreteIdentity can also be used to describe the relationship of the software to any LogicalFiles that result from installing it. As above, there may not be sufficient detail or instrumentation to instantiate this association."
  },
  "softwareElement_Manufacturer": {
    "name": "softwareElement_Manufacturer",
    "oid": "1.3.6.1.4.1.14851.3.1.9.2.1.5",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Manufacturer of this software element"
  },
  "softwareElement_BuildNumber": {
    "name": "softwareElement_BuildNumber",
    "oid": "1.3.6.1.4.1.14851.3.1.9.2.1.6",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The internal identifier for this compilation of this software element."
  },
  "softwareElement_SerialNumber": {
    "name": "softwareElement_SerialNumber",
    "oid": "1.3.6.1.4.1.14851.3.1.9.2.1.7",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The assigned serial number of this software element."
  },
  "softwareElement_CodeSet": {
    "name": "softwareElement_CodeSet",
    "oid": "1.3.6.1.4.1.14851.3.1.9.2.1.8",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "deprecated",
    "description": "The code set used by this software element. "
  },
  "softwareElement_IdentificationCode": {
    "name": "softwareElement_IdentificationCode",
    "oid": "1.3.6.1.4.1.14851.3.1.9.2.1.9",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "deprecated",
    "description": "The value of this property is the manufacturer's identifier for this software element. Often this will be a stock keeping unit (SKU) or a part number."
  },
  "softwareElement_LanguageEdition": {
    "name": "softwareElement_LanguageEdition",
    "oid": "1.3.6.1.4.1.14851.3.1.9.2.1.10",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 32
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "deprecated",
    "description": "The value of this property identifies the language edition of this software element. The language codes defined in ISO 639 should be used. Where the software element represents multi-lingual or international version of a product, the string multilingual should be used."
  },
  "softwareElement_InstanceID": {
    "name": "softwareElement_InstanceID",
    "oid": "1.3.6.1.4.1.14851.3.1.9.2.1.11",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Within the scope of the instantiating Namespace, InstanceID opaquely and uniquely identifies an instance of this class. In order to ensure uniqueness within the NameSpace, the value of InstanceID SHOULD be constructed using the following 'preferred' algorithm: <OrgID>:<LocalID> Where <OrgID> and <LocalID> are separated by a colon ':', and where <OrgID> MUST include a copyrighted, trademarked or otherwise unique name that is owned by the business entity creating/defining the InstanceID, or is a registered ID that is assigned to the business entity by a recognized global authority (This is similar to the <Schema Name>_<Class Name> structure of Schema class names.) In addition, to ensure uniqueness <OrgID> MUST NOT contain a colon (':'). When using this algorithm, the first colon to appear in InstanceID MUST appear between <OrgID> and <LocalID>. <LocalID> is chosen by the business entity and SHOULD not be re-used to identify different underlying (real-world) elements. If the above 'preferred' algorithm is not used, the defining entity MUST assure that the resultant InstanceID is not re-used across any InstanceIDs produced by this or other providers for this instance's NameSpace. For DMTF defined instances, the 'preferred' algorithm MUST be used with the <OrgID> set to 'CIM'."
  },
  "computerSystemGroup": {
    "name": "computerSystemGroup",
    "oid": "1.3.6.1.4.1.14851.3.1.10",
    "class": "objectidentity"
  },
  "computerSystem_ElementName": {
    "name": "computerSystem_ElementName",
    "oid": "1.3.6.1.4.1.14851.3.1.10.1",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A user-friendly name for the object. This property allows each instance to define a user-friendly name IN ADDITION TO its key properties/identity data, and description information. \\n Note that ManagedSystemElement's Name property is also defined as a user-friendly name. But, it is often subclassed to be a Key. It is not reasonable that the same property can convey both identity and a user friendly name, without inconsistencies. Where Name exists and is not a Key (such as for instances of LogicalDevice), the same information MAY be present in both the Name and ElementName properties."
  },
  "computerSystem_OperationalStatus": {
    "name": "computerSystem_OperationalStatus",
    "oid": "1.3.6.1.4.1.14851.3.1.10.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "other": 1,
          "ok": 2,
          "degraded": 3,
          "stressed": 4,
          "predictiveFailure": 5,
          "error": 6,
          "non-RecoverableError": 7,
          "starting": 8,
          "stopping": 9,
          "stopped": 10,
          "inService": 11,
          "noContact": 12,
          "lostCommunication": 13,
          "aborted": 14,
          "dormant": 15,
          "supportingEntityInError": 16,
          "completed": 17,
          "powerMode": 18,
          "dMTFReserved": 19,
          "vendorReserved": 32768
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Indicates the current status(es) of the element. Various health and operational statuses are defined. Many of the enumeration's values are self- explanatory. However, a few are not and are described in more detail. \\n 'Stressed' indicates that the element is functioning, but needs attention. Examples of 'Stressed' states are overload, overheated, etc. \\n 'Predictive Failure' indicates that an element is functioning nominally but predicting a failure in the near future. \\n 'In Service' describes an element being configured, maintained, cleaned, or otherwise administered. \\n 'No Contact' indicates that the monitoring system has knowledge of this element, but has never been able to establish communications with it. \\n 'Lost Communication' indicates that the ManagedSystem Element is known to exist and has been contacted successfully in the past, but is currently unreachable. \\n 'Stopped' and 'Aborted' are similar, although the former implies a clean and orderly stop, while the latter implies an abrupt stop where the element's state and configuration may need to be updated. \\n 'Dormant' indicates that the element is inactive or quiesced. \\n 'Supporting Entity in Error' describes that this element may be 'OK' but that another element, on which it is dependent, is in error. An example is a network service or endpoint that cannot function due to lower layer networking problems. \\n 'Completed' indicates the element has completed its operation. This value should be combined with either OK, Error, or Degraded so that a client can till if the complete operation passed (Completed with OK), and failure (Completed with Error). Completed with Degraded would imply the operation finished, but did not complete OK or report an error. \\n 'Power Mode' indicates the element has additional power model information contained in the Associated PowerManagementService association. \\n OperationalStatus replaces the Status property on ManagedSystemElement to provide a consistent approach to enumerations, to address implementation needs for an array property, and to provide a migration path from today's environment to the future. This change was not made earlier since it required the DEPRECATED qualifier. Due to the widespread use of the existing Status property in management applications, it is strongly RECOMMENDED that providers/instrumentation provide BOTH the Status and OperationalStatus properties. Further, the first value of OperationalStatus SHOULD contain the primary status for the element. When instrumented, Status (since it is single-valued) SHOULD also provide the primary status of the element."
  },
  "computerSystem_Name": {
    "name": "computerSystem_Name",
    "oid": "1.3.6.1.4.1.14851.3.1.10.3",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The Name property defines the label by which the object is known. When subclassed, the Name property can be overridden to be a Key property."
  },
  "computerSystem_NameFormat": {
    "name": "computerSystem_NameFormat",
    "oid": "1.3.6.1.4.1.14851.3.1.10.4",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The ComputerSystem object and its derivatives are Top Level Objects of CIM. They provide the scope for numerous components. Having unique System keys is required. The NameFormat property identifies how the ComputerSystem Name is generated. The NameFormat ValueMap qualifier defines the various mechanisms for assigning the name. Note that another name can be assigned and used for the ComputerSystem that better suit a business, using the inherited ElementName property. Possible values include 'Other', 'IP', 'Dial', 'HID', 'NWA', 'HWA', 'X25', 'ISDN', 'IPX', 'DCC', 'ICD', 'E.164', 'SNA', 'OID/OSI', 'WWN', 'NAA'"
  },
  "computerSystem_Dedicated": {
    "name": "computerSystem_Dedicated",
    "oid": "1.3.6.1.4.1.14851.3.1.10.5",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "notDedicated": 0,
          "unknown": 1,
          "other": 2,
          "storage": 3,
          "router": 4,
          "switch": 5,
          "layer3switch": 6,
          "centralOfficeSwitch": 7,
          "hub": 8,
          "accessServer": 9,
          "firewall": 10,
          "print": 11,
          "io": 12,
          "webCaching": 13,
          "management": 14,
          "blockServer": 15,
          "fileServer": 16,
          "mobileUserDevice": 17,
          "repeater": 18,
          "bridgeExtender": 19,
          "gateway": 20
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Enumeration indicating whether the ComputerSystem is a special-purpose System (ie, dedicated to a particular use), versus being 'general purpose'. For example, one could specify that the System is dedicated to 'Print' (value=11) or acts as a 'Hub' (value=8). \\n A clarification is needed with respect to the value 17 ('Mobile User Device'). An example of a dedicated user device is a mobile phone or a barcode scanner in a store that communicates via radio frequency. These systems are quite limited in functionality and programmability, and are not considered 'general purpose' computing platforms. Alternately, an example of a mobile system that is 'general purpose' (i.e., is NOT dedicated) is a hand-held computer. Although limited in its programmability, new software can be downloaded and its functionality expanded by the user."
  },
  "computerSystem_PrimaryOwnerContact": {
    "name": "computerSystem_PrimaryOwnerContact",
    "oid": "1.3.6.1.4.1.14851.3.1.10.6",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A string that provides information on how the primary system owner can be reached (e.g. phone number, email address, ...)"
  },
  "computerSystem_PrimaryOwnerName": {
    "name": "computerSystem_PrimaryOwnerName",
    "oid": "1.3.6.1.4.1.14851.3.1.10.7",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The name of the primary system owner. The system owner is the primary user of the system."
  },
  "computerSystem_Description": {
    "name": "computerSystem_Description",
    "oid": "1.3.6.1.4.1.14851.3.1.10.8",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The Description property provides a textual description of the object."
  },
  "computerSystem_Caption": {
    "name": "computerSystem_Caption",
    "oid": "1.3.6.1.4.1.14851.3.1.10.9",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The Caption property is a short textual description (one- line string) of the object."
  },
  "computerSystem_Realizes_softwareElementIndex": {
    "name": "computerSystem_Realizes_softwareElementIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.10.10",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the softwareElementIndex that this computerSystem is associated with. If no association exists an index of 0 may be returned."
  },
  "changerDeviceGroup": {
    "name": "changerDeviceGroup",
    "oid": "1.3.6.1.4.1.14851.3.1.11",
    "class": "objectidentity"
  },
  "numberOfChangerDevices": {
    "name": "numberOfChangerDevices",
    "oid": "1.3.6.1.4.1.14851.3.1.11.1",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "Integer32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "This value specifies the number of ChangerDevices that are present."
  },
  "changerDeviceTable": {
    "name": "changerDeviceTable",
    "oid": "1.3.6.1.4.1.14851.3.1.11.2",
    "nodetype": "table",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "status": "mandatory",
    "description": "The changerDevice class represents changerDevices in the library"
  },
  "changerDeviceEntry": {
    "name": "changerDeviceEntry",
    "oid": "1.3.6.1.4.1.14851.3.1.11.2.1",
    "nodetype": "row",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "indices": [
      {
        "module": "SNIA-SML-MIB",
        "object": "changerDeviceIndex",
        "implied": 0
      }
    ],
    "status": "mandatory",
    "description": "Each entry in the table contains information about a changerDevice that is present in the library."
  },
  "changerDeviceIndex": {
    "name": "changerDeviceIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.11.2.1.1",
    "nodetype": "column",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the changerDevice."
  },
  "changerDevice_DeviceID": {
    "name": "changerDevice_DeviceID",
    "oid": "1.3.6.1.4.1.14851.3.1.11.2.1.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "An address or other identifying information to uniquely name the LogicalDevice."
  },
  "changerDevice_MediaFlipSupported": {
    "name": "changerDevice_MediaFlipSupported",
    "oid": "1.3.6.1.4.1.14851.3.1.11.2.1.3",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "true": 1,
          "false": 2
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Boolean set to TRUE if the Changer supports media flipping. Media needs to be flipped when multi-sided PhysicalMedia are placed into a MediaAccessDevice that does NOT support dual sided access."
  },
  "changerDevice_ElementName": {
    "name": "changerDevice_ElementName",
    "oid": "1.3.6.1.4.1.14851.3.1.11.2.1.4",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A user-friendly name for the object. This property allows each instance to define a user-friendly name IN ADDITION TO its key properties/identity data, and description information. Note that ManagedSystemElement's Name property is also defined as a user-friendly name. But, it is often subclassed to be a Key. It is not reasonable that the same property can convey both identity and a user friendly name, without inconsistencies. Where Name exists and is not a Key (such as for instances of LogicalDevice), the same information MAY be present in both the Name and ElementName properties."
  },
  "changerDevice_Caption": {
    "name": "changerDevice_Caption",
    "oid": "1.3.6.1.4.1.14851.3.1.11.2.1.5",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The Caption property is a short textual description (one- line string) of the object."
  },
  "changerDevice_Description": {
    "name": "changerDevice_Description",
    "oid": "1.3.6.1.4.1.14851.3.1.11.2.1.6",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The Description property provides a textual description of the object."
  },
  "changerDevice_Availability": {
    "name": "changerDevice_Availability",
    "oid": "1.3.6.1.4.1.14851.3.1.11.2.1.8",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "other": 1,
          "unknown": 2,
          "runningFullPower": 3,
          "warning": 4,
          "inTest": 5,
          "notApplicable": 6,
          "powerOff": 7,
          "offLine": 8,
          "offDuty": 9,
          "degraded": 10,
          "notInstalled": 11,
          "installError": 12,
          "powerSaveUnknown": 13,
          "powerSaveLowPowerMode": 14,
          "powerSaveStandby": 15,
          "powerCycle": 16,
          "powerSaveWarning": 17,
          "paused": 18,
          "notReady": 19,
          "notConfigured": 20,
          "quiesced": 21
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The primary availability and status of the Device. (Additional status information can be specified using the Additional Availability array property.) For example, the Availability property indicates that the Device is running and has full power (value=3), or is in a warning (4), test (5), degraded (10) or power save state (values 13-15 and 17). Regarding the Power Save states, these are defined as follows Value 13 (\\'Power Save - Unknown\\') indicates that the Device is known to be in a power save mode, but its exact status in this mode is unknown; 14 (\\'Power Save - Low Power Mode\\') indicates that the Device is in a power save state but still functioning, and may exhibit degraded performance 15 (\\'Power Save - Standby\\') describes that the Device is not functioning but could be brought to full power 'quickly'; and value 17 (\\'Power Save - Warning\\') indicates that the Device is in a warning state, though also in a power save mode."
  },
  "changerDevice_OperationalStatus": {
    "name": "changerDevice_OperationalStatus",
    "oid": "1.3.6.1.4.1.14851.3.1.11.2.1.9",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "other": 1,
          "ok": 2,
          "degraded": 3,
          "stressed": 4,
          "predictiveFailure": 5,
          "error": 6,
          "non-RecoverableError": 7,
          "starting": 8,
          "stopping": 9,
          "stopped": 10,
          "inService": 11,
          "noContact": 12,
          "lostCommunication": 13,
          "aborted": 14,
          "dormant": 15,
          "supportingEntityInError": 16,
          "completed": 17,
          "powerMode": 18,
          "dMTFReserved": 19,
          "vendorReserved": 32768
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Indicates the current status(es) of the element. Various health and operational statuses are defined. Many of the enumeration's values are self- explanatory. However, a few are not and are described in more detail. \\n 'Stressed' indicates that the element is functioning, but needs attention. Examples of 'Stressed' states are overload, overheated, etc. \\n 'Predictive Failure' indicates that an element is functioning nominally but predicting a failure in the near future. \\n 'In Service' describes an element being configured, maintained, cleaned, or otherwise administered. \\n 'No Contact' indicates that the monitoring system has knowledge of this element, but has never been able to establish communications with it. \\n 'Lost Communication' indicates that the ManagedSystem Element is known to exist and has been contacted successfully in the past, but is currently unreachable. \\n 'Stopped' and 'Aborted' are similar, although the former implies a clean and orderly stop, while the latter implies an abrupt stop where the element's state and configuration may need to be updated. \\n 'Dormant' indicates that the element is inactive or quiesced. \\n 'Supporting Entity in Error' describes that this element may be 'OK' but that another element, on which it is dependent, is in error. An example is a network service or endpoint that cannot function due to lower layer networking problems. \\n 'Completed' indicates the element has completed its operation. This value should be combined with either OK, Error, or Degraded so that a client can till if the complete operation passed (Completed with OK), and failure (Completed with Error). Completed with Degraded would imply the operation finished, but did not complete OK or report an error. \\n 'Power Mode' indicates the element has additional power model information contained in the Associated PowerManagementService association. \\n OperationalStatus replaces the Status property on ManagedSystemElement to provide a consistent approach to enumerations, to address implementation needs for an array property, and to provide a migration path from today's environment to the future. This change was not made earlier since it required the DEPRECATED qualifier. Due to the widespread use of the existing Status property in management applications, it is strongly RECOMMENDED that providers/instrumentation provide BOTH the Status and OperationalStatus properties. Further, the first value of OperationalStatus SHOULD contain the primary status for the element. When instrumented, Status (since it is single-valued) SHOULD also provide the primary status of the element."
  },
  "changerDevice_Realizes_StorageLocationIndex": {
    "name": "changerDevice_Realizes_StorageLocationIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.11.2.1.10",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the storageMediaLocationIndex that this changerDevice is associated with. If no association exists an index of 0 may be returned."
  },
  "scsiProtocolControllerGroup": {
    "name": "scsiProtocolControllerGroup",
    "oid": "1.3.6.1.4.1.14851.3.1.12",
    "class": "objectidentity"
  },
  "numberOfSCSIProtocolControllers": {
    "name": "numberOfSCSIProtocolControllers",
    "oid": "1.3.6.1.4.1.14851.3.1.12.1",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "Integer32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "This value specifies the number of SCSIProtocolControllers that are present."
  },
  "scsiProtocolControllerTable": {
    "name": "scsiProtocolControllerTable",
    "oid": "1.3.6.1.4.1.14851.3.1.12.2",
    "nodetype": "table",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "status": "mandatory",
    "description": "The scsiProtocolController class represents SCSIProtocolControllers in the library"
  },
  "scsiProtocolControllerEntry": {
    "name": "scsiProtocolControllerEntry",
    "oid": "1.3.6.1.4.1.14851.3.1.12.2.1",
    "nodetype": "row",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "indices": [
      {
        "module": "SNIA-SML-MIB",
        "object": "scsiProtocolControllerIndex",
        "implied": 0
      }
    ],
    "status": "mandatory",
    "description": "Each entry in the table contains information about a SCSIProtocolController that is present in the library."
  },
  "scsiProtocolControllerIndex": {
    "name": "scsiProtocolControllerIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.12.2.1.1",
    "nodetype": "column",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the scsiProtocolController."
  },
  "scsiProtocolController_DeviceID": {
    "name": "scsiProtocolController_DeviceID",
    "oid": "1.3.6.1.4.1.14851.3.1.12.2.1.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "An address or other identifying information to uniquely name the LogicalDevice."
  },
  "scsiProtocolController_ElementName": {
    "name": "scsiProtocolController_ElementName",
    "oid": "1.3.6.1.4.1.14851.3.1.12.2.1.3",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A user-friendly name for the object. This property allows each instance to define a user-friendly name IN ADDITION TO its key properties/identity data, and description information. Note that ManagedSystemElement's Name property is also defined as a user-friendly name. But, it is often subclassed to be a Key. It is not reasonable that the same property can convey both identity and a user friendly name, without inconsistencies. Where Name exists and is not a Key (such as for instances of LogicalDevice), the same information MAY be present in both the Name and ElementName properties."
  },
  "scsiProtocolController_OperationalStatus": {
    "name": "scsiProtocolController_OperationalStatus",
    "oid": "1.3.6.1.4.1.14851.3.1.12.2.1.4",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "other": 1,
          "ok": 2,
          "degraded": 3,
          "stressed": 4,
          "predictiveFailure": 5,
          "error": 6,
          "non-RecoverableError": 7,
          "starting": 8,
          "stopping": 9,
          "stopped": 10,
          "inService": 11,
          "noContact": 12,
          "lostCommunication": 13,
          "aborted": 14,
          "dormant": 15,
          "supportingEntityInError": 16,
          "completed": 17,
          "powerMode": 18,
          "dMTFReserved": 19,
          "vendorReserved": 32768
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Indicates the current status(es) of the element. Various health and operational statuses are defined. Many of the enumeration's values are self- explanatory. However, a few are not and are described in more detail. \\n 'Stressed' indicates that the element is functioning, but needs attention. Examples of 'Stressed' states are overload, overheated, etc. \\n 'Predictive Failure' indicates that an element is functioning nominally but predicting a failure in the near future. \\n 'In Service' describes an element being configured, maintained, cleaned, or otherwise administered. \\n 'No Contact' indicates that the monitoring system has knowledge of this element, but has never been able to establish communications with it. \\n 'Lost Communication' indicates that the ManagedSystem Element is known to exist and has been contacted successfully in the past, but is currently unreachable. \\n 'Stopped' and 'Aborted' are similar, although the former implies a clean and orderly stop, while the latter implies an abrupt stop where the element's state and configuration may need to be updated. \\n 'Dormant' indicates that the element is inactive or quiesced. \\n 'Supporting Entity in Error' describes that this element may be 'OK' but that another element, on which it is dependent, is in error. An example is a network service or endpoint that cannot function due to lower layer networking problems. \\n 'Completed' indicates the element has completed its operation. This value should be combined with either OK, Error, or Degraded so that a client can till if the complete operation passed (Completed with OK), and failure (Completed with Error). Completed with Degraded would imply the operation finished, but did not complete OK or report an error. \\n 'Power Mode' indicates the element has additional power model information contained in the Associated PowerManagementService association. \\n OperationalStatus replaces the Status property on ManagedSystemElement to provide a consistent approach to enumerations, to address implementation needs for an array property, and to provide a migration path from today's environment to the future. This change was not made earlier since it required the DEPRECATED qualifier. Due to the widespread use of the existing Status property in management applications, it is strongly RECOMMENDED that providers/instrumentation provide BOTH the Status and OperationalStatus properties. Further, the first value of OperationalStatus SHOULD contain the primary status for the element. When instrumented, Status (since it is single-valued) SHOULD also provide the primary status of the element."
  },
  "scsiProtocolController_Description": {
    "name": "scsiProtocolController_Description",
    "oid": "1.3.6.1.4.1.14851.3.1.12.2.1.5",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The Description property provides a textual description of the object."
  },
  "scsiProtocolController_Availability": {
    "name": "scsiProtocolController_Availability",
    "oid": "1.3.6.1.4.1.14851.3.1.12.2.1.6",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "other": 1,
          "unknown": 2,
          "runningFullPower": 3,
          "warning": 4,
          "inTest": 5,
          "notApplicable": 6,
          "powerOff": 7,
          "offLine": 8,
          "offDuty": 9,
          "degraded": 10,
          "notInstalled": 11,
          "installError": 12,
          "powerSaveUnknown": 13,
          "powerSaveLowPowerMode": 14,
          "powerSaveStandby": 15,
          "powerCycle": 16,
          "powerSaveWarning": 17,
          "paused": 18,
          "notReady": 19,
          "notConfigured": 20,
          "quiesced": 21
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The primary availability and status of the Device. (Additional status information can be specified using the Additional Availability array property.) For example, the Availability property indicates that the Device is running and has full power (value=3), or is in a warning (4), test (5), degraded (10) or power save state (values 13-15 and 17). Regarding the Power Save states, these are defined as follows: Value 13 (\\'Power Save - Unknown\\') indicates that the Device is known to be in a power save mode, but its exact status in this mode is unknown; 14 (\\'Power Save - Low Power Mode\\') indicates that the Device is in a power save state but still functioning, and may exhibit degraded performance; 15 (\\'Power Save - Standby\\') describes that the Device is not functioning but could be brought to full power 'quickly'; and value 17 (\\'Power Save - Warning\\') indicates that the Device is in a warning state, though also in a power save mode."
  },
  "scsiProtocolController_Realizes_ChangerDeviceIndex": {
    "name": "scsiProtocolController_Realizes_ChangerDeviceIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.12.2.1.7",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the ChangerDeviceIndex that this scsiProtocolController is associated with. If no association exists an index of 0 may be returned."
  },
  "scsiProtocolController_Realizes_MediaAccessDeviceIndex": {
    "name": "scsiProtocolController_Realizes_MediaAccessDeviceIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.12.2.1.8",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the MediaAccessDeviceIndex that this scsiProtocolController is associated with. If no association exists an index of 0 may be returned."
  },
  "storageMediaLocationGroup": {
    "name": "storageMediaLocationGroup",
    "oid": "1.3.6.1.4.1.14851.3.1.13",
    "class": "objectidentity"
  },
  "numberOfStorageMediaLocations": {
    "name": "numberOfStorageMediaLocations",
    "oid": "1.3.6.1.4.1.14851.3.1.13.1",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "Integer32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "This value specifies the number of StorageMediaLocations that are present."
  },
  "numberOfPhysicalMedias": {
    "name": "numberOfPhysicalMedias",
    "oid": "1.3.6.1.4.1.14851.3.1.13.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "Integer32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "This value specifies the number of PhysicalMedia that are present."
  },
  "storageMediaLocationTable": {
    "name": "storageMediaLocationTable",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3",
    "nodetype": "table",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "status": "mandatory",
    "description": "StorageMediaLocation represents a possible location for an instance of PhysicalMedia. PhysicalMedia represents any type of documentation or storage medium, such as tapes, CDROMs, etc. This class is typically used to locate and manage Removable Media (versus Media sealed with the MediaAccessDevice, as a single Package, as is the case with hard disks). However, 'sealed' Media can also be modeled using this class, where the Media would then be associated with the PhysicalPackage using the PackagedComponent relationship. "
  },
  "storageMediaLocationEntry": {
    "name": "storageMediaLocationEntry",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1",
    "nodetype": "row",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "indices": [
      {
        "module": "SNIA-SML-MIB",
        "object": "storageMediaLocationIndex",
        "implied": 0
      }
    ],
    "status": "mandatory",
    "description": "Each entry in the table contains information about a StorageMediaLocation that is present in the library."
  },
  "storageMediaLocationIndex": {
    "name": "storageMediaLocationIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.1",
    "nodetype": "column",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the StorageMediaLocation."
  },
  "storageMediaLocation_Tag": {
    "name": "storageMediaLocation_Tag",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "An arbitrary string that uniquely identifies the Physical Element and serves as the Element's key. The Tag property can contain information such as asset tag or serial number data. The key for PhysicalElement is placed very high in the object hierarchy in order to independently identify the hardware/entity, regardless of physical placement in or on Cabinets, Adapters, etc. For example, a hotswappable or removeable component may be taken from its containing (scoping) Package and be temporarily unused. The object still continues to exist - and may even be inserted into a different scoping container. Therefore, the key for Physical Element is an arbitrary string and is defined independently of any placement or location-oriented hierarchy."
  },
  "storageMediaLocation_LocationType": {
    "name": "storageMediaLocation_LocationType",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.3",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "other": 1,
          "slot": 2,
          "magazine": 3,
          "mediaAccessDevice": 4,
          "interLibraryPort": 5,
          "limitedAccessPort": 6,
          "door": 7,
          "shelf": 8,
          "vault": 9
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The type of Location. For example, whether this is an individual Media \\'Slot\\' (value=2), a MediaAccessDevice (value=4) or a \\'Magazine\\' (value=3) is indicated in this property."
  },
  "storageMediaLocation_LocationCoordinates": {
    "name": "storageMediaLocation_LocationCoordinates",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.4",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "LocationCoordinates represent the physical location of the the FrameSlot instance. The property is defined as a free-form string to allow the location information to be described in vendor-unique terminology."
  },
  "storageMediaLocation_MediaTypesSupported": {
    "name": "storageMediaLocation_MediaTypesSupported",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.5",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "other": 1,
          "tape": 2,
          "qic": 3,
          "ait": 4,
          "dtf": 5,
          "dat": 6,
          "eightmmTape": 7,
          "nineteenmmTape": 8,
          "dlt": 9,
          "halfInchMO": 10,
          "catridgeDisk": 11,
          "jazDisk": 12,
          "zipDisk": 13,
          "syQuestDisk": 14,
          "winchesterDisk": 15,
          "cdRom": 16,
          "cdRomXA": 17,
          "cdI": 18,
          "cdRecordable": 19,
          "wORM": 20,
          "magneto-Optical": 21,
          "dvd": 22,
          "dvdRWPlus": 23,
          "dvdRAM": 24,
          "dvdROM": 25,
          "dvdVideo": 26,
          "divx": 27,
          "floppyDiskette": 28,
          "hardDisk": 29,
          "memoryCard": 30,
          "hardCopy": 31,
          "clikDisk": 32,
          "cdRW": 33,
          "cdDA": 34,
          "cdPlus": 35,
          "dvdRecordable": 36,
          "dvdRW": 37,
          "dvdAudio": 38,
          "dvd5": 39,
          "dvd9": 40,
          "dvd10": 41,
          "dvd18": 42,
          "moRewriteable": 43,
          "moWriteOnce": 44,
          "moLIMDOW": 45,
          "phaseChangeWO": 46,
          "phaseChangeRewriteable": 47,
          "phaseChangeDualRewriteable": 48,
          "ablativeWriteOnce": 49,
          "nearField": 50,
          "miniQic": 51,
          "travan": 52,
          "eightmmMetal": 53,
          "eightmmAdvanced": 54,
          "nctp": 55,
          "ltoUltrium": 56,
          "ltoAccelis": 57,
          "tape9Track": 58,
          "tape18Track": 59,
          "tape36Track": 60,
          "magstar3590": 61,
          "magstarMP": 62,
          "d2Tape": 63,
          "dstSmall": 64,
          "dstMedium": 65,
          "dstLarge": 66
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Certain StorageMediaLocations may only be able to accept a limited set of PhysicalMedia MediaTypes. This property defines an array containing the types of Media that are acceptable for placement in the Location. Additional information and description of the contained MediaTypes can be provided using the TypesDescription array. Also, size data (for example, DVD disc diameter) can be specified using the MediaSizesSupported array. \\n \\n Values defined here correspond to those in the CIM_Physical Media.MediaType property. This allows quick comparisons using value equivalence calculations. It is understood that there is no external physical difference between (for example) DVD- Video and DVD-RAM. But, equivalent values in both the Physical Media and StorageMediaLocation enumerations allows for one for one comparisons with no additional processing logic (i.e., the following is not required ... if \\'DVD-Video\\' then value=\\'DVD\\')."
  },
  "storageMediaLocation_MediaCapacity": {
    "name": "storageMediaLocation_MediaCapacity",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.6",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A StorageMediaLocation may hold more than one PhysicalMedia - for example, a Magazine. This property indicates the Physical Media capacity of the Location."
  },
  "storageMediaLocation_Association_ChangerDeviceIndex": {
    "name": "storageMediaLocation_Association_ChangerDeviceIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.7",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Experimental: The current index value for the ChangerDeviceIndex that this storageMediaLocation is associated with. If no association exists an index of 0 may be returned. This association allows a representation of the experimental "
  },
  "storageMediaLocation_PhysicalMediaPresent": {
    "name": "storageMediaLocation_PhysicalMediaPresent",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.10",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "true": 1,
          "false": 2
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "'true' when Physical Media is present in this storage location. When this is 'false' -physicalMedia- entries are undefined"
  },
  "storageMediaLocation_PhysicalMedia_Removable": {
    "name": "storageMediaLocation_PhysicalMedia_Removable",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.11",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "true": 1,
          "false": 2
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A PhysicalComponent is Removable if it is designed to be taken in and out of the physical container in which it is normally found, without impairing the function of the overall packaging. A Component can still be Removable if power must be 'off' in order to perform the removal. If power can be 'on' and the Component removed, then the Element is both Removable and HotSwappable. For example, an upgradeable Processor chip is Removable."
  },
  "storageMediaLocation_PhysicalMedia_Replaceable": {
    "name": "storageMediaLocation_PhysicalMedia_Replaceable",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.12",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "true": 1,
          "false": 2
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A PhysicalComponent is Replaceable if it is possible to replace (FRU or upgrade) the Element with a physically different one. For example, some ComputerSystems allow the main Processor chip to be upgraded to one of a higher clock rating. In this case, the Processor is said to be Replaceable. All Removable Components are inherently Replaceable."
  },
  "storageMediaLocation_PhysicalMedia_HotSwappable": {
    "name": "storageMediaLocation_PhysicalMedia_HotSwappable",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.13",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "true": 1,
          "false": 2
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A PhysicalComponent is HotSwappable if it is possible to replace the Element with a physically different but equivalent one while the containing Package has power applied to it (ie, is 'on'). For example, a fan Component may be designed to be HotSwappable. All HotSwappable Components are inherently Removable and Replaceable."
  },
  "storageMediaLocation_PhysicalMedia_Capacity": {
    "name": "storageMediaLocation_PhysicalMedia_Capacity",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.14",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT64",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The number of bytes that can be read from or written to a Media. This property is not applicable to 'Hard Copy' (documentation) or cleaner Media. Data compression should not be assumed, as it would increase the value in this property. For tapes, it should be assumed that no filemarks or blank space areas are recorded on the Media."
  },
  "storageMediaLocation_PhysicalMedia_MediaType": {
    "name": "storageMediaLocation_PhysicalMedia_MediaType",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.15",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "other": 1,
          "tape": 2,
          "qic": 3,
          "ait": 4,
          "dtf": 5,
          "dat": 6,
          "eightmmTape": 7,
          "nineteenmmTape": 8,
          "dlt": 9,
          "halfInchMO": 10,
          "catridgeDisk": 11,
          "jazDisk": 12,
          "zipDisk": 13,
          "syQuestDisk": 14,
          "winchesterDisk": 15,
          "cdRom": 16,
          "cdRomXA": 17,
          "cdI": 18,
          "cdRecordable": 19,
          "wORM": 20,
          "magneto-Optical": 21,
          "dvd": 22,
          "dvdRWPlus": 23,
          "dvdRAM": 24,
          "dvdROM": 25,
          "dvdVideo": 26,
          "divx": 27,
          "floppyDiskette": 28,
          "hardDisk": 29,
          "memoryCard": 30,
          "hardCopy": 31,
          "clikDisk": 32,
          "cdRW": 33,
          "cdDA": 34,
          "cdPlus": 35,
          "dvdRecordable": 36,
          "dvdRW": 37,
          "dvdAudio": 38,
          "dvd5": 39,
          "dvd9": 40,
          "dvd10": 41,
          "dvd18": 42,
          "moRewriteable": 43,
          "moWriteOnce": 44,
          "moLIMDOW": 45,
          "phaseChangeWO": 46,
          "phaseChangeRewriteable": 47,
          "phaseChangeDualRewriteable": 48,
          "ablativeWriteOnce": 49,
          "nearField": 50,
          "miniQic": 51,
          "travan": 52,
          "eightmmMetal": 53,
          "eightmmAdvanced": 54,
          "nctp": 55,
          "ltoUltrium": 56,
          "ltoAccelis": 57,
          "tape9Track": 58,
          "tape18Track": 59,
          "tape36Track": 60,
          "magstar3590": 61,
          "magstarMP": 62,
          "d2Tape": 63,
          "dstSmall": 64,
          "dstMedium": 65,
          "dstLarge": 66
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Specifies the type of the PhysicalMedia, as an enumerated integer. The MediaDescription property is used to provide more explicit definition of the Media type, whether it is pre-formatted, compatability features, etc."
  },
  "storageMediaLocation_PhysicalMedia_MediaDescription": {
    "name": "storageMediaLocation_PhysicalMedia_MediaDescription",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.16",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Additional detail related to the MediaType enumeration. For example, if value 3 ('QIC Cartridge') is specified, this property could indicate whether the tape is wide or 1/4 inch, whether it is pre-formatted, whether it is Travan compatible, etc."
  },
  "storageMediaLocation_PhysicalMedia_CleanerMedia": {
    "name": "storageMediaLocation_PhysicalMedia_CleanerMedia",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.17",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "true": 1,
          "false": 2
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Boolean indicating that the PhysicalMedia is used for cleaning purposes and not data storage."
  },
  "storageMediaLocation_PhysicalMedia_DualSided": {
    "name": "storageMediaLocation_PhysicalMedia_DualSided",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.18",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "true": 1,
          "false": 2
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Boolean indicating that the Media has two recording sides (TRUE) or only a single side (FALSE). Examples of dual sided Media include DVD-ROM and some optical disks. Examples of single sided Media are tapes and CD-ROM."
  },
  "storageMediaLocation_PhysicalMedia_PhysicalLabel": {
    "name": "storageMediaLocation_PhysicalMedia_PhysicalLabel",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.19",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "One or more strings on 'labels' on the PhysicalMedia. The format of the labels and their state (readable, unreadable, upside-down) are indicated in the LabelFormats and LabelStates array properties."
  },
  "storageMediaLocation_PhysicalMedia_Tag": {
    "name": "storageMediaLocation_PhysicalMedia_Tag",
    "oid": "1.3.6.1.4.1.14851.3.1.13.3.1.20",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "An arbitrary string that uniquely identifies the Physical Element and serves as the Element's key. The Tag property can contain information such as asset tag or serial data. The key for PhysicalElement is placed very high in number the object hierarchy in order to independently identify the hardware/entity, regardless of physical placement in or on Cabinets, Adapters, etc. For example, a hotswappable or removeable component may be taken from its containing (scoping) Package and be temporarily unused. The object still continues to exist - and may even be inserted into a different scoping container. Therefore, the key for Physical Element is an arbitrary string and is defined independently of any placement or location-oriented hierarchy."
  },
  "limitedAccessPortGroup": {
    "name": "limitedAccessPortGroup",
    "oid": "1.3.6.1.4.1.14851.3.1.14",
    "class": "objectidentity"
  },
  "numberOflimitedAccessPorts": {
    "name": "numberOflimitedAccessPorts",
    "oid": "1.3.6.1.4.1.14851.3.1.14.1",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "Integer32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "This value specifies the number of limitedAccessPorts that are present."
  },
  "limitedAccessPortTable": {
    "name": "limitedAccessPortTable",
    "oid": "1.3.6.1.4.1.14851.3.1.14.2",
    "nodetype": "table",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "status": "mandatory",
    "description": "The limitedAccessPort class represents limitedAccessPorts in the library"
  },
  "limitedAccessPortEntry": {
    "name": "limitedAccessPortEntry",
    "oid": "1.3.6.1.4.1.14851.3.1.14.2.1",
    "nodetype": "row",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "indices": [
      {
        "module": "SNIA-SML-MIB",
        "object": "limitedAccessPortIndex",
        "implied": 0
      }
    ],
    "status": "mandatory",
    "description": "Each entry in the table contains information about a limitedAccessPort that is present in the library."
  },
  "limitedAccessPortIndex": {
    "name": "limitedAccessPortIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.14.2.1.1",
    "nodetype": "column",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the limitedAccessPort."
  },
  "limitedAccessPort_DeviceID": {
    "name": "limitedAccessPort_DeviceID",
    "oid": "1.3.6.1.4.1.14851.3.1.14.2.1.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "An address or other identifying information to uniquely name the LogicalDevice."
  },
  "limitedAccessPort_Extended": {
    "name": "limitedAccessPort_Extended",
    "oid": "1.3.6.1.4.1.14851.3.1.14.2.1.3",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "true": 1,
          "false": 2
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "When a Port is 'Extended' or 'open' (value=TRUE), its Storage MediaLocations are accessible to a human operator. If not extended (value=FALSE), the Locations are accessible to a PickerElement."
  },
  "limitedAccessPort_ElementName": {
    "name": "limitedAccessPort_ElementName",
    "oid": "1.3.6.1.4.1.14851.3.1.14.2.1.4",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A user-friendly name for the object. This property allows each instance to define a user-friendly name IN ADDITION TO its key properties/identity data, and description information. Note that ManagedSystemElement's Name property is also defined as a user-friendly name. But, it is often subclassed to be a Key. It is not reasonable that the same property can convey both identity and a user friendly name, without inconsistencies. Where Name exists and is not a Key (such as for instances of LogicalDevice), the same information MAY be present in both the Name and ElementName properties."
  },
  "limitedAccessPort_Caption": {
    "name": "limitedAccessPort_Caption",
    "oid": "1.3.6.1.4.1.14851.3.1.14.2.1.5",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The Caption property is a short textual description (one- line string) of the object."
  },
  "limitedAccessPort_Description": {
    "name": "limitedAccessPort_Description",
    "oid": "1.3.6.1.4.1.14851.3.1.14.2.1.6",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The Description property provides a textual description of the object."
  },
  "limitedAccessPort_Realizes_StorageLocationIndex": {
    "name": "limitedAccessPort_Realizes_StorageLocationIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.14.2.1.7",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the storageMediaLocationIndex that this limitedAccessPort is associated with. If no association exists an index of 0 may be returned."
  },
  "fCPortGroup": {
    "name": "fCPortGroup",
    "oid": "1.3.6.1.4.1.14851.3.1.15",
    "class": "objectidentity"
  },
  "numberOffCPorts": {
    "name": "numberOffCPorts",
    "oid": "1.3.6.1.4.1.14851.3.1.15.1",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "Integer32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "This value specifies the number of fcPorts that are present."
  },
  "fCPortTable": {
    "name": "fCPortTable",
    "oid": "1.3.6.1.4.1.14851.3.1.15.2",
    "nodetype": "table",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "status": "mandatory",
    "description": "The fcPort class represents Fibre Channel Ports in the library"
  },
  "fCPortEntry": {
    "name": "fCPortEntry",
    "oid": "1.3.6.1.4.1.14851.3.1.15.2.1",
    "nodetype": "row",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "indices": [
      {
        "module": "SNIA-SML-MIB",
        "object": "fCPortIndex",
        "implied": 0
      }
    ],
    "status": "mandatory",
    "description": "Each entry in the table contains information about an fcPort that is present in the library."
  },
  "fCPortIndex": {
    "name": "fCPortIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.15.2.1.1",
    "nodetype": "column",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the fCPort."
  },
  "fCPort_DeviceID": {
    "name": "fCPort_DeviceID",
    "oid": "1.3.6.1.4.1.14851.3.1.15.2.1.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "An address or other identifying information to uniquely name the LogicalDevice."
  },
  "fCPort_ElementName": {
    "name": "fCPort_ElementName",
    "oid": "1.3.6.1.4.1.14851.3.1.15.2.1.3",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "A user-friendly name for the object. This property allows each instance to define a user-friendly name IN ADDITION TO its key properties/identity data, and description information. Note that ManagedSystemElement's Name property is also defined as a user-friendly name. But, it is often subclassed to be a Key. It is not reasonable that the same property can convey both identity and a user friendly name, without inconsistencies. Where Name exists and is not a Key (such as for instances of LogicalDevice), the same information MAY be present in both the Name and ElementName properties."
  },
  "fCPort_Caption": {
    "name": "fCPort_Caption",
    "oid": "1.3.6.1.4.1.14851.3.1.15.2.1.4",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The Caption property is a short textual description (one- line string) of the object."
  },
  "fCPort_Description": {
    "name": "fCPort_Description",
    "oid": "1.3.6.1.4.1.14851.3.1.15.2.1.5",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 255
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The Description property provides a textual description of the object."
  },
  "fCPortController_OperationalStatus": {
    "name": "fCPortController_OperationalStatus",
    "oid": "1.3.6.1.4.1.14851.3.1.15.2.1.6",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "other": 1,
          "ok": 2,
          "degraded": 3,
          "stressed": 4,
          "predictiveFailure": 5,
          "error": 6,
          "non-RecoverableError": 7,
          "starting": 8,
          "stopping": 9,
          "stopped": 10,
          "inService": 11,
          "noContact": 12,
          "lostCommunication": 13,
          "aborted": 14,
          "dormant": 15,
          "supportingEntityInError": 16,
          "completed": 17,
          "powerMode": 18,
          "dMTFReserved": 19,
          "vendorReserved": 32768
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Indicates the current status(es) of the element. Various health and operational statuses are defined. Many of the enumeration's values are self- explanatory. However, a few are not and are described in more detail. \\n 'Stressed' indicates that the element is functioning, but needs attention. Examples of 'Stressed' states are overload, overheated, etc. \\n 'Predictive Failure' indicates that an element is functioning nominally but predicting a failure in the near future. \\n 'In Service' describes an element being configured, maintained, cleaned, or otherwise administered. \\n 'No Contact' indicates that the monitoring system has knowledge of this element, but has never been able to establish communications with it. \\n 'Lost Communication' indicates that the ManagedSystem Element is known to exist and has been contacted successfully in the past, but is currently unreachable. \\n 'Stopped' and 'Aborted' are similar, although the former implies a clean and orderly stop, while the latter implies an abrupt stop where the element's state and configuration may need to be updated. \\n 'Dormant' indicates that the element is inactive or quiesced. \\n 'Supporting Entity in Error' describes that this element may be 'OK' but that another element, on which it is dependent, is in error. An example is a network service or endpoint that cannot function due to lower layer networking problems. \\n 'Completed' indicates the element has completed its operation. This value should be combined with either OK, Error, or Degraded so that a client can till if the complete operation passed (Completed with OK), and failure (Completed with Error). Completed with Degraded would imply the operation finished, but did not complete OK or report an error. \\n 'Power Mode' indicates the element has additional power model information contained in the Associated PowerManagementService association. \\n OperationalStatus replaces the Status property on ManagedSystemElement to provide a consistent approach to enumerations, to address implementation needs for an array property, and to provide a migration path from today's environment to the future. This change was not made earlier since it required the DEPRECATED qualifier. Due to the widespread use of the existing Status property in management applications, it is strongly RECOMMENDED that providers/instrumentation provide BOTH the Status and OperationalStatus properties. Further, the first value of OperationalStatus SHOULD contain the primary status for the element. When instrumented, Status (since it is single-valued) SHOULD also provide the primary status of the element. SMI-S 1.1 Section 8.1.2.2.3 additional description for FC Ports OK - Port is online Error - Port has a failure Stopped - Port is disabled InService - Port is in Self Test Unknown"
  },
  "fCPort_PermanentAddress": {
    "name": "fCPort_PermanentAddress",
    "oid": "1.3.6.1.4.1.14851.3.1.15.2.1.7",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type",
      "constraints": {
        "size": [
          {
            "min": 0,
            "max": 64
          }
        ]
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "PermanentAddress defines the network address hardcoded into a port. This 'hardcoded' address may be changed via firmware upgrade or software configuration. If so, this field should be updated when the change is made. PermanentAddress should be left blank if no 'hardcoded' address exists for the NetworkAdapter. In SMI-S 1.1 table 1304 FCPorts are defined to use the port WWN as described in table 7.2.4.5.2 World Wide Name (i.e. FC Name_Identifier) FCPort Permanent Address property; no corresponding format property 16 un-separated upper case hex digits (e.g. '21000020372D3C73')"
  },
  "fCPort_Realizes_scsiProtocolControllerIndex": {
    "name": "fCPort_Realizes_scsiProtocolControllerIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.15.2.1.8",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the scsiProtocolControllerIndex that this fCPort is associated with. If no association exists an index of 0 may be returned."
  },
  "trapGroup": {
    "name": "trapGroup",
    "oid": "1.3.6.1.4.1.14851.3.1.16",
    "class": "objectidentity"
  },
  "trapsEnabled": {
    "name": "trapsEnabled",
    "oid": "1.3.6.1.4.1.14851.3.1.16.1",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "enabled": 1,
          "disabled": 2
        }
      }
    },
    "maxaccess": "read-write",
    "status": "mandatory",
    "description": "Set to enable sending traps"
  },
  "trapDriveAlertSummary": {
    "name": "trapDriveAlertSummary",
    "oid": "1.3.6.1.4.1.14851.3.1.16.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "readWarning": 1,
          "writeWarning": 2,
          "hardError": 3,
          "media": 4,
          "readFailure": 5,
          "writeFailure": 6,
          "mediaLife": 7,
          "notDataGrade": 8,
          "writeProtect": 9,
          "noRemoval": 10,
          "cleaningMedia": 11,
          "unsupportedFormat": 12,
          "recoverableSnappedTape": 13,
          "unrecoverableSnappedTape": 14,
          "memoryChipInCartridgeFailure": 15,
          "forcedEject": 16,
          "readOnlyFormat": 17,
          "directoryCorruptedOnLoad": 18,
          "nearingMediaLife": 19,
          "cleanNow": 20,
          "cleanPeriodic": 21,
          "expiredCleaningMedia": 22,
          "invalidCleaningMedia": 23,
          "retentionRequested": 24,
          "dualPortInterfaceError": 25,
          "coolingFanError": 26,
          "powerSupplyFailure": 27,
          "powerConsumption": 28,
          "driveMaintenance": 29,
          "hardwareA": 30,
          "hardwareB": 31,
          "interface": 32,
          "ejectMedia": 33,
          "downloadFailure": 34,
          "driveHumidity": 35,
          "driveTemperature": 36,
          "driveVoltage": 37,
          "predictiveFailure": 38,
          "diagnosticsRequired": 39,
          "lostStatistics": 50,
          "mediaDirectoryInvalidAtUnload": 51,
          "mediaSystemAreaWriteFailure": 52,
          "mediaSystemAreaReadFailure": 53,
          "noStartOfData": 54,
          "loadingFailure": 55,
          "unrecoverableUnloadFailure": 56,
          "automationInterfaceFailure": 57,
          "firmwareFailure": 58,
          "wormMediumIntegrityCheckFailed": 59,
          "wormMediumOverwriteAttempted": 60
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Short summary of a media (tape, optical, etc.) driveAlert trap. Corresponds to the Number/Flag property of drive/autoloader alerts in the T10 TapeAlert Specification v3 (w/SSC-3 Enhancements) as modified by the EventSummary property in the SMI-S 1.1 section 8.1.8.25 LibraryAlert Events/Indications for Library Devices. In particular, all occurances of 'tape' have been replaced with 'media'. (This summary property has a 1 to 1 relationship to the CIM_AlertIndication.OtherAlertType property, and might be stored in the CIM_AlertIndication.Message property.)"
  },
  "trap_Association_MediaAccessDeviceIndex": {
    "name": "trap_Association_MediaAccessDeviceIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.16.3",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the MediaAccessDeviceIndex that this changerAlert trap is associated with. If no association exists an index of 0 may be returned. "
  },
  "trapChangerAlertSummary": {
    "name": "trapChangerAlertSummary",
    "oid": "1.3.6.1.4.1.14851.3.1.16.4",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "libraryHardwareA": 1,
          "libraryHardwareB": 2,
          "libraryHardwareC": 3,
          "libraryHardwareD": 4,
          "libraryDiagnosticsRequired": 5,
          "libraryInterface": 6,
          "failurePrediction": 7,
          "libraryMaintenance": 8,
          "libraryHumidityLimits": 9,
          "libraryTemperatureLimits": 10,
          "libraryVoltageLimits": 11,
          "libraryStrayMedia": 12,
          "libraryPickRetry": 13,
          "libraryPlaceRetry": 14,
          "libraryLoadRetry": 15,
          "libraryDoor": 16,
          "libraryMailslot": 17,
          "libraryMagazine": 18,
          "librarySecurity": 19,
          "librarySecurityMode": 20,
          "libraryOffline": 21,
          "libraryDriveOffline": 22,
          "libraryScanRetry": 23,
          "libraryInventory": 24,
          "libraryIllegalOperation": 25,
          "dualPortInterfaceError": 26,
          "coolingFanFailure": 27,
          "powerSupply": 28,
          "powerConsumption": 29,
          "passThroughMechanismFailure": 30,
          "cartridgeInPassThroughMechanism": 31,
          "unreadableBarCodeLabels": 32
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Short summary of a changer (eg. robot) changerAlert trap. Corresponds to the Number/Flag property of stand-alone changer alerts in the T10 TapeAlert Specification v3 (w/SSC-3 Enhancements) as modified by the EventSummary property in the SMI-S 1.1 section 8.1.8.25 LibraryAlert Events/Indications for Library Devices. In particular, all occurances of 'tape' have been replaced with 'media'. (This summary property has a 1 to 1 relationship to the CIM_AlertIndication.OtherAlertType property, and might be stored in the CIM_AlertIndication.Message property.)"
  },
  "trap_Association_ChangerDeviceIndex": {
    "name": "trap_Association_ChangerDeviceIndex",
    "oid": "1.3.6.1.4.1.14851.3.1.16.5",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "UINT32",
      "class": "type"
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "The current index value for the ChangerDeviceIndex that this changerAlert trap is associated with. If no association exists an index of 0 may be returned. "
  },
  "trapPerceivedSeverity": {
    "name": "trapPerceivedSeverity",
    "oid": "1.3.6.1.4.1.14851.3.1.16.6",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "other": 1,
          "information": 2,
          "degradedWarning": 3,
          "minor": 4,
          "major": 5,
          "critical": 6,
          "fatalNonRecoverable": 7
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "An enumerated value that describes the severity of the Alert Indication from the notifier's point of view: 1 - Other, by CIM convention, is used to indicate that the Severity's value can be found in the OtherSeverity property. 3 - Degraded/Warning should be used when its appropriate to let the user decide if action is needed. 4 - Minor should be used to indicate action is needed, but the situation is not serious at this time. 5 - Major should be used to indicate action is needed NOW. 6 - Critical should be used to indicate action is needed NOW and the scope is broad (perhaps an imminent outage to a critical resource will result). 7 - Fatal/NonRecoverable should be used to indicate an error occurred, but it's too late to take remedial action. 2 and 0 - Information and Unknown (respectively) follow common usage. Literally, the AlertIndication is purely informational or its severity is simply unknown. This would have values described in SMI-S 1.1 section 8.1.8.25 LibraryAlert Events/Indications for Library Devices, the PerceivedSeverity column. These values are a superset of the Info/Warning/Critical values in the T10 TapeAlert Specification v3 (w/SSC-3 Enhancements) , and an SNMP agent may choose to only specify those if that's all that's available. (This corresponds to the CIM_AlertIndication.PerceivedSeverity property.)"
  },
  "trapDestinationTable": {
    "name": "trapDestinationTable",
    "oid": "1.3.6.1.4.1.14851.3.1.16.7",
    "nodetype": "table",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "status": "mandatory",
    "description": "Table of client/manager desitinations which will receive traps"
  },
  "trapDestinationEntry": {
    "name": "trapDestinationEntry",
    "oid": "1.3.6.1.4.1.14851.3.1.16.7.1",
    "nodetype": "row",
    "class": "objecttype",
    "maxaccess": "not-accessible",
    "indices": [
      {
        "module": "SNIA-SML-MIB",
        "object": "numberOfTrapDestinations",
        "implied": 0
      }
    ],
    "status": "mandatory",
    "description": "Entry containing information needed to send traps to an SNMP client/manager"
  },
  "numberOfTrapDestinations": {
    "name": "numberOfTrapDestinations",
    "oid": "1.3.6.1.4.1.14851.3.1.16.7.1.1",
    "nodetype": "column",
    "class": "objecttype",
    "syntax": {
      "type": "Integer32",
      "class": "type"
    },
    "maxaccess": "read-write",
    "status": "mandatory",
    "description": "This value specifies the number of trap destination SNMP clients/managers."
  },
  "trapDestinationHostType": {
    "name": "trapDestinationHostType",
    "oid": "1.3.6.1.4.1.14851.3.1.16.7.1.2",
    "nodetype": "column",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "iPv4": 1,
          "iPv6": 2
        }
      }
    },
    "maxaccess": "read-write",
    "status": "mandatory",
    "description": "The type of addressing model to represent the network address (IPv4/IPv6)"
  },
  "trapDestinationHostAddr": {
    "name": "trapDestinationHostAddr",
    "oid": "1.3.6.1.4.1.14851.3.1.16.7.1.3",
    "nodetype": "column",
    "class": "objecttype",
    "syntax": {
      "type": "DisplayString",
      "class": "type"
    },
    "maxaccess": "read-write",
    "status": "mandatory",
    "description": "The network address of this client/manager, to which the trap should be sent"
  },
  "trapDestinationPort": {
    "name": "trapDestinationPort",
    "oid": "1.3.6.1.4.1.14851.3.1.16.7.1.4",
    "nodetype": "column",
    "class": "objecttype",
    "syntax": {
      "type": "Integer32",
      "class": "type",
      "constraints": {
        "range": [
          {
            "min": 0,
            "max": 65535
          }
        ]
      }
    },
    "maxaccess": "read-write",
    "status": "mandatory",
    "description": "The port number where this client/manager is listening for traps."
  },
  "driveAlert": {
    "name": "driveAlert",
    "oid": "1.3.6.1.4.1.14851.3.10.0",
    "class": "notificationtype",
    "objects": [
      {
        "module": "SNIA-SML-MIB",
        "object": "trapDriveAlertSummary"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "trap_Association_MediaAccessDeviceIndex"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "trapPerceivedSeverity"
      }
    ],
    "description": "A Drive/Autoloader Alert trap, based on the T10 TapeAlert Specification v3 (w/SSC-3 Enhancements) and SMI-S 1.1 section 8.1.8.25 LibraryAlert Events/Indications."
  },
  "changerAlert": {
    "name": "changerAlert",
    "oid": "1.3.6.1.4.1.14851.3.10.1",
    "class": "notificationtype",
    "objects": [
      {
        "module": "SNIA-SML-MIB",
        "object": "trapChangerAlertSummary"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "trap_Association_ChangerDeviceIndex"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "trapPerceivedSeverity"
      }
    ],
    "description": "A Changer Device (eg. robot) Alert trap, based on the T10 TapeAlert Specification v3 (w/SSC-3 Enhancements) and SMI-S 1.1 section 8.1.8.25 LibraryAlert Events/Indications."
  },
  "trapObjects": {
    "name": "trapObjects",
    "oid": "1.3.6.1.4.1.14851.3.1.16.8",
    "class": "objectidentity"
  },
  "currentOperationalStatus": {
    "name": "currentOperationalStatus",
    "oid": "1.3.6.1.4.1.14851.3.1.16.8.1",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "other": 1,
          "ok": 2,
          "degraded": 3,
          "stressed": 4,
          "predictiveFailure": 5,
          "error": 6,
          "non-RecoverableError": 7,
          "starting": 8,
          "stopping": 9,
          "stopped": 10,
          "inService": 11,
          "noContact": 12,
          "lostCommunication": 13,
          "aborted": 14,
          "dormant": 15,
          "supportingEntityInError": 16,
          "completed": 17,
          "powerMode": 18,
          "dMTFReserved": 19,
          "vendorReserved": 32768
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Indicates the previous status(es) of the element. Various health and operational statuses are defined. Many of the enumeration's values are self- explanatory. However, a few are not and are described in more detail. \\n 'Stressed' indicates that the element is functioning, but needs attention. Examples of 'Stressed' states are overload, overheated, etc. \\n 'Predictive Failure' indicates that an element is functioning nominally but predicting a failure in the near future. \\n 'In Service' describes an element being configured, maintained, cleaned, or otherwise administered. \\n 'No Contact' indicates that the monitoring system has knowledge of this element, but has never been able to establish communications with it. \\n 'Lost Communication' indicates that the ManagedSystem Element is known to exist and has been contacted successfully in the past, but is currently unreachable. \\n 'Stopped' and 'Aborted' are similar, although the former implies a clean and orderly stop, while the latter implies an abrupt stop where the element's state and configuration may need to be updated. \\n 'Dormant' indicates that the element is inactive or quiesced. \\n 'Supporting Entity in Error' describes that this element may be 'OK' but that another element, on which it is dependent, is in error. An example is a network service or endpoint that cannot function due to lower layer networking problems. \\n 'Completed' indicates the element has completed its operation. This value should be combined with either OK, Error, or Degraded so that a client can till if the complete operation passed (Completed with OK), and failure (Completed with Error). Completed with Degraded would imply the operation finished, but did not complete OK or report an error. \\n 'Power Mode' indicates the element has additional power model information contained in the Associated PowerManagementService association. \\n OperationalStatus replaces the Status property on ManagedSystemElement to provide a consistent approach to enumerations, to address implementation needs for an array property, and to provide a migration path from today's environment to the future. This change was not made earlier since it required the DEPRECATED qualifier. Due to the widespread use of the existing Status property in management applications, it is strongly RECOMMENDED that providers/instrumentation provide BOTH the Status and OperationalStatus properties. Further, the first value of OperationalStatus SHOULD contain the primary status for the element. When instrumented, Status (since it is single-valued) SHOULD also provide the primary status of the element."
  },
  "oldOperationalStatus": {
    "name": "oldOperationalStatus",
    "oid": "1.3.6.1.4.1.14851.3.1.16.8.2",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "INTEGER",
      "class": "type",
      "constraints": {
        "enumeration": {
          "unknown": 0,
          "other": 1,
          "ok": 2,
          "degraded": 3,
          "stressed": 4,
          "predictiveFailure": 5,
          "error": 6,
          "non-RecoverableError": 7,
          "starting": 8,
          "stopping": 9,
          "stopped": 10,
          "inService": 11,
          "noContact": 12,
          "lostCommunication": 13,
          "aborted": 14,
          "dormant": 15,
          "supportingEntityInError": 16,
          "completed": 17,
          "powerMode": 18,
          "dMTFReserved": 19,
          "vendorReserved": 32768
        }
      }
    },
    "maxaccess": "read-only",
    "status": "mandatory",
    "description": "Indicates the previous status(es) of the element. Various health and operational statuses are defined. Many of the enumeration's values are self- explanatory. However, a few are not and are described in more detail. \\n 'Stressed' indicates that the element is functioning, but needs attention. Examples of 'Stressed' states are overload, overheated, etc. \\n 'Predictive Failure' indicates that an element is functioning nominally but predicting a failure in the near future. \\n 'In Service' describes an element being configured, maintained, cleaned, or otherwise administered. \\n 'No Contact' indicates that the monitoring system has knowledge of this element, but has never been able to establish communications with it. \\n 'Lost Communication' indicates that the ManagedSystem Element is known to exist and has been contacted successfully in the past, but is currently unreachable. \\n 'Stopped' and 'Aborted' are similar, although the former implies a clean and orderly stop, while the latter implies an abrupt stop where the element's state and configuration may need to be updated. \\n 'Dormant' indicates that the element is inactive or quiesced. \\n 'Supporting Entity in Error' describes that this element may be 'OK' but that another element, on which it is dependent, is in error. An example is a network service or endpoint that cannot function due to lower layer networking problems. \\n 'Completed' indicates the element has completed its operation. This value should be combined with either OK, Error, or Degraded so that a client can till if the complete operation passed (Completed with OK), and failure (Completed with Error). Completed with Degraded would imply the operation finished, but did not complete OK or report an error. \\n 'Power Mode' indicates the element has additional power model information contained in the Associated PowerManagementService association. \\n OperationalStatus replaces the Status property on ManagedSystemElement to provide a consistent approach to enumerations, to address implementation needs for an array property, and to provide a migration path from today's environment to the future. This change was not made earlier since it required the DEPRECATED qualifier. Due to the widespread use of the existing Status property in management applications, it is strongly RECOMMENDED that providers/instrumentation provide BOTH the Status and OperationalStatus properties. Further, the first value of OperationalStatus SHOULD contain the primary status for the element. When instrumented, Status (since it is single-valued) SHOULD also provide the primary status of the element."
  },
  "libraryAddedTrap": {
    "name": "libraryAddedTrap",
    "oid": "1.3.6.1.4.1.14851.3.1.160.3",
    "class": "notificationtype",
    "objects": [
      {
        "module": "SNIA-SML-MIB",
        "object": "storageLibrary_Name"
      }
    ],
    "description": "A library is added to the SMI-S agent. This trap is to support the SMI-S 1.1 section 8.1.8.23 InstCreation indication."
  },
  "libraryDeletedTrap": {
    "name": "libraryDeletedTrap",
    "oid": "1.3.6.1.4.1.14851.3.1.160.4",
    "class": "notificationtype",
    "objects": [
      {
        "module": "SNIA-SML-MIB",
        "object": "storageLibrary_Name"
      }
    ],
    "description": "A library is deleted in the SMI-S agent. This trap is to support the SMI-S 1.1 section 8.1.8.23 InstDeletion indication."
  },
  "libraryOpStatusChangedTrap": {
    "name": "libraryOpStatusChangedTrap",
    "oid": "1.3.6.1.4.1.14851.3.1.160.5",
    "class": "notificationtype",
    "objects": [
      {
        "module": "SNIA-SML-MIB",
        "object": "storageLibrary_Name"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "currentOperationalStatus"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "oldOperationalStatus"
      }
    ],
    "description": "A library OperationalStatus has changed in the SMI-S agent. This trap is to support the SMI-S 1.1 section 8.1.8.23 InstModification indication."
  },
  "driveAddedTrap": {
    "name": "driveAddedTrap",
    "oid": "1.3.6.1.4.1.14851.3.1.160.6",
    "class": "notificationtype",
    "objects": [
      {
        "module": "SNIA-SML-MIB",
        "object": "storageLibrary_Name"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "mediaAccessDevice_DeviceID"
      }
    ],
    "description": "A media access device (trap drive) is added to the library. This trap is to support the SMI-S 1.1 section 8.1.8.25 InstCreation indication."
  },
  "driveDeletedTrap": {
    "name": "driveDeletedTrap",
    "oid": "1.3.6.1.4.1.14851.3.1.160.7",
    "class": "notificationtype",
    "objects": [
      {
        "module": "SNIA-SML-MIB",
        "object": "storageLibrary_Name"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "mediaAccessDevice_DeviceID"
      }
    ],
    "description": "A media access device (trap drive) is deleted from the library. This trap is to support the SMI-S 1.1 section 8.1.8.25 InstDeletion indication."
  },
  "driveOpStatusChangedTrap": {
    "name": "driveOpStatusChangedTrap",
    "oid": "1.3.6.1.4.1.14851.3.1.160.8",
    "class": "notificationtype",
    "objects": [
      {
        "module": "SNIA-SML-MIB",
        "object": "storageLibrary_Name"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "mediaAccessDevice_DeviceID"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "currentOperationalStatus"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "oldOperationalStatus"
      }
    ],
    "description": "A drive OperationalStatus has changed in the SMI-S agent. This trap is to support the SMI-S 1.1 section 8.1.8.23 InstModification indication."
  },
  "changerAddedTrap": {
    "name": "changerAddedTrap",
    "oid": "1.3.6.1.4.1.14851.3.1.160.9",
    "class": "notificationtype",
    "objects": [
      {
        "module": "SNIA-SML-MIB",
        "object": "storageLibrary_Name"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "changerDevice_DeviceID"
      }
    ],
    "description": "A changer device is added to the library. This trap is to support the SMI-S 1.1 section 8.1.8.25 InstCreation indication."
  },
  "changerDeletedTrap": {
    "name": "changerDeletedTrap",
    "oid": "1.3.6.1.4.1.14851.3.1.160.10",
    "class": "notificationtype",
    "objects": [
      {
        "module": "SNIA-SML-MIB",
        "object": "storageLibrary_Name"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "changerDevice_DeviceID"
      }
    ],
    "description": "A changer device is deleted from the library. This trap is to support the SMI-S 1.1 section 8.1.8.25 InstDeletion indication."
  },
  "changerOpStatusChangedTrap": {
    "name": "changerOpStatusChangedTrap",
    "oid": "1.3.6.1.4.1.14851.3.1.160.11",
    "class": "notificationtype",
    "objects": [
      {
        "module": "SNIA-SML-MIB",
        "object": "storageLibrary_Name"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "changerDevice_DeviceID"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "currentOperationalStatus"
      },
      {
        "module": "SNIA-SML-MIB",
        "object": "oldOperationalStatus"
      }
    ],
    "description": "A changer OperationalStatus has changed in the SMI-S agent. This trap is to support the SMI-S 1.1 section 8.1.8.23 InstModification indication."
  },
  "physicalMediaAddedTrap": {
    "name": "physicalMediaAddedTrap",
    "oid": "1.3.6.1.4.1.14851.3.1.160.12",
    "class": "notificationtype",
    "objects": [
      {
        "module": "SNIA-SML-MIB",
        "object": "storageMediaLocation_PhysicalMedia_Tag"
      }
    ],
    "description": "A physical media is added to the library. This trap is to support the SMI-S 1.1 section 8.1.8.25 InstCreation indication."
  },
  "physicalMediaDeletedTrap": {
    "name": "physicalMediaDeletedTrap",
    "oid": "1.3.6.1.4.1.14851.3.1.160.13",
    "class": "notificationtype",
    "objects": [
      {
        "module": "SNIA-SML-MIB",
        "object": "storageMediaLocation_PhysicalMedia_Tag"
      }
    ],
    "description": "A physical media is deleted from the library. This trap is to support the SMI-S 1.1 section 8.1.8.25 InstDeletion indication."
  },
  "endOfSmlMib": {
    "name": "endOfSmlMib",
    "oid": "1.3.6.1.4.1.14851.3.1.17",
    "nodetype": "scalar",
    "class": "objecttype",
    "syntax": {
      "type": "OBJECT IDENTIFIER",
      "class": "type"
    },
    "maxaccess": "not-accessible",
    "status": "mandatory",
    "description": "Description here"
  },
  "meta": {
    "comments": [
      "ASN.1 source file:///Users/neermitt/kusanagi/mibs.snmplabs.com/asn1/SNIA-SML-MIB",
      "Produced by pysmi-0.3.4 at Fri May 24 21:40:59 2019",
      "On host NEERMITT-M-J0NV platform Darwin version 18.6.0 by user neermitt",
      "Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) "
    ],
    "module": "SNIA-SML-MIB"
  }
}
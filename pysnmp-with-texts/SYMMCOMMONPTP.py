#
# PySNMP MIB module SYMMCOMMONPTP (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/neermitt/Dev/kusanagi/mibs.snmplabs.com/asn1/SYMMCOMMONPTP
# Produced by pysmi-0.3.4 at Tue Jul 30 11:34:56 2019
# On host NEERMITT-M-J0NV platform Darwin version 18.6.0 by user neermitt
# Using Python version 3.7.4 (default, Jul  9 2019, 18:13:23) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
entPhysicalIndex, = mibBuilder.importSymbols("ENTITY-MIB", "entPhysicalIndex")
ifNumber, ifIndex = mibBuilder.importSymbols("IF-MIB", "ifNumber", "ifIndex")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, MibIdentifier, TimeTicks, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, IpAddress, Counter32, Counter64, Bits, Integer32, Gauge32, NotificationType, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "MibIdentifier", "TimeTicks", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "IpAddress", "Counter32", "Counter64", "Bits", "Integer32", "Gauge32", "NotificationType", "Unsigned32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
symmPacketService, EnableValue = mibBuilder.importSymbols("SYMM-COMMON-SMI", "symmPacketService", "EnableValue")
symmPTPv2 = ModuleIdentity((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1))
symmPTPv2.setRevisions(('2018-07-31 06:20',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: symmPTPv2.setRevisionsDescriptions(('Symmetricom common PTP v2 packet service MIB',))
if mibBuilder.loadTexts: symmPTPv2.setLastUpdated('201807310620Z')
if mibBuilder.loadTexts: symmPTPv2.setOrganization('Symmetricom')
if mibBuilder.loadTexts: symmPTPv2.setContactInfo('Symmetricom Technical Support 1-888-367-7966 toll free USA 1-408-428-7907 worldwide Support@symmetricom.com')
if mibBuilder.loadTexts: symmPTPv2.setDescription('This is the Symmetricom PTPv2 MIB. It has two main nodes: PTPv2 status and PTPv2 configuration.')
class PTPPROFILEVALUE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("profileTelecom2008", 1), ("profileDefault", 2), ("profileHybrid", 3), ("profileITU8265one", 4), ("profileEthernetDefault", 5), ("profileITU8275one", 6), ("profileITU8275two", 7))

class PTPTIMESCALETYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("auto", 1), ("arb", 2), ("ptp", 3))

class PTPMGMTADDRTYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1))
    namedValues = NamedValues(("unicast", 0), ("multicast", 1))

class PTPTRANSPORTTYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("ethernet", 1), ("ipv4", 2))

class PTPADDRMODETYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("unicast", 0), ("multicast", 1), ("multicasthybrid", 2))

class PORTSTATEVALUE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enable", 1), ("disable", 2))

class G82751McAddrValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("mac011b19000000", 1), ("mac0180c200000e", 2))

class VLANID(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1))
    namedValues = NamedValues(("none", 1))

class DateAndTime(TextualConvention, OctetString):
    description = "A date-time specification. field octets contents range ----- ------ -------- ----- 1 1-2 year* 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minutes 0..59 6 7 seconds 0..60 (use 60 for leap-second) 7 8 deci-seconds 0..9 8 9 direction from UTC '+' / '-' 9 10 hours from UTC* 0..13 10 11 minutes from UTC 0..59 * Notes: - the value of year is in network-byte order - daylight saving time in New Zealand is +13 For example, Tuesday May 26, 1992 at 1:30:15 PM EDT would be displayed as: 1992-5-26,13:30:15.0,-4:0 Note that if only local time is known, then timezone information (fields 8-10) is not present."
    status = 'current'
    displayHint = '2d-1d-1d,1d:1d:1d.1d,1a1d:1d'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(8, 8), ValueSizeConstraint(11, 11), )
class TLatAndLon(TextualConvention, OctetString):
    description = "antenna latitude and longitude specification. field octets contents range ----- ------ -------- ----- 1 1 +/-180 deg '+' / '-' 2 2 degree 0..180 3 3 minute 0..59 4 4 second 0..59 5 5 second fraction 0..99 +/- dd:mm:ss.ss "
    status = 'current'
    displayHint = '1a1d:1d:1d.1d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(5, 5)
    fixedLength = 5

class TAntHeight(TextualConvention, OctetString):
    description = "antenna height specification. field octets contents range ----- ------ -------- ----- 1 1 +/- '+' / '-' 2 2-3 meter 0..10000 3 4 meter fraction 0..99 +/- hh.hh "
    status = 'current'
    displayHint = '1a2d.1d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

class TLocalTimeOffset(TextualConvention, OctetString):
    description = "A local time offset specification. field octets contents range ----- ------ -------- ----- 1 1 direction from UTC '+' / '-' 2 2 hours from UTC* 0..13 3 3 minutes from UTC 0..59 * Notes: - the value of year is in network-byte order - The hours range is 0..13 For example, the -6 local time offset would be displayed as: -6:0 "
    status = 'current'
    displayHint = '1a1d:1d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(3, 3)
    fixedLength = 3

class TSsm(TextualConvention, Integer32):
    description = 'The ssm hex code'
    status = 'current'
    displayHint = 'x'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

ptpv2Status = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1))
ptpv2StatusTable = MibTable((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1, 1), )
if mibBuilder.loadTexts: ptpv2StatusTable.setStatus('current')
if mibBuilder.loadTexts: ptpv2StatusTable.setDescription('The PTP status table. This table provides status for the PTP grandmaster operation.')
ptpv2StatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "SYMMCOMMONPTP", "ptpv2StatusIndex"))
if mibBuilder.loadTexts: ptpv2StatusEntry.setStatus('current')
if mibBuilder.loadTexts: ptpv2StatusEntry.setDescription('An entry of the PTPv2 status table. Table index is ifIndex (port and interface index).')
ptpv2StatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)))
if mibBuilder.loadTexts: ptpv2StatusIndex.setStatus('current')
if mibBuilder.loadTexts: ptpv2StatusIndex.setDescription('This is a local index that is not accessible. Range is 1 - 1000.')
ptpv2StatusPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1, 1, 1, 2), EnableValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpv2StatusPortEnable.setStatus('current')
if mibBuilder.loadTexts: ptpv2StatusPortEnable.setDescription('PTP port state control used to enable or disable PTP service. Values can be Enable (1) or Disable (2). ')
ptpv2StatusClockID = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpv2StatusClockID.setStatus('current')
if mibBuilder.loadTexts: ptpv2StatusClockID.setDescription('Clock ID uniquely identifies a PTP clock at a PTP port. It is a 64-bit identifier. In TP5K system each physical PTP port supports one PTP clock. ')
ptpv2StatusProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1, 1, 1, 4), PTPPROFILEVALUE()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpv2StatusProfile.setStatus('current')
if mibBuilder.loadTexts: ptpv2StatusProfile.setDescription('PTP profile supported by the specified PTP port. TP5K system supports the following profiles: (1)Telecom-2008, (2)Default, (3)Hybrid, (4)ITU G.8265.1, (5)Ethernet-default, (6)ITU G.8275.1. (7) ITU G.8275.2 The user guide has descriptions of different profiles and the values of the PTP attributes for each profile. ')
ptpv2StatusClockClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpv2StatusClockClass.setStatus('current')
if mibBuilder.loadTexts: ptpv2StatusClockClass.setDescription('PTP clock class is a quality level indication for a PTP clock. Table 5 in IEEE 1588 v2 defines clock classes for general use. ITU G.8265.1 provides a mapping between PTP clock class and synchronization clock quality level for the ITU telecom profile. ')
ptpv2StatusClockAccuracy = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpv2StatusClockAccuracy.setStatus('current')
if mibBuilder.loadTexts: ptpv2StatusClockAccuracy.setDescription('PTP clock accuracy is the expected clock accuracy when the PTP clock is used as a grandmaster. It is used as a selection criterion in the best master clock (BMC) algorithm. ')
ptpv2StatusTimescale = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1, 1, 1, 7), PTPTIMESCALETYPE()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpv2StatusTimescale.setStatus('current')
if mibBuilder.loadTexts: ptpv2StatusTimescale.setDescription('PTP timescale used by the PTP clock. It can be ARB (2) or PTP (3). If timescale is PTP, the epoch is 1 January 1970 00:00:00 TAI, which is 31 December 1969 23:59:51.999918 UTC. ')
ptpv2StatusNumClient = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpv2StatusNumClient.setStatus('current')
if mibBuilder.loadTexts: ptpv2StatusNumClient.setDescription('Number of PTP clients connected to a PTP port. It value is 0 - 1000. ')
ptpv2StatusClientLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpv2StatusClientLoad.setStatus('current')
if mibBuilder.loadTexts: ptpv2StatusClientLoad.setDescription('Percentage of PTP client load on a PTP port. This is the percentage of connected client relative to the maximum number of clients that the port can support. ')
ptpv2ClientDataTable = MibTable((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1, 2), )
if mibBuilder.loadTexts: ptpv2ClientDataTable.setStatus('current')
if mibBuilder.loadTexts: ptpv2ClientDataTable.setDescription('PTP client data table contains raw data for PTP clients. ')
ptpv2ClientDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1, 2, 1), ).setIndexNames((0, "SYMMCOMMONPTP", "ptpv2ClientDataIndex"))
if mibBuilder.loadTexts: ptpv2ClientDataEntry.setStatus('current')
if mibBuilder.loadTexts: ptpv2ClientDataEntry.setDescription('An entry to the client data table. Table index is the local index.')
ptpv2ClientDataIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpv2ClientDataIndex.setStatus('current')
if mibBuilder.loadTexts: ptpv2ClientDataIndex.setDescription('Client data index is a local index. This local index is also called client number. ')
ptpv2ClientData = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 1, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpv2ClientData.setStatus('current')
if mibBuilder.loadTexts: ptpv2ClientData.setDescription('Sync interval Client Data is a string of raw data for the entry. It contains the following PTP client information: 1.Module ID (where the client is physically connected) 2.Port ID (where the client is physically connected) 3.Client IP address 4.VLAN ID 5.VLAN priority 6.Client Clock ID 7.Client mode (Clients in TP5K client list are either dynamic or static. Dynamic clients are regular clients that negotiate with GM, and they can come and go from the client list. TP5K also support 10 or 16 static clients that are always on the client list and the GM will always send PTP packets to them whether they respond or not.) 8.Announce interval 9.Sync Interval 10.Delay response interval ')
ptpv2Config = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2))
ptpv2CommonTable = MibTable((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1), )
if mibBuilder.loadTexts: ptpv2CommonTable.setStatus('current')
if mibBuilder.loadTexts: ptpv2CommonTable.setDescription('The PTP common parameter table has PTP parameters that are not specific to the unicast or multicast addressing mode. ')
ptpv2CommonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "SYMMCOMMONPTP", "ptpv2CommonIndex"))
if mibBuilder.loadTexts: ptpv2CommonEntry.setStatus('current')
if mibBuilder.loadTexts: ptpv2CommonEntry.setDescription('An entry of the PTP common parameter table. Table index is ifIndex (port and interface index). ')
ptpv2CommonIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)))
if mibBuilder.loadTexts: ptpv2CommonIndex.setStatus('current')
if mibBuilder.loadTexts: ptpv2CommonIndex.setDescription('This is a local index of the PTP common parameter table. ')
ptpv2Profile = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 2), PTPPROFILEVALUE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2Profile.setStatus('current')
if mibBuilder.loadTexts: ptpv2Profile.setDescription("Select a PTP profile for the specified PTP port. TP5K system supports five IPv4 'profiles': (1) Telecom2008, (2) Default, (3) Hybrid, (4) ITU8265one, (5) Ethernet-default (6) ITU8275one,(7) ITU G.8275.2 The user guide has descriptions, different profiles, and the values of the PTP attributes for each profile. ")
ptpv2ClockID = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2ClockID.setStatus('current')
if mibBuilder.loadTexts: ptpv2ClockID.setDescription('Clock ID uniquely identifies a PTP clock at a PTP port. It is a 64-bit identifier, and its format is xx:xx:xx:xx:xx:xx:xx:xx. In TP5K system, each physical PTP port supports one PTP clock. ')
ptpv2Priority1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2Priority1.setStatus('current')
if mibBuilder.loadTexts: ptpv2Priority1.setDescription('Attribute Priority1 for the specified PTP port. It is used in BMC algorithm as a selection criterion. Its range is 0-255, unless restricted by a PTP profile. Default value is 128. ')
ptpv2Priority2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2Priority2.setStatus('current')
if mibBuilder.loadTexts: ptpv2Priority2.setDescription('Attribute Priority2 for the specified PTP port. It is used in BMC algorithm as a selection criterion. Its range is 0-255, unless restricted by a PTP profile. Default value is 128. ')
ptpv2Domain = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2Domain.setStatus('current')
if mibBuilder.loadTexts: ptpv2Domain.setDescription('The PTP domain of the specified PTP port. PTP domain is a logical grouping of PTP clocks. All the PTP clocks in the same domain are synchronized to each other using the PTP protocol. The range of the PTP domain is 0-255. Default value is 0. For ITU telecom profile, range is 4-23 and default is 4. ')
ptpv2DSCPState = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 7), EnableValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2DSCPState.setStatus('current')
if mibBuilder.loadTexts: ptpv2DSCPState.setDescription('Differentiated service code point (DSCP) state for the specified PTP port. It can be either Enable (1) or Disable (2). Default value is disable. If DSCP state is Enable, the QoS field will have a configured DSCP value. ')
ptpv2DSCPValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2DSCPValue.setStatus('current')
if mibBuilder.loadTexts: ptpv2DSCPValue.setDescription('DSCP value for PTP packets leaving this port. Value range is 0-63, and default value is 0. ')
ptpv2State = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 9), EnableValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2State.setStatus('current')
if mibBuilder.loadTexts: ptpv2State.setDescription('PTP packet service state for the specified PTP port. It can be either Enable (1) or Disable (2). Default value is Enable. When PTP is disabled at a port, it does not transmit or respond to PTP packets, and all alarms associated with PTP for this port are cleared. ')
ptpv2MaxClient = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1500)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2MaxClient.setStatus('current')
if mibBuilder.loadTexts: ptpv2MaxClient.setDescription('The maximum number of PTP clients that are allowed to be connected to this PTP port. Max number of clients (1000 is available in Extended mode only and 1000/1500 is available on ptp client license, otherwise 500). ')
ptpv2AnnounceLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-4, 4)).clone(-3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2AnnounceLimit.setStatus('current')
if mibBuilder.loadTexts: ptpv2AnnounceLimit.setDescription('The minimum PTP Announce message transmission interval (inverse of the maximum PTP Announce message transmission rate) that the port will accept. This is the exponent of 2, and the value range is -4 to +4. Default is -3. For telecom profile, the range is -3 to +4 and default is 1. If AnnounceLimit = -4, the minimum Announce message transmission interval is = 2^(-4) = 0.0625 seconds, or the maximum message transmission rate is 16 messages per second. ')
ptpv2SyncLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-7, 7)).clone(-7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2SyncLimit.setStatus('current')
if mibBuilder.loadTexts: ptpv2SyncLimit.setDescription('The minimum PTP Sync message interval (inverse of the maximum PTP Sync message transmission rate) that the port will accept. This is the exponent of 2, and the value range is -7 to +7 and default is -7. For telecom profile the range is -7 to +4. If SyncLimit = -4, the minimum Sync message transmission interval is = 2^(-4) = 0.0625 seconds, or the maximum message transmission rate is 16 messages per second. ')
ptpv2DelayLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-7, 7)).clone(-7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2DelayLimit.setStatus('current')
if mibBuilder.loadTexts: ptpv2DelayLimit.setDescription('The minimum PTP Delay_Req message transmission interval that the port will accept (inverse of the maximum PTP Delay_Req message transmission rate). This is the exponent of 2, and the value range is -7 to +7 and default is -7. For telecom profile the range is -7 to +4. If SyncLimit = -4, the minimum Delay_Req message transmission interval is = 2^(-4) = 0.0625 seconds, or the maximum message transmission rate is 16 messages per second. ')
ptpv2TwoStep = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 14), EnableValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2TwoStep.setStatus('current')
if mibBuilder.loadTexts: ptpv2TwoStep.setDescription('PTP two-step clock enable. Its value can be Enable (1) or Disable (2). Default value is Disable. If it is disabled, the system will use PTP one-step clock. ')
ptpv2MgmtAddrMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 15), PTPMGMTADDRTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2MgmtAddrMode.setStatus('current')
if mibBuilder.loadTexts: ptpv2MgmtAddrMode.setDescription('The addressing mode for the PTP management communication between a PTP grandmaster port and PTP clients. It can be either unicast (1) or multicast (2). Default is unicast. ')
ptpv2TTL = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2TTL.setStatus('current')
if mibBuilder.loadTexts: ptpv2TTL.setDescription('IP header time-to-live (TTL) field for the PTP packets. Range is 1-255. Default value is 64. ')
ptpv2AlternateGM = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 17), EnableValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2AlternateGM.setStatus('current')
if mibBuilder.loadTexts: ptpv2AlternateGM.setDescription('PTP alternate master enable state for the specified PTP port. It can be Enable (1) or Disable (2). Default is Disable. When it is disabled, the port is always a master and does not use BMC. ')
ptpv2TimeScale = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 18), PTPTIMESCALETYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2TimeScale.setStatus('current')
if mibBuilder.loadTexts: ptpv2TimeScale.setDescription('PTP timescale to be used by the PTP clock. It can be Auto (1), ARB (2), or PTP (3). Auto means selecting PTP or ARB depending on the reference mode. If timescale is PTP, the epoch is 1 January 1970 00:00:00 TAI, which is 31 December 1969 23:59:51.999918 UTC. ')
ptpv2Dither = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 19), EnableValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2Dither.setStatus('current')
if mibBuilder.loadTexts: ptpv2Dither.setDescription('PTP dither state. It can either be Enable (1) or Disable (2). Default is Disable. Dithering is used to randomize packet transmission time to improve performance. ')
ptpv2ServiceLoadAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2ServiceLoadAlarmThreshold.setStatus('current')
if mibBuilder.loadTexts: ptpv2ServiceLoadAlarmThreshold.setDescription('It shows percentage (%) of PTP service load alarm threshold')
ptpv2UnicastTable = MibTable((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 2), )
if mibBuilder.loadTexts: ptpv2UnicastTable.setStatus('current')
if mibBuilder.loadTexts: ptpv2UnicastTable.setDescription('The PTP unicast configuration table for PTP attributes that are specific to unicast. In TP5K 2.0, only the main shelf supports unicast. ')
ptpv2UnicastEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "SYMMCOMMONPTP", "ptpv2UnicastIndex"))
if mibBuilder.loadTexts: ptpv2UnicastEntry.setStatus('current')
if mibBuilder.loadTexts: ptpv2UnicastEntry.setDescription('An entry to the PTP unicast configuration table. Table index is ifIndex. The unicast table has two attributes: unicast negotiation state and unicast lease duration limit. ')
ptpv2UnicastIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)))
if mibBuilder.loadTexts: ptpv2UnicastIndex.setStatus('current')
if mibBuilder.loadTexts: ptpv2UnicastIndex.setDescription('Local index of the PTP unicast configuration table.')
ptpv2UnicastNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 2, 1, 2), EnableValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2UnicastNeg.setStatus('current')
if mibBuilder.loadTexts: ptpv2UnicastNeg.setDescription('Unicast negotiation state for the specified port. Its value can be Enable (1) or Disable (2). ')
ptpv2UnicastLeaseDurLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2UnicastLeaseDurLimit.setStatus('current')
if mibBuilder.loadTexts: ptpv2UnicastLeaseDurLimit.setDescription('Unicast least duration limit (in seconds) is the maximum unicast lease duration request that the grandmaster will accept. Its range is 10 to 1000 seconds. Default value is 300 seconds. ')
ptpv2UnicastInterfaceRateTLV = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 2, 1, 4), EnableValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2UnicastInterfaceRateTLV.setStatus('current')
if mibBuilder.loadTexts: ptpv2UnicastInterfaceRateTLV.setDescription('Setup PTP interface rate TLV state.')
ptpv2UnicastLeaseExtension = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2UnicastLeaseExtension.setStatus('current')
if mibBuilder.loadTexts: ptpv2UnicastLeaseExtension.setDescription('Setup PTP Lease Extension. Default value 0. Range 0-1000')
ptpv2MulticastTable = MibTable((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 3), )
if mibBuilder.loadTexts: ptpv2MulticastTable.setStatus('current')
if mibBuilder.loadTexts: ptpv2MulticastTable.setDescription('The PTP multicast table for PTP attributes that are specific to multicast. In TP5K 2.0, main shelf and expansion shelves all support multicast. ')
ptpv2MulticastEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "SYMMCOMMONPTP", "ptpv2MulticastIndex"))
if mibBuilder.loadTexts: ptpv2MulticastEntry.setStatus('current')
if mibBuilder.loadTexts: ptpv2MulticastEntry.setDescription('An entry to the PTP multicast configuration table. Table index is ifIndex. The multicast table has 6 multicast attributes. ')
ptpv2MulticastIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)))
if mibBuilder.loadTexts: ptpv2MulticastIndex.setStatus('current')
if mibBuilder.loadTexts: ptpv2MulticastIndex.setDescription('Local index of the PTP multicast configuration table.')
ptpv2MulticastAnnounceInt = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-4, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2MulticastAnnounceInt.setStatus('current')
if mibBuilder.loadTexts: ptpv2MulticastAnnounceInt.setDescription('PTP multicast Announce message transmission interval (inverse of the maximum PTP multicast Announce message transmission rate). This is the exponent of 2, and the value range is -4 to +4. Default value is 1 (which means 2 seconds). If the value of the multicast Announce transmission interval is -4, the message transmission interval is = 2^(-4) = 0.0625 seconds, or the message transmission rate is 16 messages per second. ')
ptpv2MulticastSyncInt = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-7, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2MulticastSyncInt.setStatus('current')
if mibBuilder.loadTexts: ptpv2MulticastSyncInt.setDescription('PTP multicast Sync message transmission interval (inverse of the maximum PTP multicast Sync message transmission rate). This is the exponent of 2, and the value range is -7 to +7. Default value is 0 (i.e. 1 second). If the value of the multicast Sync transmission interval is -4, the message transmission interval is = 2^(-4) = 0.0625 seconds, or the message transmission rate is 16 messages per second. ')
ptpv2MulticastDelayInt = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-7, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2MulticastDelayInt.setStatus('current')
if mibBuilder.loadTexts: ptpv2MulticastDelayInt.setDescription('PTP multicast Delay_Req message transmission interval (inverse of the maximum PTP multicast Delay_Req message transmission rate). This is the exponent of 2, and the value range is -7 to +7.Default value is -7. If the value of the multicast Delay_Req transmission interval is -4, the message transmission interval is = 2^(-4) = 0.0625 seconds, or the message transmission rate is 16 messages per second. ')
ptpv2MulticastAnnoTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2MulticastAnnoTimeout.setStatus('current')
if mibBuilder.loadTexts: ptpv2MulticastAnnoTimeout.setDescription('Multicast Announce Receipt Timeout. Its range is 2 to 10 and its unit is number of intervals. Default value is 3 (intervals). It is the number of Announce intervals that has to pass without receiving an Announce message before the PTP port declares Announce_Receipt_Timeout_Expires. If the timeout value is 2 and the multicast announce interval is 4 seconds, then the multicast announce receipt timeout value is 2*4 = 8 seconds. ')
ptpv2MulticastVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2MulticastVlanId.setStatus('current')
if mibBuilder.loadTexts: ptpv2MulticastVlanId.setDescription('Multicast VLAN ID of the specified PTP port. Each multicast PTP port only supports one VLAN. Range is 0 to 4094. Default value is 0. ')
ptpv2MulticastClientTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 3600)).clone(360)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2MulticastClientTimeout.setStatus('current')
if mibBuilder.loadTexts: ptpv2MulticastClientTimeout.setDescription('Multicast client timeout. Range is 10 to 3600 seconds. Default value is 300 seconds. TP5000 maintains a list of active PTP clients. If the grandmaster does not receive Delay_Req message from a client for more than this timeout value, the client is removed from the TP5000 client list. ')
ptpv2G82751Table = MibTable((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 4), )
if mibBuilder.loadTexts: ptpv2G82751Table.setStatus('current')
if mibBuilder.loadTexts: ptpv2G82751Table.setDescription('The PTP itu-g8276-1 configuration table for PTP attributes that are specific to itu-g8276-1. In TP5K 2.2, only the main shelf supports itu-g8276-1. ')
ptpv2G82751Entry = MibTableRow((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "SYMMCOMMONPTP", "ptpv2G82751Index"))
if mibBuilder.loadTexts: ptpv2G82751Entry.setStatus('current')
if mibBuilder.loadTexts: ptpv2G82751Entry.setDescription('An entry to the PTP G82751 configuration table. Table index is ifIndex. The G82751 table has two attributes: multicast address and G82751 local priority. ')
ptpv2G82751Index = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)))
if mibBuilder.loadTexts: ptpv2G82751Index.setStatus('current')
if mibBuilder.loadTexts: ptpv2G82751Index.setDescription('Local index of the PTP G82751 configuration table.')
ptpv2G82751MulticastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 4, 1, 2), G82751McAddrValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2G82751MulticastAddr.setStatus('current')
if mibBuilder.loadTexts: ptpv2G82751MulticastAddr.setDescription('G82751 multicast address for the specified port. The valid setting should be mac011b19000000 (1) or mac0180c200000e (2) ')
ptpv2G82751LocalPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2G82751LocalPriority.setStatus('current')
if mibBuilder.loadTexts: ptpv2G82751LocalPriority.setDescription('PTP G82751 local priority, the valid range is 1 to 255.')
ptpv2ReflectorTable = MibTable((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 5), )
if mibBuilder.loadTexts: ptpv2ReflectorTable.setStatus('current')
if mibBuilder.loadTexts: ptpv2ReflectorTable.setDescription('PTP Unicast Reflector Table')
ptpv2ReflectorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "SYMMCOMMONPTP", "ptpv2ReflectorIndex"))
if mibBuilder.loadTexts: ptpv2ReflectorEntry.setStatus('current')
if mibBuilder.loadTexts: ptpv2ReflectorEntry.setDescription('An entry to the PTP Reflector configuration table. Table index is ifIndex. ')
ptpv2ReflectorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)))
if mibBuilder.loadTexts: ptpv2ReflectorIndex.setStatus('current')
if mibBuilder.loadTexts: ptpv2ReflectorIndex.setDescription('Local index of the PTP Reflector configuration table.')
ptpv2ReflectorAnnounceIntv = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-3, 0))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2ReflectorAnnounceIntv.setStatus('current')
if mibBuilder.loadTexts: ptpv2ReflectorAnnounceIntv.setDescription('PTP unicast reflector announce interval. Valid range -3 to 0')
ptpv2ReflectorSyncDelayIntv = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-7, -4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2ReflectorSyncDelayIntv.setStatus('current')
if mibBuilder.loadTexts: ptpv2ReflectorSyncDelayIntv.setDescription('PTP unicast reflector sync-delay interval. Valid range -7 to -4')
ptpv2ReflectorClientTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2ReflectorClientTimeout.setStatus('current')
if mibBuilder.loadTexts: ptpv2ReflectorClientTimeout.setDescription('PTP unicast reflector Client timeout. Valid range 60 to 1000')
ptpv2ReflectorVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpv2ReflectorVlanID.setStatus('current')
if mibBuilder.loadTexts: ptpv2ReflectorVlanID.setDescription('PTP unicast reflector Vlan-ID. Valid range 2 to 4096. Enter 0 for NONE, 1 denotes Invalid')
ptpv2Conformance = ObjectIdentity((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 3))
if mibBuilder.loadTexts: ptpv2Conformance.setStatus('current')
if mibBuilder.loadTexts: ptpv2Conformance.setDescription('This subtree contains conformance statements for the SYMMCOMMONPTP MIB module. ')
ptpv2Compliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 3, 1))
ptpv2BasicCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 3, 1, 1)).setObjects(("SYMMCOMMONPTP", "ptpv2StatusGroup"), ("SYMMCOMMONPTP", "ptpv2ClientDataGroup"), ("SYMMCOMMONPTP", "ptpv2CommonGroup"), ("SYMMCOMMONPTP", "ptpv2UnicastGroup"), ("SYMMCOMMONPTP", "ptpv2MulticastGroup"), ("SYMMCOMMONPTP", "ptpv2G82751Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpv2BasicCompliance = ptpv2BasicCompliance.setStatus('current')
if mibBuilder.loadTexts: ptpv2BasicCompliance.setDescription('The compliance statement for SNMP entities which have PTP packet service.')
ptpv2UocGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 3, 2))
ptpv2StatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 3, 2, 1)).setObjects(("SYMMCOMMONPTP", "ptpv2StatusPortEnable"), ("SYMMCOMMONPTP", "ptpv2StatusClockID"), ("SYMMCOMMONPTP", "ptpv2StatusProfile"), ("SYMMCOMMONPTP", "ptpv2StatusClockClass"), ("SYMMCOMMONPTP", "ptpv2StatusClockAccuracy"), ("SYMMCOMMONPTP", "ptpv2StatusTimescale"), ("SYMMCOMMONPTP", "ptpv2StatusNumClient"), ("SYMMCOMMONPTP", "ptpv2StatusClientLoad"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpv2StatusGroup = ptpv2StatusGroup.setStatus('current')
if mibBuilder.loadTexts: ptpv2StatusGroup.setDescription('A collection of objects providing information applicable to PTP status group.')
ptpv2ClientDataGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 3, 2, 2)).setObjects(("SYMMCOMMONPTP", "ptpv2ClientDataIndex"), ("SYMMCOMMONPTP", "ptpv2ClientData"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpv2ClientDataGroup = ptpv2ClientDataGroup.setStatus('current')
if mibBuilder.loadTexts: ptpv2ClientDataGroup.setDescription('A collection of objects providing information applicable to PTP client group.')
ptpv2CommonGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 3, 2, 3)).setObjects(("SYMMCOMMONPTP", "ptpv2Profile"), ("SYMMCOMMONPTP", "ptpv2ClockID"), ("SYMMCOMMONPTP", "ptpv2Priority1"), ("SYMMCOMMONPTP", "ptpv2Priority2"), ("SYMMCOMMONPTP", "ptpv2Domain"), ("SYMMCOMMONPTP", "ptpv2DSCPState"), ("SYMMCOMMONPTP", "ptpv2DSCPValue"), ("SYMMCOMMONPTP", "ptpv2State"), ("SYMMCOMMONPTP", "ptpv2MaxClient"), ("SYMMCOMMONPTP", "ptpv2AnnounceLimit"), ("SYMMCOMMONPTP", "ptpv2SyncLimit"), ("SYMMCOMMONPTP", "ptpv2DelayLimit"), ("SYMMCOMMONPTP", "ptpv2TwoStep"), ("SYMMCOMMONPTP", "ptpv2MgmtAddrMode"), ("SYMMCOMMONPTP", "ptpv2TTL"), ("SYMMCOMMONPTP", "ptpv2AlternateGM"), ("SYMMCOMMONPTP", "ptpv2TimeScale"), ("SYMMCOMMONPTP", "ptpv2Dither"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpv2CommonGroup = ptpv2CommonGroup.setStatus('current')
if mibBuilder.loadTexts: ptpv2CommonGroup.setDescription('A collection of objects providing information applicable to PTP common group.')
ptpv2UnicastGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 3, 2, 4)).setObjects(("SYMMCOMMONPTP", "ptpv2UnicastNeg"), ("SYMMCOMMONPTP", "ptpv2UnicastLeaseDurLimit"), ("SYMMCOMMONPTP", "ptpv2UnicastInterfaceRateTLV"), ("SYMMCOMMONPTP", "ptpv2UnicastLeaseExtension"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpv2UnicastGroup = ptpv2UnicastGroup.setStatus('current')
if mibBuilder.loadTexts: ptpv2UnicastGroup.setDescription('A collection of objects providing information applicable to PTP unicast group.')
ptpv2MulticastGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 3, 2, 5)).setObjects(("SYMMCOMMONPTP", "ptpv2MulticastAnnounceInt"), ("SYMMCOMMONPTP", "ptpv2MulticastSyncInt"), ("SYMMCOMMONPTP", "ptpv2MulticastDelayInt"), ("SYMMCOMMONPTP", "ptpv2MulticastAnnoTimeout"), ("SYMMCOMMONPTP", "ptpv2MulticastVlanId"), ("SYMMCOMMONPTP", "ptpv2MulticastClientTimeout"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpv2MulticastGroup = ptpv2MulticastGroup.setStatus('current')
if mibBuilder.loadTexts: ptpv2MulticastGroup.setDescription('A collection of objects providing information applicable to PTP multicast group.')
ptpv2G82751Group = ObjectGroup((1, 3, 6, 1, 4, 1, 9070, 1, 2, 5, 1, 1, 3, 2, 6)).setObjects(("SYMMCOMMONPTP", "ptpv2G82751MulticastAddr"), ("SYMMCOMMONPTP", "ptpv2G82751LocalPriority"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpv2G82751Group = ptpv2G82751Group.setStatus('current')
if mibBuilder.loadTexts: ptpv2G82751Group.setDescription('A collection of objects providing information applicable to PTP G82751 group.')
mibBuilder.exportSymbols("SYMMCOMMONPTP", ptpv2G82751Group=ptpv2G82751Group, ptpv2ReflectorSyncDelayIntv=ptpv2ReflectorSyncDelayIntv, G82751McAddrValue=G82751McAddrValue, ptpv2Config=ptpv2Config, DateAndTime=DateAndTime, ptpv2StatusClockID=ptpv2StatusClockID, PTPTIMESCALETYPE=PTPTIMESCALETYPE, ptpv2MulticastDelayInt=ptpv2MulticastDelayInt, ptpv2G82751Index=ptpv2G82751Index, ptpv2MgmtAddrMode=ptpv2MgmtAddrMode, ptpv2ClockID=ptpv2ClockID, ptpv2UnicastNeg=ptpv2UnicastNeg, PTPADDRMODETYPE=PTPADDRMODETYPE, ptpv2StatusIndex=ptpv2StatusIndex, ptpv2StatusProfile=ptpv2StatusProfile, TLocalTimeOffset=TLocalTimeOffset, PTPTRANSPORTTYPE=PTPTRANSPORTTYPE, TSsm=TSsm, ptpv2TimeScale=ptpv2TimeScale, ptpv2UnicastEntry=ptpv2UnicastEntry, ptpv2StatusNumClient=ptpv2StatusNumClient, ptpv2StatusEntry=ptpv2StatusEntry, ptpv2UocGroups=ptpv2UocGroups, ptpv2MulticastEntry=ptpv2MulticastEntry, VLANID=VLANID, ptpv2StatusClockAccuracy=ptpv2StatusClockAccuracy, ptpv2StatusGroup=ptpv2StatusGroup, ptpv2ClientData=ptpv2ClientData, ptpv2StatusTimescale=ptpv2StatusTimescale, ptpv2MulticastIndex=ptpv2MulticastIndex, ptpv2ClientDataEntry=ptpv2ClientDataEntry, ptpv2Conformance=ptpv2Conformance, ptpv2StatusPortEnable=ptpv2StatusPortEnable, ptpv2UnicastIndex=ptpv2UnicastIndex, ptpv2G82751Table=ptpv2G82751Table, ptpv2CommonIndex=ptpv2CommonIndex, ptpv2UnicastLeaseDurLimit=ptpv2UnicastLeaseDurLimit, ptpv2ClientDataTable=ptpv2ClientDataTable, ptpv2StatusTable=ptpv2StatusTable, ptpv2Dither=ptpv2Dither, ptpv2Priority1=ptpv2Priority1, ptpv2UnicastGroup=ptpv2UnicastGroup, ptpv2DelayLimit=ptpv2DelayLimit, ptpv2DSCPState=ptpv2DSCPState, ptpv2MulticastGroup=ptpv2MulticastGroup, PORTSTATEVALUE=PORTSTATEVALUE, ptpv2ReflectorVlanID=ptpv2ReflectorVlanID, symmPTPv2=symmPTPv2, ptpv2Priority2=ptpv2Priority2, ptpv2ReflectorEntry=ptpv2ReflectorEntry, ptpv2SyncLimit=ptpv2SyncLimit, ptpv2MulticastVlanId=ptpv2MulticastVlanId, ptpv2MulticastAnnoTimeout=ptpv2MulticastAnnoTimeout, ptpv2MulticastSyncInt=ptpv2MulticastSyncInt, ptpv2Profile=ptpv2Profile, ptpv2StatusClientLoad=ptpv2StatusClientLoad, PYSNMP_MODULE_ID=symmPTPv2, ptpv2AlternateGM=ptpv2AlternateGM, ptpv2StatusClockClass=ptpv2StatusClockClass, ptpv2G82751Entry=ptpv2G82751Entry, ptpv2Compliances=ptpv2Compliances, ptpv2ReflectorAnnounceIntv=ptpv2ReflectorAnnounceIntv, ptpv2DSCPValue=ptpv2DSCPValue, ptpv2ReflectorIndex=ptpv2ReflectorIndex, ptpv2MulticastClientTimeout=ptpv2MulticastClientTimeout, ptpv2State=ptpv2State, ptpv2MulticastAnnounceInt=ptpv2MulticastAnnounceInt, ptpv2ClientDataIndex=ptpv2ClientDataIndex, PTPMGMTADDRTYPE=PTPMGMTADDRTYPE, ptpv2CommonGroup=ptpv2CommonGroup, ptpv2UnicastInterfaceRateTLV=ptpv2UnicastInterfaceRateTLV, ptpv2TwoStep=ptpv2TwoStep, ptpv2G82751MulticastAddr=ptpv2G82751MulticastAddr, ptpv2ReflectorTable=ptpv2ReflectorTable, ptpv2ClientDataGroup=ptpv2ClientDataGroup, ptpv2G82751LocalPriority=ptpv2G82751LocalPriority, ptpv2CommonEntry=ptpv2CommonEntry, ptpv2BasicCompliance=ptpv2BasicCompliance, ptpv2ReflectorClientTimeout=ptpv2ReflectorClientTimeout, ptpv2MaxClient=ptpv2MaxClient, ptpv2ServiceLoadAlarmThreshold=ptpv2ServiceLoadAlarmThreshold, ptpv2TTL=ptpv2TTL, ptpv2UnicastTable=ptpv2UnicastTable, TAntHeight=TAntHeight, TLatAndLon=TLatAndLon, ptpv2Status=ptpv2Status, ptpv2UnicastLeaseExtension=ptpv2UnicastLeaseExtension, PTPPROFILEVALUE=PTPPROFILEVALUE, ptpv2CommonTable=ptpv2CommonTable, ptpv2MulticastTable=ptpv2MulticastTable, ptpv2Domain=ptpv2Domain, ptpv2AnnounceLimit=ptpv2AnnounceLimit)

#
# PySNMP MIB module RADLAN-RMON (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RADLAN-RMON
# Produced by pysmi-0.3.4 at Wed May  1 14:48:48 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
rnd, = mibBuilder.importSymbols("RADLAN-MIB", "rnd")
OwnerString, EntryStatus = mibBuilder.importSymbols("RMON-MIB", "OwnerString", "EntryStatus")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Unsigned32, ModuleIdentity, Counter64, Counter32, TimeTicks, Gauge32, IpAddress, MibIdentifier, iso, ObjectIdentity, NotificationType, Integer32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "ModuleIdentity", "Counter64", "Counter32", "TimeTicks", "Gauge32", "IpAddress", "MibIdentifier", "iso", "ObjectIdentity", "NotificationType", "Integer32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TruthValue, DisplayString, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "TextualConvention", "RowStatus")
DisplayString, = mibBuilder.importSymbols("SNMPv2-TC-v1", "DisplayString")
rlRmonControl = ModuleIdentity((1, 3, 6, 1, 4, 1, 89, 49))
rlRmonControl.setRevisions(('2004-06-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rlRmonControl.setRevisionsDescriptions(('Initial version of this MIB.',))
if mibBuilder.loadTexts: rlRmonControl.setLastUpdated('200406010000Z')
if mibBuilder.loadTexts: rlRmonControl.setOrganization('Radlan Computer Communications Ltd.')
if mibBuilder.loadTexts: rlRmonControl.setContactInfo('radlan.com')
if mibBuilder.loadTexts: rlRmonControl.setDescription('The private MIB module definition for RND RMON MIB.')
rlRmonControlMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 49, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlRmonControlMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlRmonControlMibVersion.setDescription("The MIB's version. The current version is 1")
rlRmonControlHistoryControlQuotaBucket = MibScalar((1, 3, 6, 1, 4, 1, 89, 49, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlRmonControlHistoryControlQuotaBucket.setStatus('current')
if mibBuilder.loadTexts: rlRmonControlHistoryControlQuotaBucket.setDescription('Maximum number of buckets to be used by each History Control group entry. changed to read only, value is derived from rsMaxRmonEtherHistoryEntrie')
rlRmonControlHistoryControlMaxGlobalBuckets = MibScalar((1, 3, 6, 1, 4, 1, 89, 49, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(300)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlRmonControlHistoryControlMaxGlobalBuckets.setStatus('current')
if mibBuilder.loadTexts: rlRmonControlHistoryControlMaxGlobalBuckets.setDescription('Maximum number of buckets to be used by all History Control group entries together.')
rlHistoryControlTable = MibTable((1, 3, 6, 1, 4, 1, 89, 49, 4), )
if mibBuilder.loadTexts: rlHistoryControlTable.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlTable.setDescription('A list of rlHistory control entries. This table is exactly like the corresponding RMON I History control group table, but is used to sample statistics of counters not specified by the RMON I statistics group.')
rlHistoryControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 49, 4, 1), ).setIndexNames((0, "RADLAN-RMON", "rlHistoryControlIndex"))
if mibBuilder.loadTexts: rlHistoryControlEntry.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlEntry.setDescription('A list of parameters that set up a periodic sampling of statistics. As an example, an instance of the rlHistoryControlInterval object might be named rlHistoryControlInterval.2')
rlHistoryControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlHistoryControlIndex.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlIndex.setDescription('An index that uniquely identifies an entry in the rlHistoryControl table. Each such entry defines a set of samples at a particular interval for a sampled counter.')
rlHistoryControlDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 4, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlHistoryControlDataSource.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlDataSource.setDescription('This object identifies the source of the data for which historical data was collected and placed in the rlHistory table. This object may not be modified if the associated rlHistoryControlStatus object is equal to valid(1).')
rlHistoryControlBucketsRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlHistoryControlBucketsRequested.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlBucketsRequested.setDescription('The requested number of discrete time intervals over which data is to be saved in the part of the rlHistory table associated with this rlHistoryControlEntry. When this object is created or modified, the probe should set rlHistoryControlBucketsGranted as closely to this object as is possible for the particular probe implementation and available resources.')
rlHistoryControlBucketsGranted = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlHistoryControlBucketsGranted.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlBucketsGranted.setDescription('The number of discrete sampling intervals over which data shall be saved in the part of the rlHistory table associated with this rlHistoryControlEntry. When the associated rlHistoryControlBucketsRequested object is created or modified, the probe should set this object as closely to the requested value as is possible for the particular probe implementation and available resources. The probe must not lower this value except as a result of a modification to the associated rlHistoryControlBucketsRequested object. There will be times when the actual number of buckets associated with this entry is less than the value of this object. In this case, at the end of each sampling interval, a new bucket will be added to the rlHistory table. When the number of buckets reaches the value of this object and a new bucket is to be added to the media-specific table, the oldest bucket associated with this rlHistoryControlEntry shall be deleted by the agent so that the new bucket can be added. When the value of this object changes to a value less than the current value, entries are deleted from the rlHistory table. Enough of the oldest of these entries shall be deleted by the agent so that their number remains less than or equal to the new value of this object. When the value of this object changes to a value greater than the current value, the number of associated rlHistory table entries may be allowed to grow.')
rlHistoryControlInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(1800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlHistoryControlInterval.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlInterval.setDescription('The interval in seconds over which the data is sampled for each bucket in the part of the rlHistory table associated with this rlHistoryControlEntry. This interval can be set to any number of seconds between 1 and 3600 (1 hour). Because the counters in a bucket may overflow at their maximum value with no indication, a prudent manager will take into account the possibility of overflow in any of the associated counters. It is important to consider the minimum time in which any counter could overflow and set the rlHistoryControlInterval object to a value This object may not be modified if the associated rlHistoryControlStatus object is equal to valid(1).')
rlHistoryControlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 4, 1, 6), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlHistoryControlOwner.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
rlHistoryControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 4, 1, 7), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlHistoryControlStatus.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlStatus.setDescription('The status of this rlHistoryControl entry. Each instance of the rlHistory table associated with this rlHistoryControlEntry will be deleted by the agent if this rlHistoryControlEntry is not equal to valid(1).')
rlHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 89, 49, 5), )
if mibBuilder.loadTexts: rlHistoryTable.setStatus('current')
if mibBuilder.loadTexts: rlHistoryTable.setDescription('A list of history entries.')
rlHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 49, 5, 1), ).setIndexNames((0, "RADLAN-RMON", "rlHistoryIndex"), (0, "RADLAN-RMON", "rlHistorySampleIndex"))
if mibBuilder.loadTexts: rlHistoryEntry.setStatus('current')
if mibBuilder.loadTexts: rlHistoryEntry.setDescription('An historical statistics sample of a counter specified by the corresponding history control entry. This sample is associated with the rlHistoryControlEntry which set up the parameters for a regular collection of these samples. As an example, an instance of the rlHistoryPkts object might be named rlHistoryPkts.2.89')
rlHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlHistoryIndex.setStatus('current')
if mibBuilder.loadTexts: rlHistoryIndex.setDescription('The history of which this entry is a part. The history identified by a particular value of this index is the same history as identified by the same value of rlHistoryControlIndex.')
rlHistorySampleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlHistorySampleIndex.setStatus('current')
if mibBuilder.loadTexts: rlHistorySampleIndex.setDescription('An index that uniquely identifies the particular sample this entry represents among all samples associated with the same rlHistoryControlEntry. This index starts at 1 and increases by one as each new sample is taken.')
rlHistoryIntervalStart = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 5, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlHistoryIntervalStart.setStatus('current')
if mibBuilder.loadTexts: rlHistoryIntervalStart.setDescription('The value of sysUpTime at the start of the interval over which this sample was measured. If the probe keeps track of the time of day, it should start the first sample of the history at a time such that when the next hour of the day begins, a sample is started at that instant. Note that following this rule may require the probe to delay collecting the first sample of the history, as each sample must be of the same interval. Also note that the sample which is currently being collected is not accessible in this table until the end of its interval.')
rlHistoryValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlHistoryValue.setStatus('current')
if mibBuilder.loadTexts: rlHistoryValue.setDescription('The value of the sampled counter at the time of this sampling.')
rlControlHistoryControlQuotaBucket = MibScalar((1, 3, 6, 1, 4, 1, 89, 49, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlControlHistoryControlQuotaBucket.setStatus('current')
if mibBuilder.loadTexts: rlControlHistoryControlQuotaBucket.setDescription('Maximum number of buckets to be used by each rlHistoryControlTable entry.')
rlControlHistoryControlMaxGlobalBuckets = MibScalar((1, 3, 6, 1, 4, 1, 89, 49, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlControlHistoryControlMaxGlobalBuckets.setStatus('current')
if mibBuilder.loadTexts: rlControlHistoryControlMaxGlobalBuckets.setDescription('Maximum number of buckets to be used by all rlHistoryControlTable entries together.')
rlControlHistoryMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 49, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlControlHistoryMaxEntries.setStatus('current')
if mibBuilder.loadTexts: rlControlHistoryMaxEntries.setDescription('Maximum number of rlHistoryTable entries.')
mibBuilder.exportSymbols("RADLAN-RMON", rlHistoryControlBucketsRequested=rlHistoryControlBucketsRequested, rlHistoryControlIndex=rlHistoryControlIndex, rlHistoryIndex=rlHistoryIndex, PYSNMP_MODULE_ID=rlRmonControl, rlHistoryControlStatus=rlHistoryControlStatus, rlHistorySampleIndex=rlHistorySampleIndex, rlHistoryControlEntry=rlHistoryControlEntry, rlRmonControl=rlRmonControl, rlHistoryControlDataSource=rlHistoryControlDataSource, rlHistoryValue=rlHistoryValue, rlControlHistoryControlMaxGlobalBuckets=rlControlHistoryControlMaxGlobalBuckets, rlHistoryEntry=rlHistoryEntry, rlRmonControlHistoryControlQuotaBucket=rlRmonControlHistoryControlQuotaBucket, rlHistoryIntervalStart=rlHistoryIntervalStart, rlControlHistoryMaxEntries=rlControlHistoryMaxEntries, rlHistoryControlTable=rlHistoryControlTable, rlRmonControlMibVersion=rlRmonControlMibVersion, rlHistoryTable=rlHistoryTable, rlHistoryControlBucketsGranted=rlHistoryControlBucketsGranted, rlHistoryControlInterval=rlHistoryControlInterval, rlRmonControlHistoryControlMaxGlobalBuckets=rlRmonControlHistoryControlMaxGlobalBuckets, rlHistoryControlOwner=rlHistoryControlOwner, rlControlHistoryControlQuotaBucket=rlControlHistoryControlQuotaBucket)

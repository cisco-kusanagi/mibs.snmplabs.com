#
# PySNMP MIB module Fore-E1-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Fore-E1-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:17:00 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint")
asx, = mibBuilder.importSymbols("Fore-Common-MIB", "asx")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, MibIdentifier, Counter64, NotificationType, Unsigned32, ModuleIdentity, Gauge32, IpAddress, iso, TimeTicks, Integer32, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "MibIdentifier", "Counter64", "NotificationType", "Unsigned32", "ModuleIdentity", "Gauge32", "IpAddress", "iso", "TimeTicks", "Integer32", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
foreE1 = ModuleIdentity((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8))
if mibBuilder.loadTexts: foreE1.setLastUpdated('9911050000Z')
if mibBuilder.loadTexts: foreE1.setOrganization('FORE')
if mibBuilder.loadTexts: foreE1.setContactInfo(' Postal: FORE Systems Inc. 1000 FORE Drive Warrendale, PA 15086-7502 Tel: +1 724 742 6900 Email: nm_mibs@fore.com Web: http://www.fore.com')
if mibBuilder.loadTexts: foreE1.setDescription('This mib implements management tables for the E1 port module.')
e1ConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1))
e1StatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2))
e1ConfTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1), )
if mibBuilder.loadTexts: e1ConfTable.setStatus('current')
if mibBuilder.loadTexts: e1ConfTable.setDescription('A table of E1 switch port configuration information.')
e1ConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1), ).setIndexNames((0, "Fore-E1-MIB", "e1ConfBoard"), (0, "Fore-E1-MIB", "e1ConfModule"), (0, "Fore-E1-MIB", "e1ConfPort"))
if mibBuilder.loadTexts: e1ConfEntry.setStatus('current')
if mibBuilder.loadTexts: e1ConfEntry.setDescription('A table entry containing E1 configuration information for each port. Not all RFC1406 configuration table variables are included, and some are modified.')
e1ConfBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1ConfBoard.setStatus('current')
if mibBuilder.loadTexts: e1ConfBoard.setDescription("The index of this port's switch board.")
e1ConfModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1ConfModule.setStatus('current')
if mibBuilder.loadTexts: e1ConfModule.setDescription('The network module of this port.')
e1ConfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1ConfPort.setStatus('current')
if mibBuilder.loadTexts: e1ConfPort.setDescription('The number of this port.')
e1LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("e1Other", 1), ("e1NoCRC", 2), ("e1CRC", 3), ("e1MF", 4), ("e1CRCMF", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1LineType.setStatus('current')
if mibBuilder.loadTexts: e1LineType.setDescription('This variable indicates the variety of E1 Line implementing this circuit. The type of circuit affects the number of bits per second that the circuit can reasonably carry, as well as the interpretation of the usage and error statistics. This variable is defined in the rfc1406 configuration table as dsx1LineType. According to rfc1406, the different values are: e1NoCRC CCITT recommendation G.704 (table a) e1CRC CCITT recommendation G.704 (table b) e1MF G.704(table a) with TS16 multifatming enabled e1MFCRC G.704(table b) with TS16 multifatming enabled.')
e1LineCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("e1Other", 1), ("e1HDB3", 2), ("e1AMI", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1LineCoding.setStatus('current')
if mibBuilder.loadTexts: e1LineCoding.setDescription('This variable describes the variety of Zero Code suppression used on this link, which in turn affects a number of its characteristics. e1AMI(3) refers to a mode wherein no zero code suppression is present and the line encoding does not solve the problem directly. In this application, the higher layer must provide data which meets or exceeds the pulse density re-quirements, such as inverting HDLC data. This variable is defined in the rfc1406 configuration table as dsx1LineCoding.')
e1SendCode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("e1SendNoCode", 1), ("e1SendLineCode", 2), ("e1SendPayloadCode", 3), ("e1SendResetCode", 4), ("e1SendQRS", 5), ("e1Send511Pattern", 6), ("e1Send3in24Pattern", 7), ("e1SendOtherTestPattern", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1SendCode.setStatus('current')
if mibBuilder.loadTexts: e1SendCode.setDescription('This variable indicates what type of code is being sent across the E1 interface by the device. The values mean: e1SendNoCode sending looped or normal data e1SendLineCode sending request for a line loopback e1SendPayloadCode sending a request for a payload loopback e1SendResetCode sending a loopback termination request e1SendQRS sending a Quasi-Random Signal (QRS) test pattern e1Send511Pattern sending a 511 bit fixed test pattern e1Send3in24Pattern sending a fixed test pattern of 3 bits set in 24 e1SendOtherTestPattern sending a test pattern other than the above.')
e1ReceiveCode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("e1ReceiveNoCode", 1), ("e1ReceiveLineCode", 2), ("e1ReceivePayloadCode", 3), ("e1ReceiveResetCode", 4), ("e1SendQRS", 5), ("e1Send511Pattern", 6), ("e1Send3in24Pattern", 7), ("e1SendOtherTestPattern", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1ReceiveCode.setStatus('current')
if mibBuilder.loadTexts: e1ReceiveCode.setDescription('This variable indicates the type of code that was received across the E1 interface. The values mean: e1ReceiveNoCode receiving looped or normal data e1ReceiveLineCode receiving request for a line loopback e1ReceivePayloadCode receiving a request for a payload loopback e1ReceiveResetCode receiving a loopback deactivation request e1ReceiveQRS receiving a Quasi-Random Signal (QRS) test pattern e1Receive511Pattern receiving a 511 bit fixed test pattern e1Receive3in24Pattern receiving a fixed test pattern of 3 bits set in 24 e1ReceiveOtherTestPattern receiving a test pattern other than the above.')
e1LoopbackConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("e1NoLoop", 1), ("e1LineLoop", 2), ("e1PayloadLoop", 3), ("e1DiagLoop", 4), ("e1OtherLoop", 5))).clone('e1NoLoop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e1LoopbackConfig.setStatus('current')
if mibBuilder.loadTexts: e1LoopbackConfig.setDescription("This variable represents the loopback configuration of the E1 interface. This variable is defined in the rfc1406 configuration table as dsx1LoopbackConfig, with slightly different values. e1NoLoop (1) means that the interface is not in a loopback state. e1LineLoop (2) means that cells that are processed by the receiving component are not written into the receive FIFO, but into the transmit FIFO for retransmission. e1PayloadLoop (3) means that the receive signal is looped back for retransmission after it has passed through the port's reframing function. e1DiagLoop (4) means that the transmit data stream is looped back to the receiver. e1OtherLoop (5) means that the interface is in a loopback that is not defined here.")
e1TxClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rxTiming", 1), ("localTiming", 2))).clone('localTiming')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e1TxClockSource.setStatus('current')
if mibBuilder.loadTexts: e1TxClockSource.setDescription('The source of the transmit clock. rxTiming(1) indicated that the recovered receive clock is used as the transmit clock. localTiming(2) indicates that a local source clock is used as the transmit clock. To determine which local source clock is used advise the ntGlobalClock in the netmodTimingTable for this netmod (refer to the Fore-Switch-MIB for more information).')
e1LineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65534))).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1LineStatus.setStatus('current')
if mibBuilder.loadTexts: e1LineStatus.setDescription('This variable indicates the Line Status of the interface. A similar object is defined in the rfc1406 configuration table as dsx1LineStatus. The variable contains loopback state information and failure state information. It is a bit map represented as a sum. The e1NoAlarm should be set if and only if no other flag is set. The various bit positions are: 1 e1NoAlarm 2 e1RxFarEndLOF Far end LOF (Receiving Yellow Alarm Indication) 4 e1TxFarEndLOF Near end sending LOF Indication (Yellow Alarm) 8 e1RxAIS Far end sending AIS 16 e1TxAIS Near end sending AIS (Not used) 32 e1LOF Near end Loss Of Frame (Red Alarm) 64 e1LOS Near end Loss Of Signal 128 e1LoopbackState Near end is in loopback mode 256 e1RxPLCPYel Receving PLCP Yellow 512 e1TxPLCPYel Transmitting PLCP Yellow 1024 e1RxPLCPLOF Receiving PLCP LOF 2048 e1RcvTestCode Receiving a test pattern 4096 e1OtherFailure any line status not defined here 32768 e1RxLCD Receiving LCD failure indication.')
e1IdleUnassignedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unassigned", 1), ("idle", 2))).clone('unassigned')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e1IdleUnassignedCells.setStatus('current')
if mibBuilder.loadTexts: e1IdleUnassignedCells.setDescription("This variable indicates the types of cells that should be sent in case there is no real data to send. According to the ATM Forum, Unassigned cells should be sent (octet 1-3 are 0's, octet 4 is 0000xxx0, where x is 'don't care'). According to the CCITT specifications, Idle cells should be sent (everything is '0' except for the CLP bit which is '1'). By default, unassigned cells are transmitted is case there is no data to send.")
e1LineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("e1LineLt110", 1), ("e1Line110-220", 2), ("e1Line220-330", 3), ("e1Line330-440", 4), ("e1Line440-550", 5), ("e1Line550-660", 6), ("e1LineG703-75", 7), ("e1LineG703-120", 8), ("e1LineLt110Alt", 9), ("e1Line110-220Alt", 10), ("e1Line220-330Alt", 11), ("e1Line330-440Alt", 12), ("e1Line440-550Alt", 13), ("e1Line550-660Alt", 14), ("e1LineG703-75Alt", 15), ("e1LineG703-120Alt", 16))).clone('e1LineLt110')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e1LineLength.setStatus('current')
if mibBuilder.loadTexts: e1LineLength.setDescription('This variable represents the length of the physical cable connected to the e1 port. The user has to set this object to match the physical cable in order to get the netmod to receive the signal on the cable. The different values are: e1LineLt110 (1) means the line is shorter than 110 ft, e1Line110-220 (2) means the line is between 110 and 220 ft, e1Line220-330 (3) means the line is between 220 and 330 ft, e1Line330-440 (4) means the line is between 330 and 440 ft, e1Line440-550 (5) means the line is between 440 and 550 ft, e1Line550-660 (6) means the line is between 550 and 660 ft, e1LineG703-75 (7) G703 standard (75 ohm coaxial line), e1LineG703-120 (8) G703 standard (120 ohm symmetrical line).')
e1LineTypeFraming = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("e1Hcs", 2), ("e1Plcp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e1LineTypeFraming.setStatus('current')
if mibBuilder.loadTexts: e1LineTypeFraming.setDescription('This variable indicates the way ATM cells are constructed from the E1 stream. e1Hcs(2) indicates that the ATM cells are constructed upon the Header Check Sequence (HCS) inside the ATM cell header. e1Plcp(3) indicates that the ATM cells are constructed from the E1 PLCP (Physical Layer Convergence Protocol) bits.')
e1RxScrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("descrambling", 1), ("noDescrambling", 2))).clone('descrambling')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e1RxScrambling.setStatus('current')
if mibBuilder.loadTexts: e1RxScrambling.setDescription('This variable indicates whether the information is being descrambled on receiving. It should be set the same as the transmitting side.')
e1TxScrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("scrambling", 1), ("noScrambling", 2))).clone('scrambling')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: e1TxScrambling.setStatus('current')
if mibBuilder.loadTexts: e1TxScrambling.setDescription('This variable indicates whether the information (48 octet payload) is being scrambled before transmitting. It should be set the same as the receiving side.')
e1FramingTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 1), )
if mibBuilder.loadTexts: e1FramingTable.setStatus('current')
if mibBuilder.loadTexts: e1FramingTable.setDescription('A table of E1 framing statistics information.')
e1FramingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 1, 1), ).setIndexNames((0, "Fore-E1-MIB", "e1FramingBoard"), (0, "Fore-E1-MIB", "e1FramingModule"), (0, "Fore-E1-MIB", "e1FramingPort"))
if mibBuilder.loadTexts: e1FramingEntry.setStatus('current')
if mibBuilder.loadTexts: e1FramingEntry.setDescription('A table entry containing E1 framing statistics information.')
e1FramingBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1FramingBoard.setStatus('current')
if mibBuilder.loadTexts: e1FramingBoard.setDescription("The index of this port's switch board.")
e1FramingModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1FramingModule.setStatus('current')
if mibBuilder.loadTexts: e1FramingModule.setDescription('The network module of this port.')
e1FramingPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1FramingPort.setStatus('current')
if mibBuilder.loadTexts: e1FramingPort.setDescription('The number of this port.')
e1FramingLCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1FramingLCVs.setStatus('current')
if mibBuilder.loadTexts: e1FramingLCVs.setDescription('The number of Line Code Violations (LCV) that were detected by the E1 Receive Framer block.')
e1FramingFERRs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1FramingFERRs.setStatus('current')
if mibBuilder.loadTexts: e1FramingFERRs.setDescription('Number of E1 framing error (FERR) events.')
e1FramingFEBEs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1FramingFEBEs.setStatus('current')
if mibBuilder.loadTexts: e1FramingFEBEs.setDescription('Number of E1 far end block errors.')
e1FramingCRCs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1FramingCRCs.setStatus('current')
if mibBuilder.loadTexts: e1FramingCRCs.setDescription('The number cyclic redundancy errors.')
e1FramingOOFs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1FramingOOFs.setStatus('current')
if mibBuilder.loadTexts: e1FramingOOFs.setDescription('Number of seconds when OOF (loss of basic frame alignment) errors were detected.')
e1FramingLOSs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1FramingLOSs.setStatus('current')
if mibBuilder.loadTexts: e1FramingLOSs.setDescription('Number of seconds when LOS (loss of signal) error events were experienced.')
e1FramingAISs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1FramingAISs.setStatus('current')
if mibBuilder.loadTexts: e1FramingAISs.setDescription('Number of seconds when AIS (alarm indication signal) error events were experienced.')
e1FramingAISDs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1FramingAISDs.setStatus('current')
if mibBuilder.loadTexts: e1FramingAISDs.setDescription('Number of seconds when AISD (unframed pattern of all ones) error events were experienced.')
e1FramingRedAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1FramingRedAlarms.setStatus('current')
if mibBuilder.loadTexts: e1FramingRedAlarms.setDescription('Number of seconds when Red Alarm events were experienced.')
e1FramingYellowAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1FramingYellowAlarms.setStatus('current')
if mibBuilder.loadTexts: e1FramingYellowAlarms.setDescription('Number of seconds when Yellow Alarm events were experienced.')
e1PlcpTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 2), )
if mibBuilder.loadTexts: e1PlcpTable.setStatus('current')
if mibBuilder.loadTexts: e1PlcpTable.setDescription('A table of E1 Physical Layer Convergence Protocol (Procedure) statistics information.')
e1PlcpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 2, 1), ).setIndexNames((0, "Fore-E1-MIB", "e1PlcpBoard"), (0, "Fore-E1-MIB", "e1PlcpModule"), (0, "Fore-E1-MIB", "e1PlcpPort"))
if mibBuilder.loadTexts: e1PlcpEntry.setStatus('current')
if mibBuilder.loadTexts: e1PlcpEntry.setDescription('A table entry containing E1 PLCP statistics information.')
e1PlcpBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1PlcpBoard.setStatus('current')
if mibBuilder.loadTexts: e1PlcpBoard.setDescription("The index of this port's switch board.")
e1PlcpModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1PlcpModule.setStatus('current')
if mibBuilder.loadTexts: e1PlcpModule.setDescription('The network module of this port.')
e1PlcpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1PlcpPort.setStatus('current')
if mibBuilder.loadTexts: e1PlcpPort.setDescription('The number of this port.')
e1PlcpBIP8s = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1PlcpBIP8s.setStatus('current')
if mibBuilder.loadTexts: e1PlcpBIP8s.setDescription('Number of BIP-8 (Bit Interleaved Parity - 8) error events. The BIP-8 is calculated over the Path Overhead field and the associated ATM cell of the previous frame. A BIP-N is a method of error monitoring. An N bit code is generated by the transmitting equipment in such a manner that the first bit of the code provides even parity over the first bit of all N-bit sequences in the previous VT SPE, the second bit provides even parity over the second bits of all N-bit sequences within the specified portion, etc.')
e1PlcpFERRs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1PlcpFERRs.setStatus('current')
if mibBuilder.loadTexts: e1PlcpFERRs.setDescription('Number of Physical Layer Convergence Protocol (PLCP) octet error events.')
e1PlcpFEBEs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1PlcpFEBEs.setStatus('current')
if mibBuilder.loadTexts: e1PlcpFEBEs.setDescription('Number of ATM Far End Block Error (FEBE) events.')
e1PlcpLOFs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1PlcpLOFs.setStatus('current')
if mibBuilder.loadTexts: e1PlcpLOFs.setDescription('The number of seconds in which Loss Of Frame (LOF) errors were detected by the PLCP (Physical Layer Convergence Protocol) receiver. LOF is declared when an Out-Of-Frame state persists for more than 1ms. LOF is removed when in-frame state persists for more than 12ms.')
e1PlcpYellows = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1PlcpYellows.setStatus('current')
if mibBuilder.loadTexts: e1PlcpYellows.setDescription('The number of seconds in which Yellow alarm errors were detected by the PLCP (Physical Layer Convergence Protocol) receiver. Yellow alarm is asserted when 10 consecutive yellow signal bits are set to logical 1. Yellow signals are used to alert upstream terminals of a downstream failure in order to initiate trunk conditioning on the failure circuit.')
e1AtmTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 3), )
if mibBuilder.loadTexts: e1AtmTable.setStatus('current')
if mibBuilder.loadTexts: e1AtmTable.setDescription('A table of E1 ATM statistics information.')
e1AtmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 3, 1), ).setIndexNames((0, "Fore-E1-MIB", "e1AtmBoard"), (0, "Fore-E1-MIB", "e1AtmModule"), (0, "Fore-E1-MIB", "e1AtmPort"))
if mibBuilder.loadTexts: e1AtmEntry.setStatus('current')
if mibBuilder.loadTexts: e1AtmEntry.setDescription('A table entry containing E1 ATM statistics information.')
e1AtmBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1AtmBoard.setStatus('current')
if mibBuilder.loadTexts: e1AtmBoard.setDescription("The index of this port's switch board.")
e1AtmModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1AtmModule.setStatus('current')
if mibBuilder.loadTexts: e1AtmModule.setDescription('The network module of this port.')
e1AtmPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1AtmPort.setStatus('current')
if mibBuilder.loadTexts: e1AtmPort.setDescription('The number of this port.')
e1AtmHCSs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1AtmHCSs.setStatus('current')
if mibBuilder.loadTexts: e1AtmHCSs.setDescription('Number of header check sequence (HCS) error events. The HCS is a CRC-8 calculation over the first 4 octets of the ATM cell header.')
e1AtmRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1AtmRxCells.setStatus('current')
if mibBuilder.loadTexts: e1AtmRxCells.setDescription('Number of ATM cells that were received.')
e1AtmTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1AtmTxCells.setStatus('current')
if mibBuilder.loadTexts: e1AtmTxCells.setDescription('Number of non-null ATM cells that were transmitted.')
e1AtmUHCSs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1AtmUHCSs.setStatus('current')
if mibBuilder.loadTexts: e1AtmUHCSs.setDescription('Number of uncorrectable header check sequence (HCS) error events. The HCS is a CRC-8 calculation over the first 4 octets of the ATM cell header.')
e1AtmCHCSs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1AtmCHCSs.setStatus('current')
if mibBuilder.loadTexts: e1AtmCHCSs.setDescription('Number of correctable header check sequence (HCS) error events. The HCS is a CRC-8 calculation over the first 4 octets of the ATM cell header.')
e1AtmLCDs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 8, 2, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1AtmLCDs.setStatus('current')
if mibBuilder.loadTexts: e1AtmLCDs.setDescription('The number of seconds in which Loss of Cell Delineation (LCD) has occurred. An LCD defect is detected when an out of cell delination state has persisted for 4ms. An LCD defect is cleared when the sync state has been maintained for 4ms.')
mibBuilder.exportSymbols("Fore-E1-MIB", e1LoopbackConfig=e1LoopbackConfig, e1AtmEntry=e1AtmEntry, e1PlcpBIP8s=e1PlcpBIP8s, e1FramingCRCs=e1FramingCRCs, e1FramingBoard=e1FramingBoard, e1LineCoding=e1LineCoding, e1TxClockSource=e1TxClockSource, e1FramingEntry=e1FramingEntry, e1ReceiveCode=e1ReceiveCode, e1FramingRedAlarms=e1FramingRedAlarms, e1PlcpEntry=e1PlcpEntry, e1ConfModule=e1ConfModule, e1RxScrambling=e1RxScrambling, e1LineType=e1LineType, e1FramingLCVs=e1FramingLCVs, e1PlcpPort=e1PlcpPort, e1StatsGroup=e1StatsGroup, e1FramingModule=e1FramingModule, e1FramingAISDs=e1FramingAISDs, e1LineTypeFraming=e1LineTypeFraming, e1PlcpFERRs=e1PlcpFERRs, foreE1=foreE1, e1AtmTable=e1AtmTable, e1AtmHCSs=e1AtmHCSs, e1FramingPort=e1FramingPort, e1FramingYellowAlarms=e1FramingYellowAlarms, e1PlcpModule=e1PlcpModule, e1PlcpBoard=e1PlcpBoard, e1FramingFEBEs=e1FramingFEBEs, e1LineLength=e1LineLength, e1FramingTable=e1FramingTable, e1AtmModule=e1AtmModule, e1AtmTxCells=e1AtmTxCells, e1SendCode=e1SendCode, e1PlcpFEBEs=e1PlcpFEBEs, PYSNMP_MODULE_ID=foreE1, e1ConfPort=e1ConfPort, e1FramingFERRs=e1FramingFERRs, e1TxScrambling=e1TxScrambling, e1AtmCHCSs=e1AtmCHCSs, e1PlcpLOFs=e1PlcpLOFs, e1ConfBoard=e1ConfBoard, e1AtmRxCells=e1AtmRxCells, e1AtmUHCSs=e1AtmUHCSs, e1ConfEntry=e1ConfEntry, e1LineStatus=e1LineStatus, e1FramingAISs=e1FramingAISs, e1PlcpTable=e1PlcpTable, e1AtmBoard=e1AtmBoard, e1ConfTable=e1ConfTable, e1FramingOOFs=e1FramingOOFs, e1AtmPort=e1AtmPort, e1AtmLCDs=e1AtmLCDs, e1ConfGroup=e1ConfGroup, e1FramingLOSs=e1FramingLOSs, e1PlcpYellows=e1PlcpYellows, e1IdleUnassignedCells=e1IdleUnassignedCells)

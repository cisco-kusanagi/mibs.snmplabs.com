#
# PySNMP MIB module ICF-VG-RPTR (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ICF-VG-RPTR
# Produced by pysmi-0.3.4 at Wed May  1 13:35:52 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion")
icfVgRepeater, hpicfObjectModules = mibBuilder.importSymbols("HP-ICF-OID", "icfVgRepeater", "hpicfObjectModules")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Counter64, iso, TimeTicks, Gauge32, ObjectIdentity, Unsigned32, Integer32, NotificationType, ModuleIdentity, Counter32, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Counter64", "iso", "TimeTicks", "Gauge32", "ObjectIdentity", "Unsigned32", "Integer32", "NotificationType", "ModuleIdentity", "Counter32", "Bits")
MacAddress, TruthValue, DisplayString, TextualConvention, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "TruthValue", "DisplayString", "TextualConvention", "TimeStamp")
icfVgRepeaterMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 10))
icfVgRepeaterMib.setRevisions(('2000-11-03 22:25', '1997-03-06 03:47', '1996-09-10 02:03', '1996-01-25 03:56', '1995-01-18 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: icfVgRepeaterMib.setRevisionsDescriptions(('Updated division name.', 'Added NOTIFICATION-GROUP information.', 'Updated division name and STATUS info.', 'Split this MIB module from the former monolithic hp-icf MIB. Added support for and full 802.12 compliance.', 'Initial version of this MIB module. Released with the HPJ2414A agent card for the HPJ2410A 100VG repeater.',))
if mibBuilder.loadTexts: icfVgRepeaterMib.setLastUpdated('200011032225Z')
if mibBuilder.loadTexts: icfVgRepeaterMib.setOrganization('Hewlett Packard Company, Network Infrastructure Solutions')
if mibBuilder.loadTexts: icfVgRepeaterMib.setContactInfo('Hewlett Packard Company 8000 Foothills Blvd. Roseville, CA 95747')
if mibBuilder.loadTexts: icfVgRepeaterMib.setDescription('This MIB module contains objects for managing HP AdvanceStack 100VG-AnyLAN repeaters. It is expected that this module will be superceded by a standard 802.12 Repeater MIB.')
icfVgBasic = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1))
icfVgBasicRptr = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1))
icfVgMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgMACAddress.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.2.1, aMACAddress.')
if mibBuilder.loadTexts: icfVgMACAddress.setStatus('current')
if mibBuilder.loadTexts: icfVgMACAddress.setDescription('The MAC address used by the repeater when it initiates training on the uplink port. Repeaters are allowed to train with an assigned MAC address or a null (all zeroes) MAC address.')
icfVgCurrentFramingType = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgCurrentFramingType.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.2.1, aCurrentFramingType.')
if mibBuilder.loadTexts: icfVgCurrentFramingType.setStatus('current')
if mibBuilder.loadTexts: icfVgCurrentFramingType.setDescription('The type of framing (802.3 or 802.5) currently in use by the repeater.')
icfVgDesiredFramingType = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfVgDesiredFramingType.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.2.1, aDesiredFramingType.')
if mibBuilder.loadTexts: icfVgDesiredFramingType.setStatus('current')
if mibBuilder.loadTexts: icfVgDesiredFramingType.setDescription('The type of framing which will be used by the repeater after the next time it is reset. The value of this object should be preserved across repeater resets and power failures')
icfVgFramingCapability = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2), ("frameTypeEither", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgFramingCapability.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.2.1, aFramingCapability.')
if mibBuilder.loadTexts: icfVgFramingCapability.setStatus('current')
if mibBuilder.loadTexts: icfVgFramingCapability.setDescription('The type of framing this repeater is capable of supporting.')
icfVgTrainingVersion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgTrainingVersion.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.2.1, aRMACVersion.')
if mibBuilder.loadTexts: icfVgTrainingVersion.setStatus('current')
if mibBuilder.loadTexts: icfVgTrainingVersion.setDescription('The highest version bits (vvv bits) supported by the repeater during training.')
icfVgRepeaterGroupCapacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgRepeaterGroupCapacity.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.2.1, aRepeaterGroupCapacity.')
if mibBuilder.loadTexts: icfVgRepeaterGroupCapacity.setStatus('current')
if mibBuilder.loadTexts: icfVgRepeaterGroupCapacity.setDescription('The icfVgGroupCapacity is the number of groups that can be contained within the repeater. Within each managed repeater, the groups are uniquely numbered in the range from 1 to icfVgRepeaterGroupCapacity. Some groups may not be present in the repeater, in which case the actual number of groups present will be less than icfVgRepeaterGroupCapacity. The number of groups present is never greater than icfVgRepeaterGroupCapacity.')
icfVgRepeaterHealthState = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("rptrFailure", 3), ("groupFailure", 4), ("portFailure", 5), ("generalFailure", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgRepeaterHealthState.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.2.1, aRepeaterHealthState.')
if mibBuilder.loadTexts: icfVgRepeaterHealthState.setStatus('current')
if mibBuilder.loadTexts: icfVgRepeaterHealthState.setDescription("The icfVgRepeaterHealthState object indicates the operational state of the repeater. The icfVgRepeaterHealthText may be consulted for more specific information about the state of the repeater's health. In the case of multiple kinds of failures (e.g., repeater failure and port failure), the value of this attribute shall reflect the highest priority failure in the following order, listed highest priority first: rptrFailure(3) groupFailure(4) portFailure(5) generalFailure(6).")
icfVgRepeaterHealthText = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgRepeaterHealthText.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.2.1, aRepeaterHealthText.')
if mibBuilder.loadTexts: icfVgRepeaterHealthText.setStatus('current')
if mibBuilder.loadTexts: icfVgRepeaterHealthText.setDescription('The health text object is a text string that provides information relevant to the operational state of the repeater. Agents may use this string to provide detailed information on current failures, including how they were detected, and/or instructions for problem resolution. The contents are agent specific.')
icfVgRepeaterReset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfVgRepeaterReset.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.2.2, acResetRepeater.')
if mibBuilder.loadTexts: icfVgRepeaterReset.setStatus('current')
if mibBuilder.loadTexts: icfVgRepeaterReset.setDescription('Setting this object to reset(2) causes the repeater to transition to its initial state as specified in clause 12 [IEEE Draft Std 802.12]. Setting this object to noReset(1) has no effect. The agent will always return the value noReset(1) when this object is read. After receiving a request to set this variable to reset(2), the agent is allowed to delay the reset for a short period. For example, the implementor may choose to delay the reset long enough to allow the SNMP response to be transmitted. In any event, the SNMP response must be transmitted. This action does not reset the management counters defined in this document nor does it affect the icfVgPortAdminStatus parameters. Included in this action is the execution of a disruptive Self-Test with the following characteristics: a) The nature of the tests is not specified. b) The test resets the repeater but without affecting management information about the repeater. c) The test does not inject packets onto any segment. d) Packets received during the test may or may not be transferred. e) The test does not interfere with management functions. After performing this self-test, the agent will update the repeater health information (including icfVgRepeaterHealthState and icfVgRepeaterHealthText).')
icfVgRepeaterNonDisruptTest = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noSelfTest", 1), ("selfTest", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfVgRepeaterNonDisruptTest.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.2.2, acExecuteNonDisruptiveSelfTest.')
if mibBuilder.loadTexts: icfVgRepeaterNonDisruptTest.setStatus('current')
if mibBuilder.loadTexts: icfVgRepeaterNonDisruptTest.setDescription("Setting this object to selfTest(2) causes the repeater to perform an agent-specific, non-disruptive self-test that has the following characteristics: a) The nature of the tests is not specified. b) The test does not change the state of the repeater or management information about the repeater. c) The test does not inject packets onto any segment. d) The test does not prevent the relay of any packets. e) The test does not interfere with management functions. After performing this test, the agent will update the repeater health information (including icfVgRepeaterHealthState and icfVgRepeaterHealthText). Note that this definition allows returning an 'okay' result after doing a trivial test. Setting this object to noSelfTest(1) has no effect. The agent will always return the value noSelfTest(1) when this object is read.")
icfVgBasicGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2))
icfVgBasicGroupTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1), )
if mibBuilder.loadTexts: icfVgBasicGroupTable.setStatus('current')
if mibBuilder.loadTexts: icfVgBasicGroupTable.setDescription('A table containing information about groups of ports.')
icfVgBasicGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1), ).setIndexNames((0, "ICF-VG-RPTR", "icfVgGroupIndex"))
if mibBuilder.loadTexts: icfVgBasicGroupEntry.setStatus('current')
if mibBuilder.loadTexts: icfVgBasicGroupEntry.setDescription('An entry in the icfVgBasicGroupTable, containing information about a single group of ports.')
icfVgGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)))
if mibBuilder.loadTexts: icfVgGroupIndex.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.4.1, aGroupID.')
if mibBuilder.loadTexts: icfVgGroupIndex.setStatus('current')
if mibBuilder.loadTexts: icfVgGroupIndex.setDescription('This object identifies the group within the repeater for which this entry contains information. This value is never greater than icfVgRepeaterGroupCapacity.')
icfVgGroupDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgGroupDescr.setStatus('current')
if mibBuilder.loadTexts: icfVgGroupDescr.setDescription("A textual description of the group. This value should include the full name and version identification of the group's hardware type and indicate how the group is differentiated from other types of groups in the repeater. 'Plug-in Module, Rev A' or 'Barney Rubble 100BaseVG 4-port socket Version 2.1' are examples of valid group descriptions. It is mandatory that this only contain printable ASCII characters.")
icfVgGroupObjectID = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgGroupObjectID.setStatus('current')
if mibBuilder.loadTexts: icfVgGroupObjectID.setDescription("The vendor's authoritative identification of the group. This value may be allocated within the SMI enterprises subtree (1.3.6.1.4.1) and provides a straight-forward and unambiguous means for determining what kind of group is being managed. For example, this object could take the value 1.3.6.1.4.1.4242.1.2.14 if vendor 'Flintstones, Inc.' was assigned the subtree 1.3.6.1.4.1.4242, and had assigned the identifier 1.3.6.1.4.1.4242.1.2.14 to its 'Wilma Flintstone 6-Port Plug-in Module.'")
icfVgGroupOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("operational", 2), ("malfunctioning", 3), ("notPresent", 4), ("underTest", 5), ("resetInProgress", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgGroupOperStatus.setStatus('current')
if mibBuilder.loadTexts: icfVgGroupOperStatus.setDescription('An object that indicates the operational status of the group. A status of notPresent(4) indicates that the group is temporarily or permanently physically and/or logically not a part of the repeater. It is an implementation-specific matter as to whether the agent effectively removes notPresent entries from the table. A status of operational(2) indicates that the group is functioning, and a status of malfunctioning(3) indicates that the group is malfunctioning in some way.')
icfVgGroupLastOperStatusChange = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgGroupLastOperStatusChange.setStatus('current')
if mibBuilder.loadTexts: icfVgGroupLastOperStatusChange.setDescription("An object that contains the value of sysUpTime at the time that the value of the icfVgGroupOperStatus object for this group last changed. A value of zero indicates that the group's operational status has not changed since the agent last restarted.")
icfVgGroupPortCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgGroupPortCapacity.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.4.1, aGroupPortCapacity.')
if mibBuilder.loadTexts: icfVgGroupPortCapacity.setStatus('current')
if mibBuilder.loadTexts: icfVgGroupPortCapacity.setDescription('The icfVgGroupPortCapacity is the number of ports that can be contained within the group. Valid range is 1-1024. Within each group, the ports are uniquely numbered in the range from 1 to icfVgGroupPortCapacity. Some ports may not be present in a given group instance, in which case the actual number of ports present is less than icfVgGroupPortCapacity. The number of ports present is never greater than icfVgGroupPortCapacity.')
icfVgGroupCablesBundled = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("someCablesBundled", 1), ("noCablesBundled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfVgGroupCablesBundled.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.4.1, aGroupCablesBundled.')
if mibBuilder.loadTexts: icfVgGroupCablesBundled.setStatus('current')
if mibBuilder.loadTexts: icfVgGroupCablesBundled.setDescription("This configuration flag is used to select either bundled or unbundled cabling. When this flag is 'someCablesBundled(1)' and the port is not promiscuous or cascaded, frames received from ports on this group and destined to go out multiple ports on this group will be buffered completely before being repeated out ports on this group. When this flag is 'noCablesBundled(2)' or the port is promiscuous or cascaded, these frames will be repeated out ports on this group as the frame is being received. Note that the value 'someCablesBundled(1)' will work in the vast majority of installations, regardless of whether or not any cables are physically in a bundle, since promiscuous and cascaded ports automatically avoid the store and forward. The main situation in which 'noCablesBundled(2)' is beneficial is when there is a large amount of multicast traffic and the cables are not in a bundle. The value of this object should be preserved across repeater resets and power failures.")
icfVgBasicPort = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3))
icfVgBasicPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1), )
if mibBuilder.loadTexts: icfVgBasicPortTable.setStatus('current')
if mibBuilder.loadTexts: icfVgBasicPortTable.setDescription('A table containing information about ports.')
icfVgBasicPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1), ).setIndexNames((0, "ICF-VG-RPTR", "icfVgPortGroupIndex"), (0, "ICF-VG-RPTR", "icfVgPortIndex"))
if mibBuilder.loadTexts: icfVgBasicPortEntry.setStatus('current')
if mibBuilder.loadTexts: icfVgBasicPortEntry.setDescription('An entry in the icfVgBasicPortTable, containing information about a single port.')
icfVgPortGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)))
if mibBuilder.loadTexts: icfVgPortGroupIndex.setStatus('current')
if mibBuilder.loadTexts: icfVgPortGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information.')
icfVgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)))
if mibBuilder.loadTexts: icfVgPortIndex.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aPortID.')
if mibBuilder.loadTexts: icfVgPortIndex.setStatus('current')
if mibBuilder.loadTexts: icfVgPortIndex.setDescription('This object identifies the port within the group for which this entry contains information. This value can never be greater than icfVgGroupPortCapacity for the associated group.')
icfVgPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cascadeExternal", 1), ("cascadeInternal", 2), ("localExternal", 3), ("localInternal", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortType.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aPortType.')
if mibBuilder.loadTexts: icfVgPortType.setStatus('current')
if mibBuilder.loadTexts: icfVgPortType.setDescription("Describes the type of port. One of the following: cascadeExternal - Port is an uplink with physical connections which are externally visible cascadeInternal - Port is an uplink with physical connections which are not externally visible, such as a connection to an internal backplane in a chassis localExternal - Port is a downlink or local port with externally visible connections localInternal - Port is a downlink or local port with connections which are not externally visible, such as a connection to an internal agent 'internal' is used to identify ports which place traffic into the repeater, but do not have any external connections. Note that both DTE and cascaded repeater downlinks are considered 'local' ports.")
icfVgPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfVgPortAdminStatus.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aPortAdministrativeState.')
if mibBuilder.loadTexts: icfVgPortAdminStatus.setStatus('current')
if mibBuilder.loadTexts: icfVgPortAdminStatus.setDescription('Port enable/disable function. Enabling a disabled port will cause training to be initiated. Setting this object to disabled(2) disables the port. A disabled port neither transmits nor receives. Once disabled, a port must be explicitly enabled to restore operation. A port which is disabled when power is lost or when a reset is exerted shall remain disabled when normal operation resumes.')
icfVgPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("training", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortStatus.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aPortStatus.')
if mibBuilder.loadTexts: icfVgPortStatus.setStatus('current')
if mibBuilder.loadTexts: icfVgPortStatus.setDescription("Current status for the port as specified by the PORT_META_STATE in the port process module of clause 12 [IEEE Draft Std 802.12]. During initialization or any link warning conditions, icfVgPortStatus will be 'inactive(2)'. When Training_Up is received by the repeater on a local port (or when Training_Down is received on a cascade port), icfVgPortStatus will change to 'training(3)' and icfVgTrainingResult can be monitored to see the detailed status regarding training. When 24 consecutive good FCS packets are received and the configuration bits are OK, icfVgPortStatus will change to 'active(1)'. A disabled port shall have a port status of 'inactive(2)'.")
icfVgPortSupportedPromiscMode = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("singleModeOnly", 1), ("singleOrPromiscMode", 2), ("promiscModeOnly", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortSupportedPromiscMode.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aSupportedPromiscMode.')
if mibBuilder.loadTexts: icfVgPortSupportedPromiscMode.setStatus('current')
if mibBuilder.loadTexts: icfVgPortSupportedPromiscMode.setDescription("This object describes whether the port hardware is capable of supporting promiscuous mode, single address mode (i.e., repeater filters unicasts not addressed to the end station attached to this port), or both. A port for which icfVgPortType is equal to 'cascadeInternal' or 'cascadeExternal' will always have a value of 'promiscModeOnly' for this object.")
icfVgPortSupportedCascadeMode = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("endNodesOnly", 1), ("endNodesOrRepeaters", 2), ("cascadePort", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortSupportedCascadeMode.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aSupportedCascadeMode.')
if mibBuilder.loadTexts: icfVgPortSupportedCascadeMode.setStatus('current')
if mibBuilder.loadTexts: icfVgPortSupportedCascadeMode.setDescription("This object describes whether the port hardware is capable of supporting cascaded repeaters, end nodes, or both. A port for which icfVgPortType is equal to 'cascadeInternal' or 'cascadeExternal' will always have a value of 'cascadePort' for this object.")
icfVgPortAllowedTrainType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allowEndNodesOnly", 1), ("allowPromiscuousEndNodes", 2), ("allowEndNodesOrRepeaters", 3), ("allowAnything", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfVgPortAllowedTrainType.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aAllowableTrainingType.')
if mibBuilder.loadTexts: icfVgPortAllowedTrainType.setStatus('current')
if mibBuilder.loadTexts: icfVgPortAllowedTrainType.setDescription("This security object is set by the network manager to configure what type of device is permitted to connect to the port. One of the following values: allowEndNodesOnly - only non-promiscuous end nodes permitted. allowPromiscuousEndNodes - promiscuous or non- promiscuous end nodes permitted allowEndNodesOrRepeaters - repeaters or non- promiscuous end nodes permitted allowAnything - repeaters, promiscuous or non-promiscuous end nodes permitted For a port for which icfVgPortType is equal to 'cascadeInternal' or 'cascadeExternal', the corresponding instance of this object may not be set to 'allowEndNodesOnly' or 'allowPromiscuousEndNodes'. The agent must reject a SET of this object if the value includes no capabilities that are supported by this port's hardware, as defined by the values of the corresponding instances of icfVgPortSupportedPromiscMode and icfVgPortSupportedCascadeMode.")
icfVgPortLastTrainConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortLastTrainConfig.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aLastTrainingConfig.')
if mibBuilder.loadTexts: icfVgPortLastTrainConfig.setStatus('current')
if mibBuilder.loadTexts: icfVgPortLastTrainConfig.setDescription("This 16 bit field contains the most recent training configuration in an error-free training frame sent by the end node connected to the port. For cascade ports, this is the responder's configuration field from the most recent error-free training response frame received in response to training initiated by this repeater. This object is formatted as follows: First Octet: Second Octet: 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ |v|v|v|0|0|0|0|0| |0|0|0|F|F|P|P|R| +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ vvv: The version of the 802.12 training protocol with which the training initiator is compliant FF: 00 = frameType88023 is requested 01 = frameType88025 is requested 10 = reserved 11 = either frameType88023 or frameType88025 is acceptable PP: 00 = request singleAddressMode 01 = request promiscuousMode 10 = reserved 11 = reserved R: 0 = request is from an end node 1 = request is from a repeater")
icfVgPortTrainingResult = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortTrainingResult.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aTrainingResult.')
if mibBuilder.loadTexts: icfVgPortTrainingResult.setStatus('current')
if mibBuilder.loadTexts: icfVgPortTrainingResult.setDescription("This 18 bit field is used to indicate the result of training. It contains two bits which indicate if error-free training frames have been received, and it also contains the 16 bits of the most recent valid training response frame on the port. First Octet: Second Octet: Third Octet: 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ |0|0|0|0|0|0|V|G| |v|v|v|D|C|N|0|0| |0|0|0|F|F|P|P|R| +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ V: Valid: set when at least one error-free training frame has been received. Indicates the 16 training configuration bits in icfVgPortLastTrainConfig and icfVgPortTrainingResult contain valid information. This bit is cleared when icfVgPortStatus transitions to the 'inactive' or 'training' state. G: LinkGood: indicates the link hardware is OK. Set if 24 consecutive error-free training packets have been received. Cleared when a training packet with errors is received, and when icfVgPortStatus transitions to the 'inactive' or 'training' state. vvv: The version of the 802.12 training protocol with which the training responder is compliant D: 0 = no duplicate address has been detected 1 = duplicate address has been detected C: 0 = the requested configuration is compatible with the port 1 = the requested configuration is not compatible with the port. The FF, PP and R bits indicate the configuration which would be allowed (providing N = 0). N: 0 = access will be allowed, providing the configuration is compatible (C = 0). 1 = access not allowed because of security restrictions FF: 00 = frameType88023 will be used 01 = frameType88025 will be used 10 = reserved 11 = reserved PP: 00 = singleAddressMode will be used 01 = promiscuousMode will be used 10 = reserved 11 = reserved R: 0 = requested access as an end node is allowed 1 = requested access as a repeater is allowed If the port is in training, a management station can examine this object to see if any training packets have been passed successfully. If there have been any good training packets, the Valid bit will be set and the management station can examine the 16 training response bits to see if there is a duplicate address, configuration, or security problem. Note that on a repeater local port, this repeater generates the training response bits, while on the cascade port, the higher level repeater originated the training response bits.")
icfVgPortPriorityEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfVgPortPriorityEnable.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aPriorityEnable.')
if mibBuilder.loadTexts: icfVgPortPriorityEnable.setStatus('current')
if mibBuilder.loadTexts: icfVgPortPriorityEnable.setDescription("A configuration flag used to determine whether the repeater will service high priority requests received on the port as high priority or normal priority. When 'false', high priority requests on this port will be serviced as normal priority. The value of this object should be preserved across repeater resets and power failures. The setting of this object has no effect on a cascade port.")
icfVgPortMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 1, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("pmdMissing", 3), ("utp4", 4), ("stp2", 5), ("fibre", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortMediaType.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aMediaType.')
if mibBuilder.loadTexts: icfVgPortMediaType.setStatus('current')
if mibBuilder.loadTexts: icfVgPortMediaType.setDescription("The type of physical media in use. One of the following values: other undefined unknown true state not known pmdMissing PMD device not attached utp4 4-pair unshielded twisted pair stp2 2-pair shielded twisted pair fibre 802.12 fibre optic cabling This object may be 'unknown' if the implementation is not capable of identifying the PMD media type, or whether or not the PMD is even present.")
icfVgMonitor = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2))
icfVgMonRptr = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 1))
icfVgMonGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 2))
icfVgMonPort = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3))
icfVgMonPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1), )
if mibBuilder.loadTexts: icfVgMonPortTable.setStatus('current')
if mibBuilder.loadTexts: icfVgMonPortTable.setDescription('A table of performance and error statistics for the ports.')
icfVgMonPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1), ).setIndexNames((0, "ICF-VG-RPTR", "icfVgPortGroupIndex"), (0, "ICF-VG-RPTR", "icfVgPortIndex"))
if mibBuilder.loadTexts: icfVgMonPortEntry.setStatus('current')
if mibBuilder.loadTexts: icfVgMonPortEntry.setDescription('An entry in the icfVgMonPortTable, containing performance and error statistics for a single port.')
icfVgPortReadableFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortReadableFrames.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aReadableFramesReceived.')
if mibBuilder.loadTexts: icfVgPortReadableFrames.setStatus('current')
if mibBuilder.loadTexts: icfVgPortReadableFrames.setDescription('This object is the number of good frames of valid frame length that have been received on this port. This counter is incremented by one for each frame received on the port which is not counted by icfVgPortIPMFrames or icfVgPortDataErrorFrames.')
icfVgPortReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortReadableOctets.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aReadableOctetsReceived.')
if mibBuilder.loadTexts: icfVgPortReadableOctets.setStatus('current')
if mibBuilder.loadTexts: icfVgPortReadableOctets.setDescription('This object is a count of the number of octets contained in good frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which has been determined to be a readable frame (i.e. each frame counted by icfVgPortReadableFrames). Note that this counter will roll over very quickly. It is provided for backward compatibility for Network Management protocols that do not support 64 bit counters (e.g. SNMP version 1).')
icfVgPortUnreadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortUnreadableOctets.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aOctetsInUnreadableFramesRcvd.')
if mibBuilder.loadTexts: icfVgPortUnreadableOctets.setStatus('current')
if mibBuilder.loadTexts: icfVgPortUnreadableOctets.setDescription('This object is a count of the number of octets contained in invalid frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which is counted by icfVgPortIPMFrames or icfVgPortDataErrorFrames. This counter can be combined with icfVgPortReadableOctets to calculate network utilization. Note that this counter will roll over very quickly. It is provided for backward compatibility for Network Management protocols that do not support 64 bit counters (e.g. SNMP version 1).')
icfVgPortHighPriorityFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortHighPriorityFrames.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aHighPriorityFramesReceived.')
if mibBuilder.loadTexts: icfVgPortHighPriorityFrames.setStatus('current')
if mibBuilder.loadTexts: icfVgPortHighPriorityFrames.setDescription('This object is a count of high priority frames that have been received on this port. This counter is incremented by one for each high priority frame received on this port, including readable, invalid, and training frames. This counter does not include normal priority frames which were priority promoted.')
icfVgPortHighPriorityOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortHighPriorityOctets.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aHighPriorityOctetsReceived.')
if mibBuilder.loadTexts: icfVgPortHighPriorityOctets.setStatus('current')
if mibBuilder.loadTexts: icfVgPortHighPriorityOctets.setDescription('This object is a count of the number of octets contained in high priority frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which is counted by icfVgPortHighPriorityFrames. Note that this counter will roll over very quickly. It is provided for backward compatibility for Network Management protocols that do not support 64 bit counters (e.g. SNMP version 1).')
icfVgPortBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortBroadcastFrames.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aBroadcastFramesReceived.')
if mibBuilder.loadTexts: icfVgPortBroadcastFrames.setStatus('current')
if mibBuilder.loadTexts: icfVgPortBroadcastFrames.setDescription('This object is a count of broadcast packets that have been received on this port. This counter is incremented by one for each readable frame received on this port whose destination MAC address is the broadcast address. Frames counted by this counter are also counted by icfVgPortReadableFrames.')
icfVgPortMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortMulticastFrames.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aMulticastFramesReceived.')
if mibBuilder.loadTexts: icfVgPortMulticastFrames.setStatus('current')
if mibBuilder.loadTexts: icfVgPortMulticastFrames.setDescription('This object is a count of multicast packets that have been received on this port. This counter is incremented by one for each readable frame received on this port whose destination MAC address has the group address bit set, but is not the broadcast address. Frames counted by this counter are also counted by icfVgPortReadableFrames, but not by icfVgPortBroadcastFrames')
icfVgPortIPMFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortIPMFrames.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aIPMFramesReceived.')
if mibBuilder.loadTexts: icfVgPortIPMFrames.setStatus('current')
if mibBuilder.loadTexts: icfVgPortIPMFrames.setDescription('This object is a count of the number of frames that have been received on this port with an invalid packet marker and no PMI errors. A repeater will write an invalid packet marker to the end of a frame containing errors as it is forwarded through the repeater to the other ports. This counter is incremented by one for each frame received on this port which has had an invalid packet marker added to the end of the frame. This counter indicates problems with remote cable segments, as opposed to problems with cables directly attached to this repeater.')
icfVgPortDataErrorFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortDataErrorFrames.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aDataErrorFramesReceived.')
if mibBuilder.loadTexts: icfVgPortDataErrorFrames.setStatus('current')
if mibBuilder.loadTexts: icfVgPortDataErrorFrames.setDescription('This object is a count of errored frames received on this port. This counter is incremented by one for each frame received on this port with any of the following errors: bad FCS (with no IPM), PMI errors (excluding frames with an IPM error as the only PMI error), or undersize (with no IPM). Does not include packets counted by icfVgPortIPMFrames, icfVgPortOversizeFrames, or icfVgPortNullAddressedFrames. This counter indicates problems with the cable directly attached to this repeater, while icfVgPortIPMFrames indicates problems with remote cables attached to other repeaters.')
icfVgPortPriorityPromotions = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortPriorityPromotions.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aPriorityPromotions.')
if mibBuilder.loadTexts: icfVgPortPriorityPromotions.setStatus('current')
if mibBuilder.loadTexts: icfVgPortPriorityPromotions.setDescription('This counter is incremented by one each time the priority promotion timer has expired on this port and a normal priority frame was priority promoted.')
icfVgPortHCReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortHCReadableOctets.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aReadableOctetsReceived.')
if mibBuilder.loadTexts: icfVgPortHCReadableOctets.setStatus('current')
if mibBuilder.loadTexts: icfVgPortHCReadableOctets.setDescription('This object is a count of the number of octets contained in good frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which has been determined to be a readable frame (i.e. each frame counted by icfVgPortReadableFrames). This counter is a 64 bit version of icfVgPortReadableOctets. It should be used by Network Management protocols which support 64 bit counters (e.g. SNMPv2).')
icfVgPortHCUnreadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortHCUnreadableOctets.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aOctetsInUnreadableFramesRcvd.')
if mibBuilder.loadTexts: icfVgPortHCUnreadableOctets.setStatus('current')
if mibBuilder.loadTexts: icfVgPortHCUnreadableOctets.setDescription('This object is a count of the number of octets contained in invalid frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which is counted by icfVgPortIPMFrames or icfVgPortDataErrorFrames. This counter can be combined with icfVgPortHCReadableOctets to calculate network utilization. This counter is a 64 bit version of icfVgPortUnReadableOctets. It should be used by Network Management protocols which support 64 bit counters (e.g. SNMPv2).')
icfVgPortHCHighPriorityOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortHCHighPriorityOctets.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aHighPriorityOctetsReceived.')
if mibBuilder.loadTexts: icfVgPortHCHighPriorityOctets.setStatus('current')
if mibBuilder.loadTexts: icfVgPortHCHighPriorityOctets.setDescription('This object is a count of the number of octets contained in high priority frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which is counted by icfVgPortHighPriorityFrames. This counter is a 64 bit version of icfVgPortHighPriorityOctets. It should be used by Network Management protocols which support 64 bit counters (e.g. SNMPv2).')
icfVgPortHCNormPriorityOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortHCNormPriorityOctets.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aNormalPriorityOctetsReceived.')
if mibBuilder.loadTexts: icfVgPortHCNormPriorityOctets.setStatus('current')
if mibBuilder.loadTexts: icfVgPortHCNormPriorityOctets.setDescription('This object is a count of the number of octets contained in normal priority frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which is counted by icfVgPortNormPriorityFrames. This counter is a 64 bit version of icfVgPortNormPriorityOctets. It should be used by Network Management protocols which support 64 bit counters (e.g. SNMPv2).')
icfVgPortNormPriorityFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortNormPriorityFrames.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aNormalPriorityFramesReceived.')
if mibBuilder.loadTexts: icfVgPortNormPriorityFrames.setStatus('current')
if mibBuilder.loadTexts: icfVgPortNormPriorityFrames.setDescription('This object is a count of normal priority frames that have been received on this port. This counter is incremented by one for each normal priority frame received on this port. This counter includes both good and bad normal priority frames, as well as normal priority training frames and normal priority frames which were priority promoted.')
icfVgPortNormPriorityOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortNormPriorityOctets.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aNormalPriorityOctetsReceived.')
if mibBuilder.loadTexts: icfVgPortNormPriorityOctets.setStatus('current')
if mibBuilder.loadTexts: icfVgPortNormPriorityOctets.setDescription('This object is a count of the number of octets contained in normal priority frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which is counted by icfVgPortNormPriorityFrames. Note that this counter will roll over very quickly. It is provided for backward compatibility for Network Management protocols that do not support 64 bit counters (e.g. SNMP version 1).')
icfVgPortNullAddressedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortNullAddressedFrames.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aNullAddressedFramesReceived.')
if mibBuilder.loadTexts: icfVgPortNullAddressedFrames.setStatus('current')
if mibBuilder.loadTexts: icfVgPortNullAddressedFrames.setDescription('This object is a count of null addressed packets that have been received on this port. This counter is incremented by one for each frame received on this port with a destination MAC address consisting of all zero bits. Both void and training frames are included in this counter.')
icfVgPortOversizeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortOversizeFrames.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aOversizeFramesReceived.')
if mibBuilder.loadTexts: icfVgPortOversizeFrames.setStatus('current')
if mibBuilder.loadTexts: icfVgPortOversizeFrames.setDescription('This object is a count of oversize frames received on this port. This counter is incremented by one for each frame received on this port whose OctetCount is larger than the maximum legal frame size. The frame size which causes this counter to increment is dependent on the current value of icfVgCurrentFramingType. When icfVgCurrentFramingType is equal to frameType88023 this counter will increment for frames that are 1519 octets or larger. When icfVgCurrentFramingType is equal to frameType88025 this counter will increment for frames that are 4521 octets or larger.')
icfVgPortTransitionToTrainings = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 2, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgPortTransitionToTrainings.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aTransitionsIntoTraining.')
if mibBuilder.loadTexts: icfVgPortTransitionToTrainings.setStatus('current')
if mibBuilder.loadTexts: icfVgPortTransitionToTrainings.setDescription("This counter is incremented by one each time the icfVgPortStatus object for this port transitions into the 'training' state.")
icfVgAddrTrack = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3))
icfVgAddrTrackRptr = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 1))
icfVgAddrTrackGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 2))
icfVgAddrTrackPort = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 3))
icfVgAddrTrackTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 3, 1), )
if mibBuilder.loadTexts: icfVgAddrTrackTable.setStatus('current')
if mibBuilder.loadTexts: icfVgAddrTrackTable.setDescription('Table of address mapping information about the ports.')
icfVgAddrTrackEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 3, 1, 1), ).setIndexNames((0, "ICF-VG-RPTR", "icfVgPortGroupIndex"), (0, "ICF-VG-RPTR", "icfVgPortIndex"))
if mibBuilder.loadTexts: icfVgAddrTrackEntry.setStatus('current')
if mibBuilder.loadTexts: icfVgAddrTrackEntry.setDescription('An entry in the table, containing address mapping information about a single port.')
icfVgAddrLastTrainedAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 3, 1, 1, 1), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(6, 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgAddrLastTrainedAddress.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aLastTrainedAddress.')
if mibBuilder.loadTexts: icfVgAddrLastTrainedAddress.setStatus('current')
if mibBuilder.loadTexts: icfVgAddrLastTrainedAddress.setDescription('This object is the MAC address of the last station which succeeded in training on this port. A cascaded repeater may train using the null address. If no stations have succeeded in training on this port since the agent began monitoring the port activity, the agent shall return a string of length zero.')
icfVgAddrTrainedAddrChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgAddrTrainedAddrChanges.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aTrainedAddressChanges.')
if mibBuilder.loadTexts: icfVgAddrTrainedAddrChanges.setStatus('current')
if mibBuilder.loadTexts: icfVgAddrTrainedAddrChanges.setDescription('This counter is incremented by one for each time that the icfVgAddrLastTrainedAddress object for this port has changed.')
icfVgRptrDetectedDupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 3, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icfVgRptrDetectedDupAddress.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aLocalRptrDetectedDupAddr.')
if mibBuilder.loadTexts: icfVgRptrDetectedDupAddress.setStatus('current')
if mibBuilder.loadTexts: icfVgRptrDetectedDupAddress.setDescription("This object is used to indicate that the repeater detected an error-free training frame on this port with a source MAC address which matches the value of icfVgAddrLastTrainedAddress of another active port. This is reset to 'false' when an error-free training frame is received with a source MAC address which does not match icfVgAddrLastTrainedAddress of another port which is active. For the cascade port, this object will be 'true' if the 'D' bit in the most recently received error-free training response frame was set.")
icfVgMgrDetectedDupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 3, 3, 1, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: icfVgMgrDetectedDupAddress.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.5.1, aCentralMgmtDetectedDupAddr.')
if mibBuilder.loadTexts: icfVgMgrDetectedDupAddress.setStatus('current')
if mibBuilder.loadTexts: icfVgMgrDetectedDupAddress.setDescription("This object can be set by a management station when it detects that there is a duplicate MAC address. This object is OR'd with icfVgRptrDetectedDupAddress to form the value of the 'D' bit in training response frames on this port. The purpose of this object is to provide a means for network management software to inform an end station that it is using a duplicate station address. Setting this object does not affect the current state of the link; the end station will not be informed of the duplicate address until it retrains for some reason. Note that regardless of its station address, the end station will not be able to train successfully until the network management software has set this object back to 'false'. Although this object exists on cascade ports, it does not perform any function since this repeater is the initiator of training on a cascade port.")
icfVgRptrTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 4))
icfVgRptrTrapsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 4, 0))
icfVgRptrHealth = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 4, 0, 1)).setObjects(("ICF-VG-RPTR", "icfVgRepeaterHealthState"))
if mibBuilder.loadTexts: icfVgRptrHealth.setStatus('current')
if mibBuilder.loadTexts: icfVgRptrHealth.setDescription("A icfVgRptrHealth trap conveys information related to the operational state of the repeater. This trap is sent either when the value of icfVgRepeaterHealthState changes, or upon completion of a non-disruptive test. The icfVgRptrHealth trap is not sent as a result of powering up a repeater. The icfVgRptrHealth trap must contain the icfVgRepeaterHealthState object. The agent may optionally include the icfVgRepeaterHealthText object in the varBind list. See the icfVgRepeaterHealthState and icfVgRepeaterHealthText objects for descriptions of the information that is sent. The agent must throttle the generation of consecutive icfVgRptrHealth traps so that there is at least a five-second gap between traps of this type. When traps are throttled, they are dropped, not queued for sending at a future time. (Note that 'generating' a trap means sending to all configured recipients.)")
if mibBuilder.loadTexts: icfVgRptrHealth.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.2.3, nRepeaterHealth.')
icfVgRptrResetEvent = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 8, 1, 4, 0, 3)).setObjects(("ICF-VG-RPTR", "icfVgRepeaterHealthState"))
if mibBuilder.loadTexts: icfVgRptrResetEvent.setStatus('current')
if mibBuilder.loadTexts: icfVgRptrResetEvent.setDescription("An icfVgRptrResetEvent trap conveys information related to the operational state of the repeater. This trap is sent on completion of a repeater reset action. A repeater reset action is defined as a transition to its initial state as specified in clause 12 [IEEE Draft Std 802.12] when triggered by a management command. The icfVgRptrResetEvent trap is not sent when the agent restarts and sends an SNMP coldStart or warmStart trap. However, it is recommended that an 802.12 repeater agent send the icfVgRepeaterHealthState object as an optional object with its coldStart and warmStart trap PDUs. The icfVgRptrResetEvent trap must contain the icfVgRepeaterHealthState object. The agent may optionally include the icfVgRepeaterHealthText object in the varBind list. See the icfVgRepeaterHealthState and icfVgRepeaterHealthText objects for descriptions of the information that is sent. The agent must throttle the generation of consecutive icfVgRptrResetEvent traps so that there is at least a five-second gap between traps of this type. When traps are throttled, they are dropped, not queued for sending at a future time. (Note that 'generating' a trap means sending to all configured recipients.)")
if mibBuilder.loadTexts: icfVgRptrResetEvent.setReference('IEEE Draft Std. 802.12, Draft 6, 23 November, 1994, 13.2.4.2.3, nRepeaterReset.')
icfVgRepeaterConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 10, 1))
icfVgRepeaterCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 10, 1, 1))
icfVgRepeaterGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 10, 1, 2))
icfVgRptrPreStdCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 10, 1, 1, 1)).setObjects(("ICF-VG-RPTR", "icfVgRptrBasicGroup"), ("ICF-VG-RPTR", "icfVgRptrPreStdMonitorGroup"), ("ICF-VG-RPTR", "icfVgRptrPreStdAddrTrackGroup"), ("ICF-VG-RPTR", "icfVgRptrNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    icfVgRptrPreStdCompliance = icfVgRptrPreStdCompliance.setStatus('obsolete')
if mibBuilder.loadTexts: icfVgRptrPreStdCompliance.setDescription('********* THIS COMPLIANCE IS OBSOLETE ********* The compliance statement for pre-standard 802.12 repeater management.')
icfVgRptrCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 10, 1, 1, 2)).setObjects(("ICF-VG-RPTR", "icfVgRptrBasicGroup"), ("ICF-VG-RPTR", "icfVgRptrMonitorGroup"), ("ICF-VG-RPTR", "icfVgRptrAddrTrackGroup"), ("ICF-VG-RPTR", "icfVgRptrNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    icfVgRptrCompliance = icfVgRptrCompliance.setStatus('current')
if mibBuilder.loadTexts: icfVgRptrCompliance.setDescription('The compliance statement for 802.12 repeater management.')
icfVgRptrBasicGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 10, 1, 2, 1)).setObjects(("ICF-VG-RPTR", "icfVgMACAddress"), ("ICF-VG-RPTR", "icfVgCurrentFramingType"), ("ICF-VG-RPTR", "icfVgDesiredFramingType"), ("ICF-VG-RPTR", "icfVgFramingCapability"), ("ICF-VG-RPTR", "icfVgTrainingVersion"), ("ICF-VG-RPTR", "icfVgRepeaterGroupCapacity"), ("ICF-VG-RPTR", "icfVgRepeaterHealthState"), ("ICF-VG-RPTR", "icfVgRepeaterHealthText"), ("ICF-VG-RPTR", "icfVgRepeaterReset"), ("ICF-VG-RPTR", "icfVgRepeaterNonDisruptTest"), ("ICF-VG-RPTR", "icfVgGroupDescr"), ("ICF-VG-RPTR", "icfVgGroupObjectID"), ("ICF-VG-RPTR", "icfVgGroupOperStatus"), ("ICF-VG-RPTR", "icfVgGroupLastOperStatusChange"), ("ICF-VG-RPTR", "icfVgGroupPortCapacity"), ("ICF-VG-RPTR", "icfVgGroupCablesBundled"), ("ICF-VG-RPTR", "icfVgPortType"), ("ICF-VG-RPTR", "icfVgPortAdminStatus"), ("ICF-VG-RPTR", "icfVgPortStatus"), ("ICF-VG-RPTR", "icfVgPortSupportedPromiscMode"), ("ICF-VG-RPTR", "icfVgPortSupportedCascadeMode"), ("ICF-VG-RPTR", "icfVgPortAllowedTrainType"), ("ICF-VG-RPTR", "icfVgPortLastTrainConfig"), ("ICF-VG-RPTR", "icfVgPortTrainingResult"), ("ICF-VG-RPTR", "icfVgPortPriorityEnable"), ("ICF-VG-RPTR", "icfVgPortMediaType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    icfVgRptrBasicGroup = icfVgRptrBasicGroup.setStatus('current')
if mibBuilder.loadTexts: icfVgRptrBasicGroup.setDescription('A collection of objects for managing the status and configuration of IEEE 802.12 repeaters.')
icfVgRptrPreStdMonitorGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 10, 1, 2, 2)).setObjects(("ICF-VG-RPTR", "icfVgPortReadableFrames"), ("ICF-VG-RPTR", "icfVgPortReadableOctets"), ("ICF-VG-RPTR", "icfVgPortUnreadableOctets"), ("ICF-VG-RPTR", "icfVgPortHighPriorityFrames"), ("ICF-VG-RPTR", "icfVgPortHighPriorityOctets"), ("ICF-VG-RPTR", "icfVgPortBroadcastFrames"), ("ICF-VG-RPTR", "icfVgPortMulticastFrames"), ("ICF-VG-RPTR", "icfVgPortIPMFrames"), ("ICF-VG-RPTR", "icfVgPortDataErrorFrames"), ("ICF-VG-RPTR", "icfVgPortPriorityPromotions"), ("ICF-VG-RPTR", "icfVgPortHCReadableOctets"), ("ICF-VG-RPTR", "icfVgPortHCUnreadableOctets"), ("ICF-VG-RPTR", "icfVgPortHCHighPriorityOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    icfVgRptrPreStdMonitorGroup = icfVgRptrPreStdMonitorGroup.setStatus('obsolete')
if mibBuilder.loadTexts: icfVgRptrPreStdMonitorGroup.setDescription('********* THIS GROUP IS OBSOLETE ********* A collection of objects for providing statistics for pre-standard IEEE 802.12 repeaters.')
icfVgRptrPreStdAddrTrackGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 10, 1, 2, 3)).setObjects(("ICF-VG-RPTR", "icfVgAddrLastTrainedAddress"), ("ICF-VG-RPTR", "icfVgAddrTrainedAddrChanges"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    icfVgRptrPreStdAddrTrackGroup = icfVgRptrPreStdAddrTrackGroup.setStatus('obsolete')
if mibBuilder.loadTexts: icfVgRptrPreStdAddrTrackGroup.setDescription('********* THIS GROUP IS OBSOLETE ********* A collection of objects for tracking addresses on pre-standard IEEE 802.12 repeaters.')
icfVgRptrMonitorGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 10, 1, 2, 4)).setObjects(("ICF-VG-RPTR", "icfVgPortReadableFrames"), ("ICF-VG-RPTR", "icfVgPortReadableOctets"), ("ICF-VG-RPTR", "icfVgPortUnreadableOctets"), ("ICF-VG-RPTR", "icfVgPortHighPriorityFrames"), ("ICF-VG-RPTR", "icfVgPortHighPriorityOctets"), ("ICF-VG-RPTR", "icfVgPortBroadcastFrames"), ("ICF-VG-RPTR", "icfVgPortMulticastFrames"), ("ICF-VG-RPTR", "icfVgPortIPMFrames"), ("ICF-VG-RPTR", "icfVgPortDataErrorFrames"), ("ICF-VG-RPTR", "icfVgPortPriorityPromotions"), ("ICF-VG-RPTR", "icfVgPortHCReadableOctets"), ("ICF-VG-RPTR", "icfVgPortHCUnreadableOctets"), ("ICF-VG-RPTR", "icfVgPortHCHighPriorityOctets"), ("ICF-VG-RPTR", "icfVgPortHCNormPriorityOctets"), ("ICF-VG-RPTR", "icfVgPortNormPriorityFrames"), ("ICF-VG-RPTR", "icfVgPortNormPriorityOctets"), ("ICF-VG-RPTR", "icfVgPortNullAddressedFrames"), ("ICF-VG-RPTR", "icfVgPortOversizeFrames"), ("ICF-VG-RPTR", "icfVgPortTransitionToTrainings"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    icfVgRptrMonitorGroup = icfVgRptrMonitorGroup.setStatus('current')
if mibBuilder.loadTexts: icfVgRptrMonitorGroup.setDescription('A collection of objects for providing statistics for IEEE 802.12 repeaters.')
icfVgRptrAddrTrackGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 10, 1, 2, 5)).setObjects(("ICF-VG-RPTR", "icfVgAddrLastTrainedAddress"), ("ICF-VG-RPTR", "icfVgAddrTrainedAddrChanges"), ("ICF-VG-RPTR", "icfVgRptrDetectedDupAddress"), ("ICF-VG-RPTR", "icfVgMgrDetectedDupAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    icfVgRptrAddrTrackGroup = icfVgRptrAddrTrackGroup.setStatus('current')
if mibBuilder.loadTexts: icfVgRptrAddrTrackGroup.setDescription('A collection of objects for tracking addresses on IEEE 802.12 repeaters.')
icfVgRptrNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 10, 1, 2, 6)).setObjects(("ICF-VG-RPTR", "icfVgRptrHealth"), ("ICF-VG-RPTR", "icfVgRptrResetEvent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    icfVgRptrNotificationsGroup = icfVgRptrNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: icfVgRptrNotificationsGroup.setDescription('A collection of notifications used to indicate 802.12 repeater general status changes.')
mibBuilder.exportSymbols("ICF-VG-RPTR", icfVgPortNormPriorityFrames=icfVgPortNormPriorityFrames, icfVgRepeaterHealthText=icfVgRepeaterHealthText, icfVgRepeaterHealthState=icfVgRepeaterHealthState, icfVgRptrCompliance=icfVgRptrCompliance, icfVgPortHCReadableOctets=icfVgPortHCReadableOctets, icfVgRptrHealth=icfVgRptrHealth, icfVgPortNullAddressedFrames=icfVgPortNullAddressedFrames, icfVgRptrTrapsPrefix=icfVgRptrTrapsPrefix, icfVgPortIndex=icfVgPortIndex, icfVgPortMediaType=icfVgPortMediaType, icfVgPortReadableFrames=icfVgPortReadableFrames, icfVgRepeaterCompliances=icfVgRepeaterCompliances, icfVgPortType=icfVgPortType, icfVgPortMulticastFrames=icfVgPortMulticastFrames, icfVgPortUnreadableOctets=icfVgPortUnreadableOctets, icfVgRptrAddrTrackGroup=icfVgRptrAddrTrackGroup, icfVgRepeaterNonDisruptTest=icfVgRepeaterNonDisruptTest, icfVgRptrTraps=icfVgRptrTraps, icfVgGroupCablesBundled=icfVgGroupCablesBundled, icfVgPortTrainingResult=icfVgPortTrainingResult, icfVgPortGroupIndex=icfVgPortGroupIndex, icfVgPortSupportedCascadeMode=icfVgPortSupportedCascadeMode, icfVgBasic=icfVgBasic, icfVgAddrTrackRptr=icfVgAddrTrackRptr, icfVgFramingCapability=icfVgFramingCapability, icfVgBasicRptr=icfVgBasicRptr, icfVgPortAdminStatus=icfVgPortAdminStatus, icfVgMonPortTable=icfVgMonPortTable, icfVgPortPriorityPromotions=icfVgPortPriorityPromotions, icfVgBasicPort=icfVgBasicPort, icfVgRptrBasicGroup=icfVgRptrBasicGroup, icfVgRepeaterGroupCapacity=icfVgRepeaterGroupCapacity, icfVgBasicGroup=icfVgBasicGroup, icfVgMonitor=icfVgMonitor, icfVgRepeaterConformance=icfVgRepeaterConformance, icfVgCurrentFramingType=icfVgCurrentFramingType, icfVgAddrTrackGroup=icfVgAddrTrackGroup, icfVgGroupOperStatus=icfVgGroupOperStatus, icfVgGroupObjectID=icfVgGroupObjectID, icfVgAddrTrackPort=icfVgAddrTrackPort, icfVgMonRptr=icfVgMonRptr, icfVgRptrPreStdMonitorGroup=icfVgRptrPreStdMonitorGroup, icfVgTrainingVersion=icfVgTrainingVersion, icfVgRepeaterGroups=icfVgRepeaterGroups, icfVgBasicPortTable=icfVgBasicPortTable, icfVgAddrTrackEntry=icfVgAddrTrackEntry, icfVgPortReadableOctets=icfVgPortReadableOctets, icfVgPortHCNormPriorityOctets=icfVgPortHCNormPriorityOctets, icfVgRepeaterMib=icfVgRepeaterMib, icfVgRptrPreStdAddrTrackGroup=icfVgRptrPreStdAddrTrackGroup, PYSNMP_MODULE_ID=icfVgRepeaterMib, icfVgGroupLastOperStatusChange=icfVgGroupLastOperStatusChange, icfVgRptrMonitorGroup=icfVgRptrMonitorGroup, icfVgPortBroadcastFrames=icfVgPortBroadcastFrames, icfVgMonPortEntry=icfVgMonPortEntry, icfVgPortDataErrorFrames=icfVgPortDataErrorFrames, icfVgRptrResetEvent=icfVgRptrResetEvent, icfVgPortOversizeFrames=icfVgPortOversizeFrames, icfVgPortHighPriorityOctets=icfVgPortHighPriorityOctets, icfVgRptrNotificationsGroup=icfVgRptrNotificationsGroup, icfVgPortSupportedPromiscMode=icfVgPortSupportedPromiscMode, icfVgBasicGroupEntry=icfVgBasicGroupEntry, icfVgGroupIndex=icfVgGroupIndex, icfVgAddrTrackTable=icfVgAddrTrackTable, icfVgMgrDetectedDupAddress=icfVgMgrDetectedDupAddress, icfVgAddrLastTrainedAddress=icfVgAddrLastTrainedAddress, icfVgMACAddress=icfVgMACAddress, icfVgPortPriorityEnable=icfVgPortPriorityEnable, icfVgBasicPortEntry=icfVgBasicPortEntry, icfVgMonGroup=icfVgMonGroup, icfVgGroupDescr=icfVgGroupDescr, icfVgPortNormPriorityOctets=icfVgPortNormPriorityOctets, icfVgPortStatus=icfVgPortStatus, icfVgPortHCUnreadableOctets=icfVgPortHCUnreadableOctets, icfVgPortLastTrainConfig=icfVgPortLastTrainConfig, icfVgPortIPMFrames=icfVgPortIPMFrames, icfVgPortHighPriorityFrames=icfVgPortHighPriorityFrames, icfVgPortAllowedTrainType=icfVgPortAllowedTrainType, icfVgRptrPreStdCompliance=icfVgRptrPreStdCompliance, icfVgAddrTrainedAddrChanges=icfVgAddrTrainedAddrChanges, icfVgRptrDetectedDupAddress=icfVgRptrDetectedDupAddress, icfVgPortHCHighPriorityOctets=icfVgPortHCHighPriorityOctets, icfVgRepeaterReset=icfVgRepeaterReset, icfVgGroupPortCapacity=icfVgGroupPortCapacity, icfVgAddrTrack=icfVgAddrTrack, icfVgDesiredFramingType=icfVgDesiredFramingType, icfVgPortTransitionToTrainings=icfVgPortTransitionToTrainings, icfVgMonPort=icfVgMonPort, icfVgBasicGroupTable=icfVgBasicGroupTable)

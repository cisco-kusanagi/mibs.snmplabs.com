#
# PySNMP MIB module A3Com-IPX-r5-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/A3COM-IPX-R5-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:08:04 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
MacAddress, = mibBuilder.importSymbols("RFC1286-MIB", "MacAddress")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, iso, ModuleIdentity, Counter64, Bits, MibIdentifier, Gauge32, NotificationType, Integer32, ObjectIdentity, Counter32, enterprises, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "iso", "ModuleIdentity", "Counter64", "Bits", "MibIdentifier", "Gauge32", "NotificationType", "Integer32", "ObjectIdentity", "Counter32", "enterprises", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "IpAddress")
DisplayString, PhysAddress, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "PhysAddress", "TextualConvention")
a3Com = MibIdentifier((1, 3, 6, 1, 4, 1, 43))
brouterMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2))
a3ComIPX = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 7))
class SMDSAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class RowStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))

a3ipxGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 7, 1))
a3ipxControl = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 7))
class IPXNET(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

a3ipxRouteControl = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRouteControl.setStatus('deprecated')
if mibBuilder.loadTexts: a3ipxRouteControl.setDescription('If this object is set to enabled(1), then IPX routing is enabled. If this object is set to disabled(2), then IPX routing is disabled. Note, if this is disabled(2), then RIP is disabled as well (for all Ports). If this is set to disabled(2), then all dynamic routing entries will be removed. All entries in the server table will be removed as well. NOTE: for NETBuilders running sw version 8.0 and greater, this object is no longer supported. a3ipxControlTable has replaced its functionality.')
a3ipxWanBcastControl = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxWanBcastControl.setStatus('deprecated')
if mibBuilder.loadTexts: a3ipxWanBcastControl.setDescription('If this object is enabled(1), then the IPX router makes copies of all received WAN broadcast packets and forwards them to all ports other than the one on which that packet was received. NOTE: for NETBuilders running sw version 8.0 and greater, this object is no longer supported. a3ipxControlTable has replaced its functionality.')
a3ipxUpdateTime = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 65535)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxUpdateTime.setStatus('deprecated')
if mibBuilder.loadTexts: a3ipxUpdateTime.setDescription('This parameter specifies how often the router sends both RIP and SAP regular updates to exhange routing and service information. This parameter is defined in units of seconds. NOTE: for NETBuilders running sw version 8.0 and greater, this object is no longer supported. a3ipxRipUpdateTime and a3ipxSapUpdateTime have replaced its functionality.')
a3ipxFlushRipSap = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("rip", 2), ("sap", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxFlushRipSap.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxFlushRipSap.setDescription('This object is used to remove dynamic routing and or sap entries quickly and efficiently. Setting this object to rip (2) causes all dynamically entered routes to be removed from a3ipxRouteTable. If this object is set to sap (3), all dynamicaly learned sap entries will be removed from a3ipxServerTable. If this object is set to both (4), all dynamic entries will be removed from both the routing table (a3ipxRouteTable) and the sap table (a3ipxServerTable). If a GET REQUEST is received for this object, other (1) will be returned. Setting this object to other (1) will have no effect on any routing or sap entries.')
a3ipxInternalNet = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 5), IPXNET()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxInternalNet.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxInternalNet.setDescription("This object represents the router's internal network number. This is used during IPX WAN negotiation and is the basis on which the MASTER/SLAVE selection is made. The router with the lowest internal network number becomes the SLAVE of the link.")
a3ipxRouterName = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRouterName.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRouterName.setDescription("This object specifies the router's symbolic name and is used during IPX WAN negotiations to build RIP/SAP Information Request/Response packets.")
a3ipxControlTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 7, 1), )
if mibBuilder.loadTexts: a3ipxControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxControlTable.setDescription('A list of port-specific IPX control parmeters. This table is used currently to control ipx routing, WAN broadcasts, and WAN checksums.')
a3ipxControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 7, 1, 1), ).setIndexNames((0, "A3Com-IPX-r5-MIB", "a3ipxControlPort"))
if mibBuilder.loadTexts: a3ipxControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxControlEntry.setDescription('Each entry in this table applies control over a seperate port.')
a3ipxControlPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxControlPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxControlPort.setDescription('The IPX port to which this entry applies.')
a3ipxControlRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxControlRoute.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxControlRoute.setDescription('If this object is set to enabled(1), then IPX routing is enabled. If this object is set to disabled(2), then IPX routing is disabled. Note, if this is disabled(2), then RIP is disabled as well (for this Port). If this is set to disabled(2), then all dynamic routing entries will be removed. All entries in the server table will be removed as well.')
a3ipxControlWanBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxControlWanBcast.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxControlWanBcast.setDescription('If this object is enabled(1), then the IPX router makes copies of all received WAN broadcast packets and forwards them to all ports other than the one on which that packet was received.')
a3ipxControlChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxControlChecksum.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxControlChecksum.setDescription('If this object is set to enabled(1), Checksum will be generated and checked on IPX packet over WAN.')
a3ipxControlWanOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wan", 1), ("noWan", 2))).clone('noWan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxControlWanOpt.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxControlWanOpt.setDescription('This object is used to enable or disable the IPX WAN feature on a specific port. IPX WAN is the protocol Novell IPX uses to exchange necessary router to router information prior to exchanging IPX RIP and SAP information over various WAN links. If this object has the value wan(1), the feature is enabled. Otherwise it is disabled. This object applies only to WAN ports. For software release 7.0, only ports supporting PPP offer this feature.')
a3ipxRipControlTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 7, 2), )
if mibBuilder.loadTexts: a3ipxRipControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRipControlTable.setDescription('A list of RIP Control parameter entries')
a3ipxRipControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 7, 2, 1), ).setIndexNames((0, "A3Com-IPX-r5-MIB", "a3ipxRipControlPort"))
if mibBuilder.loadTexts: a3ipxRipControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRipControlEntry.setDescription('A list of parameters that determin how IPX updates its routing table.')
a3ipxRipControlPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxRipControlPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRipControlPort.setDescription('The IPX port to which this entry applies.')
a3ipxRipControlSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRipControlSwitch.setStatus('deprecated')
if mibBuilder.loadTexts: a3ipxRipControlSwitch.setDescription("If this object is set to enabled(1), IPX RIP exchanges RIP information with its neighbors and maintains the routing table dynamically. If this object is set to disabled(2), dynamic learning is stopped and no RIP updates are generated. NOTE: this object is no longer supported by NETBuilders running sw version 8.0 and greater. The objects a3ipxRipControlTalk, a3ipxRipControlListen, a3ipxSapControlTalk, and a3ipxSapControlListen have replaced this object's functionality.")
a3ipxRipControlTrigger = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRipControlTrigger.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRipControlTrigger.setDescription('If this object is set to enabled(1), triggered responses are sent when the network topology changes, allowing the network to calculate potentially better routes. If this object is disabled(2), topology change responses are not sent immediately, but are included in the regular updates.')
a3ipxRipControlPoison = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRipControlPoison.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRipControlPoison.setDescription('If this object is set to enabled(1), Split Horizon with Poison Reverse is performed. If this object is set to disabled(2), the router omits routes learned from one neighbor in regular updates sent to that neighbor.')
a3ipxRipControlMapOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("oldNbrMap", 1), ("newNbrMap", 2))).clone('newNbrMap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRipControlMapOpt.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRipControlMapOpt.setDescription('X.25 addresses and Frame Relay DLCIs can be mapped in two different ways: by using IPX network numbers as previously implemented (OldNbrMap) or by using the Ethernet address of the remote NETBuilder currently implemented (NewNbrMap). This option is set to NewNbrMap by default, but OldNbrMap should be selected to interoperate with a neighbor running earlier than 5.0 bridge/router software.')
a3ipxRipControlWanOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wan", 1), ("noWan", 2))).clone('noWan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRipControlWanOpt.setStatus('deprecated')
if mibBuilder.loadTexts: a3ipxRipControlWanOpt.setDescription('This object is used to enable or disable the IPX WAN feature on a specific port. IPX WAN is the protocol Novell IPX uses to exchange necessary router to router information prior to exchanging IPX RIP and SAP information over various WAN links. If this object has the value wan(1), the feature is enabled. Otherwise it is disabled. This object applies only to WAN ports. For software release 7.0, only ports supporting PPP offer this feature.')
a3ipxRipControlPerRip = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("periodicRip", 1), ("nonPeriodicRip", 2))).clone('periodicRip')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRipControlPerRip.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRipControlPerRip.setDescription('This object is used to specify how this router generates IPX RIP updates. If this object is set to periodicRip(1), the router will generate RIP updates periodically. If this object is set to nonPeriodicRip(2), the router will generate incremental updates. When selecting this option, make sure that all participating routers use the same option.')
a3ipxRipControlPerSap = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("periodicSap", 1), ("nonPeriodicSap", 2))).clone('periodicSap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRipControlPerSap.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRipControlPerSap.setDescription('This object is used to specify how this router generates IPX SAP updates. If this object is set to periodicSap(1), the router will generate SAP updates periodically. If this object is set to nonPeriodicSap(2), the router will generate incremental updates. When selecting this option, make sure that all participating routers use the same option.')
a3ipxRipControlTalk = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRipControlTalk.setStatus('deprecated')
if mibBuilder.loadTexts: a3ipxRipControlTalk.setDescription('This object controls the transmission of IPX RIP updates on this port. If enabled, IPX RIP updates are sent. If disabled, they are not sent.')
a3ipxRipControlListen = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRipControlListen.setStatus('deprecated')
if mibBuilder.loadTexts: a3ipxRipControlListen.setDescription('This object determines if IPX RIP updates are accepted over this port. If this object is enabled(1), then the IPX router listens to the incoming RIP updates. If this object is set to disabled(2), then the IPX router does not listen for IPX RIP updates.')
a3ipxSapControlTalk = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxSapControlTalk.setStatus('deprecated')
if mibBuilder.loadTexts: a3ipxSapControlTalk.setDescription('This object controls the transmission of IPX SAP updates on this port. If enabled, IPX SAP updates are sent. If disabled, they are not sent.')
a3ipxSapControlListen = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxSapControlListen.setStatus('deprecated')
if mibBuilder.loadTexts: a3ipxSapControlListen.setDescription('This object determines if IPX SAP updates are accepted over this port. If this object is enabled(1), then the IPX router listens to the incoming SAP updates. If this object is set to disabled(2), then the IPX router does not listen for IPX SAP updates.')
a3ipxRipCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("talkListen", 1), ("talkNoListen", 2), ("noTalkListen", 3), ("noTalkNoListen", 4), ("auto", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRipCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRipCtl.setDescription('')
a3ipxSapCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("talkListen", 1), ("talkNoListen", 2), ("noTalkListen", 3), ("noTalkNoListen", 4), ("auto", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxSapCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxSapCtl.setDescription('')
a3ipxWaAddrTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 7, 3), )
if mibBuilder.loadTexts: a3ipxWaAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxWaAddrTable.setDescription('A list of IPX entities reachable across a wide area network.')
a3ipxWaAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 7, 3, 1), ).setIndexNames((0, "A3Com-IPX-r5-MIB", "a3ipxWaAddrEthAddress"))
if mibBuilder.loadTexts: a3ipxWaAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxWaAddrEntry.setDescription('Each entry contains the WAN Address of an IPX entity. Each entry also contains the IPX port over which the entity can be reached.')
a3ipxWaAddrEthAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 3, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxWaAddrEthAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxWaAddrEthAddress.setDescription('The Ethernet address (IPX Node ID) of a remote IPX entity.')
a3ipxWaAddrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxWaAddrPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxWaAddrPort.setDescription('The IPX port through which the IPX entity identified by a3ipxWaAddrEthAddress can be reached.')
a3ipxWaAddrDLType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("x25", 1), ("frameRelay", 2), ("smds", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxWaAddrDLType.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxWaAddrDLType.setDescription('The type of address that is returned by a3ipxWaAddrDLAddress.')
a3ipxWaAddrDLAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 3, 1, 4), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxWaAddrDLAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxWaAddrDLAddress.setDescription('The WAN address that is used to reach the IPX entity corresponding to this table entry.')
a3ipxWaAddrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 3, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxWaAddrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxWaAddrStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB.')
a3ipxAttachedNetTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 7, 4), )
if mibBuilder.loadTexts: a3ipxAttachedNetTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxAttachedNetTable.setDescription('A list of the IPX Network Numbers attached to an IPX port.')
a3ipxAttachedNetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 7, 4, 1), ).setIndexNames((0, "A3Com-IPX-r5-MIB", "a3ipxAttachedNetNumber"))
if mibBuilder.loadTexts: a3ipxAttachedNetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxAttachedNetEntry.setDescription('Each entry specifies an IPX network number, assigns it to a port, and specifies the header format to be used when sending IPX packets to that network. On Ethernet ports, up to four different IPX Network Numbers may be specified, of which only one may be primary. On serial ports, only one IPX Network Number may be configured. The header format assigned to a serial port is irrelevant. The header format is determined, instead, by the owner of the port (X25, ppp, etc.) If an attached network number is removed, the server entries that are reachable through that network will be removed. All routing entries that are reachable through that network are removed as well.')
a3ipxAttachedNetNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 4, 1, 1), IPXNET()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxAttachedNetNumber.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxAttachedNetNumber.setDescription('The IPX Network Number associated with this table entry.')
a3ipxAttachedNetPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 4, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxAttachedNetPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxAttachedNetPort.setDescription('The port to which the IPX Network Number is assigned.')
a3ipxAttachedNetFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("ethernet", 1), ("ieee", 2), ("llc", 3), ("snap", 4), ("ppp", 5), ("x25", 6), ("fr", 7), ("smds", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxAttachedNetFormat.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxAttachedNetFormat.setDescription('The format of the header used on packets sent to the IPX Network Number associated with this table entry. This object can be set to 1, 2, 3, or 4 when adding an entry for a LAN interface. For WAN interfaces, this object must be set to 5, 6, 7, or 8.')
a3ipxAttachedNetType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxAttachedNetType.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxAttachedNetType.setDescription('When more than one IPX Network Number is assigned to a port, one must be labeled the primary number and the rest secondary.')
a3ipxAttachedNetOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxAttachedNetOperState.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxAttachedNetOperState.setDescription('This identifies the current operational state of an attached IPX network.')
a3ipxAttachedNetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 4, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxAttachedNetStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxAttachedNetStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB.')
a3ipxRouteTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 7, 5), )
if mibBuilder.loadTexts: a3ipxRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRouteTable.setDescription('A list of IPX routes')
a3ipxRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 7, 5, 1), ).setIndexNames((0, "A3Com-IPX-r5-MIB", "a3ipxRouteDestNet"), (0, "A3Com-IPX-r5-MIB", "a3ipxRouteType"))
if mibBuilder.loadTexts: a3ipxRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRouteEntry.setDescription('Each entry specifies an IPX route. The destination of the route is specified by a3ipxRouteDestNet. The next hop of the route is specified by a3ipxRouteAttachedNet and a3ipxRouteDLAddress. Note, IPX routing must be enabled before routes are exposed via this table.')
a3ipxRouteDestNet = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 5, 1, 1), IPXNET()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxRouteDestNet.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRouteDestNet.setDescription('The IPX network number of the destination network. The value 0xfffffffe is used to represent the default route.')
a3ipxRouteAttachedNet = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 5, 1, 2), IPXNET()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRouteAttachedNet.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRouteAttachedNet.setDescription('The network number of the directly connected network through which the router can reach the destination network.')
a3ipxRouteDLType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernet", 1), ("x25", 2), ("frameRelay", 3), ("smds", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxRouteDLType.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRouteDLType.setDescription('The type of network to which the closest router is attached. This value is determined by the value of a3ipxRouteAttachedNet.')
a3ipxRouteDLAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 5, 1, 4), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRouteDLAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRouteDLAddress.setDescription('The Data Link address of the next hop router through which the IPX network can be reached. The type of address is determined by the value of a3ipxRouteDLType.')
a3ipxRouteHops = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRouteHops.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRouteHops.setDescription('The number of gateways that a packet has to pass through before reaching the destination network. The maximum number of hops is 15.')
a3ipxRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxRouteType.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRouteType.setDescription('The IPX Router allows up to two routes (ie, two separate next hop routers) to a specific destination network, only one of which will be the primary route. The determination of which is primary and which is secondary is based on the speed of the physical port used to reach the next hop routers. If these are equal, the number of hops is used to make this determination. NOTE: NETBuilders running sw version 8.0 and greater will only display primary routes, and when routes are being added, only primary routes will be accepted.')
a3ipxRouteProto = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("static", 2), ("rip", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxRouteProto.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRouteProto.setDescription('This object specifies how the entry was made.')
a3ipxRouteDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 5, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRouteDelay.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRouteDelay.setDescription('The delay associated with the route.')
a3ipxRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 5, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRouteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRouteStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB. Note, only statically learned routes may be removed via this object. Dynamically learned routes may be removed via the object a3ipxFlushRipSap.')
a3ipxServerTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 7, 6), )
if mibBuilder.loadTexts: a3ipxServerTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxServerTable.setDescription('A list of servers reachable via this router')
a3ipxServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 7, 6, 1), ).setIndexNames((0, "A3Com-IPX-r5-MIB", "a3ipxServerName"), (0, "A3Com-IPX-r5-MIB", "a3ipxServerType"))
if mibBuilder.loadTexts: a3ipxServerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxServerEntry.setDescription('Each entry specifies the reachability of a server. The server name is specified by a3ipxServerName. The service is fully specified by a3ipxServerName, and a3ipxServerType.')
a3ipxServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 6, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 47))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxServerName.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxServerName.setDescription('The name of the server.')
a3ipxServerType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 6, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxServerType.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxServerType.setDescription('The type of service available on the server.')
a3ipxServerNet = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 6, 1, 3), IPXNET()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxServerNet.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxServerNet.setDescription('The IPX network number on which the server resides.')
a3ipxServerDLAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 6, 1, 4), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxServerDLAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxServerDLAddress.setDescription('The Mac address of the server.')
a3ipxServerSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 6, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxServerSocket.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxServerSocket.setDescription('The socket number of the service.')
a3ipxServerProto = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("static", 2), ("sap", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxServerProto.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxServerProto.setDescription('This object identifies how the entry was made. If the entry was learned via the Service Advertisement Protocol, this object will have the value sap(3). If the entry was entered statically, this object will have the value static(2).')
a3ipxServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 6, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxServerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxServerStatus.setDescription('This table currently does not allow entries to be added. This object is used to delete entries from this table. See the notes describing RowStatus at the beginning of this MIB. Note, only statically learned service entries may be removed via this object. To remove the dynamically learned entries, use the object a3ipxFlushRipSap.')
a3ipxX25configTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 7, 7), )
if mibBuilder.loadTexts: a3ipxX25configTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxX25configTable.setDescription('A list of IPX X25 configuration entries.')
a3ipxX25configEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 7, 7, 1), ).setIndexNames((0, "A3Com-IPX-r5-MIB", "a3ipxX25configPort"))
if mibBuilder.loadTexts: a3ipxX25configEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxX25configEntry.setDescription('Each entry specifies a list of X25 configuration parameters applying to an IPX port.')
a3ipxX25configPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxX25configPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxX25configPort.setDescription('The port number to which this table entry applies.')
a3ipxX25configPID = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(238)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxX25configPID.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxX25configPID.setDescription('The protocol ID that is included in all outgoing IPX packets sent over the X25 port associated with this table entry.')
a3ipxX25configQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxX25configQueueSize.setStatus('deprecated')
if mibBuilder.loadTexts: a3ipxX25configQueueSize.setDescription('The maximum number of packets that can be queued for a specific DTE address when the virtual circuit or the X25 port is congested. NOTE: this object is no longer supported by NETBuilders running sw version 8.0 and greater. The corresponding functionality has been replaced by the X25 Profile feature. SNMP control over this feature will be added at a later date.')
a3ipxX25configVClimit = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 63)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxX25configVClimit.setStatus('deprecated')
if mibBuilder.loadTexts: a3ipxX25configVClimit.setDescription('The maximum number of virtual circuits that can be established concurrently for IPX routing. NOTE: this object is no longer supported by NETBuilders running sw version 8.0 and greater. The corresponding functionality has been replaced by the X25 Profile feature. SNMP control over this feature will be added at a later date.')
a3ipxX25configVCtimer = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxX25configVCtimer.setStatus('deprecated')
if mibBuilder.loadTexts: a3ipxX25configVCtimer.setDescription('The maximum amount of time, in minutes, that can elapse when there is no activity on the X25 virtual circuit before it is cleared. This applies to the first virtual circuit established for a particular DTE address. IF more than one virtual circuit is established for the same DTE address, all are cleared (except for the first one established) when the first virtual circuit is not experiencing congestion. NOTE: this object is no longer supported by NETBuilders running sw version 8.0 and greater. The corresponding functionality has been replaced by the X25 Profile feature. SNMP control over this feature will be added at a later date.')
a3ipxX25configProfId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxX25configProfId.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxX25configProfId.setDescription('To specify an X.25 profile that will be used when the virtual circuit is set-up to carry the IPX traffic. default (0) indicates that no x25 profile is specified.')
a3ipxSmdsGroupAddressTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 7, 8), )
if mibBuilder.loadTexts: a3ipxSmdsGroupAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxSmdsGroupAddressTable.setDescription('A list of SMDS Group Addresses assigned to IPX Ports.')
a3ipxSmdsGroupAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 7, 8, 1), ).setIndexNames((0, "A3Com-IPX-r5-MIB", "a3ipxSmdsGaIpxPort"))
if mibBuilder.loadTexts: a3ipxSmdsGroupAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxSmdsGroupAddressEntry.setDescription('Each entry specifies the SMDS Group Address assigned to an IPX port.')
a3ipxSmdsGaIpxPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxSmdsGaIpxPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxSmdsGaIpxPort.setDescription('This identifies an IPX port to which the SMDS Group Address identified by the corresponding instance of a3ipxSmdsGaAddress is associated.')
a3ipxSmdsGaAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 8, 1, 2), SMDSAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxSmdsGaAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxSmdsGaAddress.setDescription('This identifies an SMDS Group address that is used as the IPX multicast address on the specified SMDS port. If this object has a value of all zeros, then no SMDS Group address is defined for this port.')
a3ipxPreferredSvrTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 7, 9), )
if mibBuilder.loadTexts: a3ipxPreferredSvrTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxPreferredSvrTable.setDescription("A list of those IPX servers that are included in responses to 'Get Nearest Server' requests. Separate lists are kept for each port. When a request is receive over a particular port, this system will respond with the preferred server assigned to that port. If more than one preferred server has been assigned to a particular port, each server will be offered in a round robin fashion. That is, if serverA, serverB, and serverC have been assigned to port 1, serverA will be offered in response to the first request, serverB in response to the second request, and so on.")
a3ipxPreferredSvrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 7, 9, 1), ).setIndexNames((0, "A3Com-IPX-r5-MIB", "a3ipxPrefSvrPort"), (0, "A3Com-IPX-r5-MIB", "a3ipxPrefSvrName"))
if mibBuilder.loadTexts: a3ipxPreferredSvrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxPreferredSvrEntry.setDescription("Each entry specifies an IPX server that will be offered when a 'Get Nearest Server' request in received over a particular port.")
a3ipxPrefSvrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxPrefSvrPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxPrefSvrPort.setDescription('This identifies an IPX port to which the IPX server identified by the corresponding instance of a3ipxPrefSvrName is associated.')
a3ipxPrefSvrName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 9, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 47))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxPrefSvrName.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxPrefSvrName.setDescription("This identifies an IPX server that is offered in response to 'Get Nearest Server' requests received over the port identified by a3ipxPrefSvrPort. If there exists more than one instance of this object for a particular port, each will be offered in a round robin fashion.")
a3ipxPrefSvrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 9, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxPrefSvrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxPrefSvrStatus.setDescription('This object is used to add and remove entries from this table. See the definition of RowStatus at the beginning of this mib module for details.')
a3ipxPortconfigTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 7, 10), )
if mibBuilder.loadTexts: a3ipxPortconfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxPortconfigTable.setDescription('A list of port-specific parmeters.')
a3ipxPortconfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 7, 10, 1), ).setIndexNames((0, "A3Com-IPX-r5-MIB", "a3ipxPortconfigPort"))
if mibBuilder.loadTexts: a3ipxPortconfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxPortconfigEntry.setDescription('Each entry in this table applies the paramater over a seperate port.')
a3ipxPortconfigPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxPortconfigPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxPortconfigPort.setDescription('The port number to which this table entry applies.')
a3ipxRipUpdateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 65535)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRipUpdateTime.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRipUpdateTime.setDescription('This parameter specifies how often the router sends RIP regular updates to exhange routing information. This parameter is defined in units of seconds.')
a3ipxSapUpdateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 65535)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxSapUpdateTime.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxSapUpdateTime.setDescription('This parameter specifies how often the router sends Sap regular updates to exhange and service information. This parameter is defined in units of seconds.')
a3ipxDefMetricHops = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxDefMetricHops.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxDefMetricHops.setDescription('This parameter specifies the hop value placed in NRIP advertisements of the default route. If this object has the value 0, the default route is not advertised.')
a3ipxDefMetricTicks = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxDefMetricTicks.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxDefMetricTicks.setDescription('This parameter specifies the number of ticks placed in NLSP advertisements of the default route.')
a3ipxSpoofCtlTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 7, 11), )
if mibBuilder.loadTexts: a3ipxSpoofCtlTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxSpoofCtlTable.setDescription('A table of spoof controls for all the ports. Each row, represented by a3ipxSpoofCtlEntry, contains the various spoof controls that are applicable to a port.')
a3ipxSpoofCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 7, 11, 1), ).setIndexNames((0, "A3Com-IPX-r5-MIB", "a3ipxSpoofCtlPort"))
if mibBuilder.loadTexts: a3ipxSpoofCtlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxSpoofCtlEntry.setDescription('Each entry represents the various spoof controls applicable to a port.')
a3ipxSpoofCtlPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ipxSpoofCtlPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxSpoofCtlPort.setDescription('Specifies the port number, used as an index to a row entry in the table.')
a3ipxSpoofCtlWatchdog = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 7, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxSpoofCtlWatchdog.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxSpoofCtlWatchdog.setDescription('Used to enable(1) or disable(2) the Spoofing of Watchdog packets.')
a3ipxRipHoldTimeFactor = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxRipHoldTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxRipHoldTimeFactor.setDescription('This parameter specifies a factor that RIP uses to generate a hold time. A holdtime is generated by HoldTimeFactor * UpdateTime. A entry in RIP will be aged out if further update for it is not received within the hold time.')
a3ipxSapHoldTimeFactor = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ipxSapHoldTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: a3ipxSapHoldTimeFactor.setDescription('This parameter specifies a factor that SAP uses to generate a hold time. A holdtime is generated by HoldTimeFactor * UpdateTime. A entry in SAP will be aged out if further update for it is not received within the hold time.')
mibBuilder.exportSymbols("A3Com-IPX-r5-MIB", a3ipxRipControlWanOpt=a3ipxRipControlWanOpt, a3ipxControlPort=a3ipxControlPort, a3ipxSmdsGroupAddressTable=a3ipxSmdsGroupAddressTable, a3ComIPX=a3ComIPX, a3ipxWanBcastControl=a3ipxWanBcastControl, a3ipxX25configProfId=a3ipxX25configProfId, a3ipxRipControlListen=a3ipxRipControlListen, a3ipxPortconfigTable=a3ipxPortconfigTable, a3ipxX25configEntry=a3ipxX25configEntry, a3ipxRipUpdateTime=a3ipxRipUpdateTime, a3ipxRouteDLAddress=a3ipxRouteDLAddress, a3ipxX25configQueueSize=a3ipxX25configQueueSize, a3ipxServerName=a3ipxServerName, a3ipxPortconfigPort=a3ipxPortconfigPort, a3ipxControlEntry=a3ipxControlEntry, a3ipxControl=a3ipxControl, a3ipxWaAddrEntry=a3ipxWaAddrEntry, a3ipxFlushRipSap=a3ipxFlushRipSap, a3ipxRouterName=a3ipxRouterName, a3ipxAttachedNetPort=a3ipxAttachedNetPort, a3ipxAttachedNetFormat=a3ipxAttachedNetFormat, a3ipxServerDLAddress=a3ipxServerDLAddress, a3ipxPreferredSvrTable=a3ipxPreferredSvrTable, a3ipxRipControlMapOpt=a3ipxRipControlMapOpt, a3ipxRipControlPerRip=a3ipxRipControlPerRip, a3ipxRipCtl=a3ipxRipCtl, a3ipxControlWanOpt=a3ipxControlWanOpt, a3ipxRouteHops=a3ipxRouteHops, a3ipxWaAddrTable=a3ipxWaAddrTable, a3ipxAttachedNetTable=a3ipxAttachedNetTable, a3ipxRipControlEntry=a3ipxRipControlEntry, a3ipxAttachedNetOperState=a3ipxAttachedNetOperState, a3ipxInternalNet=a3ipxInternalNet, a3ipxServerTable=a3ipxServerTable, a3ipxServerType=a3ipxServerType, a3ipxRouteAttachedNet=a3ipxRouteAttachedNet, a3ipxSapControlTalk=a3ipxSapControlTalk, a3ipxRipHoldTimeFactor=a3ipxRipHoldTimeFactor, a3ipxSmdsGaAddress=a3ipxSmdsGaAddress, a3ipxSapCtl=a3ipxSapCtl, a3ipxSapUpdateTime=a3ipxSapUpdateTime, a3ipxControlTable=a3ipxControlTable, a3ipxWaAddrDLType=a3ipxWaAddrDLType, a3ipxGeneral=a3ipxGeneral, a3ipxRipControlPort=a3ipxRipControlPort, a3ipxServerEntry=a3ipxServerEntry, a3ipxX25configPort=a3ipxX25configPort, brouterMIB=brouterMIB, a3ipxRipControlPerSap=a3ipxRipControlPerSap, IPXNET=IPXNET, a3ipxRouteDestNet=a3ipxRouteDestNet, a3ipxAttachedNetStatus=a3ipxAttachedNetStatus, a3ipxWaAddrPort=a3ipxWaAddrPort, a3ipxRouteProto=a3ipxRouteProto, a3ipxRipControlTalk=a3ipxRipControlTalk, a3ipxSpoofCtlTable=a3ipxSpoofCtlTable, a3ipxRouteStatus=a3ipxRouteStatus, a3ipxRipControlTable=a3ipxRipControlTable, a3ipxAttachedNetNumber=a3ipxAttachedNetNumber, a3ipxAttachedNetType=a3ipxAttachedNetType, a3ipxUpdateTime=a3ipxUpdateTime, a3ipxSapHoldTimeFactor=a3ipxSapHoldTimeFactor, a3ipxDefMetricHops=a3ipxDefMetricHops, a3ipxDefMetricTicks=a3ipxDefMetricTicks, a3ipxControlWanBcast=a3ipxControlWanBcast, a3ipxX25configPID=a3ipxX25configPID, a3ipxPrefSvrStatus=a3ipxPrefSvrStatus, a3ipxWaAddrEthAddress=a3ipxWaAddrEthAddress, a3ipxRipControlSwitch=a3ipxRipControlSwitch, a3ipxX25configTable=a3ipxX25configTable, a3ipxWaAddrStatus=a3ipxWaAddrStatus, a3ipxRouteControl=a3ipxRouteControl, SMDSAddress=SMDSAddress, a3ipxRipControlPoison=a3ipxRipControlPoison, a3ipxRouteTable=a3ipxRouteTable, a3ipxPortconfigEntry=a3ipxPortconfigEntry, a3ipxServerSocket=a3ipxServerSocket, a3ipxControlRoute=a3ipxControlRoute, a3ipxSpoofCtlEntry=a3ipxSpoofCtlEntry, a3ipxRouteType=a3ipxRouteType, a3ipxRipControlTrigger=a3ipxRipControlTrigger, a3ipxServerProto=a3ipxServerProto, a3ipxSmdsGroupAddressEntry=a3ipxSmdsGroupAddressEntry, a3ipxPreferredSvrEntry=a3ipxPreferredSvrEntry, a3ipxPrefSvrPort=a3ipxPrefSvrPort, a3ipxPrefSvrName=a3ipxPrefSvrName, a3ipxRouteEntry=a3ipxRouteEntry, a3ipxServerNet=a3ipxServerNet, a3ipxWaAddrDLAddress=a3ipxWaAddrDLAddress, a3ipxRouteDLType=a3ipxRouteDLType, a3ipxX25configVClimit=a3ipxX25configVClimit, a3ipxServerStatus=a3ipxServerStatus, RowStatus=RowStatus, a3ipxAttachedNetEntry=a3ipxAttachedNetEntry, a3Com=a3Com, a3ipxRouteDelay=a3ipxRouteDelay, a3ipxX25configVCtimer=a3ipxX25configVCtimer, a3ipxControlChecksum=a3ipxControlChecksum, a3ipxSapControlListen=a3ipxSapControlListen, a3ipxSmdsGaIpxPort=a3ipxSmdsGaIpxPort, a3ipxSpoofCtlPort=a3ipxSpoofCtlPort, a3ipxSpoofCtlWatchdog=a3ipxSpoofCtlWatchdog)

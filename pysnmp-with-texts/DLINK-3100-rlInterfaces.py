#
# PySNMP MIB module DLINK-3100-rlInterfaces (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DLINK-3100-rlInterfaces
# Produced by pysmi-0.3.4 at Wed May  1 12:49:31 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint")
swInterfaces, rlIfInterfaces = mibBuilder.importSymbols("DLINK-3100-MIB", "swInterfaces", "rlIfInterfaces")
InterfaceIndex, InterfaceIndexOrZero, ifIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero", "ifIndex")
PortList, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "PortList")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, MibIdentifier, Gauge32, IpAddress, Integer32, iso, ModuleIdentity, Counter64, Unsigned32, Bits, TimeTicks, NotificationType, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "MibIdentifier", "Gauge32", "IpAddress", "Integer32", "iso", "ModuleIdentity", "Counter64", "Unsigned32", "Bits", "TimeTicks", "NotificationType", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TruthValue, DisplayString, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "RowStatus", "TextualConvention")
class AutoNegCapabilitiesBits(TextualConvention, Bits):
    description = 'Auto negotiation capabilities bits.'
    status = 'current'
    namedValues = NamedValues(("default", 0), ("unknown", 1), ("tenHalf", 2), ("tenFull", 3), ("fastHalf", 4), ("fastFull", 5), ("gigaHalf", 6), ("gigaFull", 7))

swIfTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1), )
if mibBuilder.loadTexts: swIfTable.setStatus('current')
if mibBuilder.loadTexts: swIfTable.setDescription('Switch media specific information and configuration of the device interfaces.')
swIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1), ).setIndexNames((0, "DLINK-3100-rlInterfaces", "swIfIndex"))
if mibBuilder.loadTexts: swIfEntry.setStatus('current')
if mibBuilder.loadTexts: swIfEntry.setDescription('Defines the contents of each line in the swIfTable table.')
swIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfIndex.setStatus('current')
if mibBuilder.loadTexts: swIfIndex.setDescription('Index to the swIfTable. The interface defined by a particular value of this index is the same interface as identified by the same value of ifIndex (MIB II).')
swIfPhysAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("default", 1), ("reserve", 2))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfPhysAddressType.setStatus('obsolete')
if mibBuilder.loadTexts: swIfPhysAddressType.setDescription(' This variable indicates whether the physical address assigned to this interface should be the default one or be chosen from the set of reserved physical addresses of the device.')
swIfDuplexAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("half", 2), ("full", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfDuplexAdminMode.setStatus('current')
if mibBuilder.loadTexts: swIfDuplexAdminMode.setDescription("This variable specifies whether this interface should operate in half duplex or full duplex mode. This specification will take effect only if swIfSpeedDuplexAutoNegotiation is disabled. A value of 'none' is returned if a value of the variable hasn't been set.")
swIfDuplexOperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("half", 1), ("full", 2), ("hybrid", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfDuplexOperMode.setStatus('current')
if mibBuilder.loadTexts: swIfDuplexOperMode.setDescription(' This variable indicates whether this interface operates in half duplex or full duplex mode. This variable can have the values hybrid or unknown only for a trunk. unknown - only if trunk operative status is not present.')
swIfBackPressureMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfBackPressureMode.setStatus('current')
if mibBuilder.loadTexts: swIfBackPressureMode.setDescription('This variable indicates whether this interface activates back pressure when congested.')
swIfTaggedMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfTaggedMode.setStatus('current')
if mibBuilder.loadTexts: swIfTaggedMode.setDescription('If enable, this interface operates in tagged mode, i.e all frames sent out through this interface will have the 802.1Q header. If disabled the frames will not be tagged.')
swIfTransceiverType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("regular", 1), ("fiberOptics", 2), ("comboRegular", 3), ("comboFiberOptics", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfTransceiverType.setStatus('current')
if mibBuilder.loadTexts: swIfTransceiverType.setDescription(' This variable indicates the transceiver type of this interface.')
swIfLockAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("locked", 1), ("unlocked", 2))).clone('unlocked')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfLockAdminStatus.setStatus('current')
if mibBuilder.loadTexts: swIfLockAdminStatus.setDescription('This variable indicates whether this interface should operate in locked or unlocked mode. In unlocked mode the device learns all MAC addresses from this port and forwards all frames arrived at this port. In locked mode no new MAC addresses are learned and only frames with known source MAC addresses are forwarded.')
swIfLockOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("locked", 1), ("unlocked", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfLockOperStatus.setStatus('current')
if mibBuilder.loadTexts: swIfLockOperStatus.setDescription('This variable defines whether this interface operates in locked or unlocked mode. It is locked in each of the following two cases: 1) if swLockAdminStatus is set to locked 2) no IP/IPX interface is defined over this interface and no VLAN contains this interface. In unlocked mode the device learns all MAC addresses from this port and forwards all frames arrived at this port. In locked mode no new MAC addresses are learned and only frames with known source MAC addresses are forwarded.')
swIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eth10M", 1), ("eth100M", 2), ("eth1000M", 3), ("eth10G", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfType.setStatus('current')
if mibBuilder.loadTexts: swIfType.setDescription(' This variable specifies the type of interface.')
swIfDefaultTag = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfDefaultTag.setStatus('current')
if mibBuilder.loadTexts: swIfDefaultTag.setDescription('This variable specifies the default VLAN tag which will be attached to outgoing frames if swIfTaggedMode for this interface is enabled.')
swIfDefaultPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfDefaultPriority.setStatus('current')
if mibBuilder.loadTexts: swIfDefaultPriority.setDescription(' This variable specifies the default port priority.')
swIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 13), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfStatus.setStatus('current')
if mibBuilder.loadTexts: swIfStatus.setDescription('The status of a table entry. It is used to delete an entry from this table.')
swIfFlowControlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("autoNegotiation", 3), ("enabledRx", 4), ("enabledTx", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfFlowControlMode.setStatus('current')
if mibBuilder.loadTexts: swIfFlowControlMode.setDescription("on - Flow control will be enabled on this interface according to the IEEE 802.3x standard. off - Flow control is disabled. autoNegotiation - Flow control will be enabled or disabled on this interface. If enabled, it will operate as specified by the IEEE 802.3x standard. enabledRx - Flow control will be enabled on this interface for recieved frames. enabledTx - Flow control will be enabled on this interface for transmitted frames. An attempt to set this object to 'enabledRx(4)' or 'enabledTx(5)' will fail on interfaces that do not support operation at greater than 100 Mb/s. In any case, flow control can work only if swIfDuplexOperMode is full.")
swIfSpeedAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfSpeedAdminMode.setStatus('current')
if mibBuilder.loadTexts: swIfSpeedAdminMode.setDescription("This variable specifies the required speed of this interface in bits per second. This specification will take effect only if swIfSpeedDuplexAutoNegotiation is disabled. A value of 10 is returned for 10G. A value of 0 is returned if the value of the variable hasn't been set.")
swIfSpeedDuplexAutoNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfSpeedDuplexAutoNegotiation.setStatus('current')
if mibBuilder.loadTexts: swIfSpeedDuplexAutoNegotiation.setDescription('If enabled the speed and duplex mode will be set by the device through the autonegotiation process. Otherwise these characteristics will be set according to the values of swIfSpeedAdminMode and swIfSpeedDuplexAutoNegotiation.')
swIfOperFlowControlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("enabledRx", 3), ("enabledTx", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfOperFlowControlMode.setStatus('current')
if mibBuilder.loadTexts: swIfOperFlowControlMode.setDescription('on - Flow control is enabled on this interface according to the IEEE 802.3x standard. off - Flow control is disabled. enabledRx - Flow control is enabled on this interface for recieved frames. enabledTx - Flow control is enabled on this interface for transmitted frames.')
swIfOperSpeedDuplexAutoNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("hybrid", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfOperSpeedDuplexAutoNegotiation.setStatus('current')
if mibBuilder.loadTexts: swIfOperSpeedDuplexAutoNegotiation.setDescription('If enabled the speed and duplex are determined by the device through the autonegotiation process. If disabled these characteristics are determined according to the values of swIfSpeedAdminMode and swIfDuplexAdminMode. hybrid - only for a trunk. unknown - only for ports that there operative status is not present.')
swIfOperBackPressureMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("hybrid", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfOperBackPressureMode.setStatus('current')
if mibBuilder.loadTexts: swIfOperBackPressureMode.setDescription('This variable indicates the operative back pressure mode of this interface.')
swIfAdminLockAction = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("discard", 1), ("forwardNormal", 2), ("discardDisable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfAdminLockAction.setStatus('current')
if mibBuilder.loadTexts: swIfAdminLockAction.setDescription('This variable indicates which action this interface should be taken in locked mode and therefore relevant only in locked mode. Possible actions: discard(1) - every packet is dropped. forwardNormal(2) - every packet is forwarded according to the DST address. discardDisable(3) - drops the first packet and suspends the port.')
swIfOperLockAction = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("discard", 1), ("forwardNormal", 2), ("discardDisable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfOperLockAction.setStatus('current')
if mibBuilder.loadTexts: swIfOperLockAction.setDescription('This variable indicates which action this interface actually takes in locked mode and therefore relevant only in locked mode. Possible actions: discard(1) - every packet is dropped. forwardNormal(2) - every packet is forwarded according to the DST address. discardDisable(3) - drops the first packet and suspends the port.')
swIfAdminLockTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 22), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfAdminLockTrapEnable.setStatus('current')
if mibBuilder.loadTexts: swIfAdminLockTrapEnable.setDescription('This variable indicates whether to create a SNMP trap in the locked mode.')
swIfOperLockTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 23), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfOperLockTrapEnable.setStatus('current')
if mibBuilder.loadTexts: swIfOperLockTrapEnable.setDescription('This variable indicates whether a SNMP trap can be created in the locked mode.')
swIfOperSuspendedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 24), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfOperSuspendedStatus.setStatus('current')
if mibBuilder.loadTexts: swIfOperSuspendedStatus.setDescription('This variable indicates whether the port is suspended or not due to some feature. After reboot this value is false')
swIfLockOperTrapCount = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfLockOperTrapCount.setStatus('current')
if mibBuilder.loadTexts: swIfLockOperTrapCount.setDescription("This variable indicates the trap counter status per ifIndex (i.e. number of received packets since the last trap sent due to a packet which was received on this ifIndex). It's relevant only in locked mode while trap is enabled.")
swIfLockAdminTrapFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfLockAdminTrapFrequency.setStatus('current')
if mibBuilder.loadTexts: swIfLockAdminTrapFrequency.setDescription("This variable indicates the minimal frequency (in seconds) of sending a trap per ifIndex. It's relevant only in locked mode and in trap enabled.")
swIfReActivate = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 27), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfReActivate.setStatus('current')
if mibBuilder.loadTexts: swIfReActivate.setDescription('This variable reactivates (enables) an ifIndex (which was suspended)')
swIfAdminMdix = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cross", 1), ("normal", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfAdminMdix.setStatus('current')
if mibBuilder.loadTexts: swIfAdminMdix.setDescription('The configuration is on a physical port, not include trunks. cross - The interface should force crossover. normal - The interface should not force crossover. auto - Auto mdix is enabled on the interface.')
swIfOperMdix = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cross", 1), ("normal", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfOperMdix.setStatus('current')
if mibBuilder.loadTexts: swIfOperMdix.setDescription('cross - The interface is in crossover mode. normal - The interface is not in crossover mode. unknown - Only for port that its operative status is not present or down.')
swIfHostMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("single", 1), ("multiple", 2), ("multiple-auth", 3))).clone('single')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfHostMode.setStatus('current')
if mibBuilder.loadTexts: swIfHostMode.setDescription("This variable indicates the 802.1X host mode of a port. Relevant when the port's 802.1X control is auto. In addtion multiple-auth was added.")
swIfSingleHostViolationAdminAction = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("discard", 1), ("forwardNormal", 2), ("discardDisable", 3))).clone('discard')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfSingleHostViolationAdminAction.setStatus('current')
if mibBuilder.loadTexts: swIfSingleHostViolationAdminAction.setDescription('This variable indicates which action this interface should take in single authorized. Possible actions: discard - every packet is dropped. forwardNormal - every packet is forwarded according to the DST address. discardDisable - drops the first packet and suspends the port.')
swIfSingleHostViolationOperAction = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("discard", 1), ("forwardNormal", 2), ("discardDisable", 3))).clone('discard')).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfSingleHostViolationOperAction.setStatus('current')
if mibBuilder.loadTexts: swIfSingleHostViolationOperAction.setDescription('This variable indicates which action this interface actually takes in single authorized. Possible actions: discard(1) - every packet is dropped. forwardNormal(2) - every packet is forwarded according to the DST address. discardDisable(3) - drops the first packet and suspends the port.')
swIfSingleHostViolationAdminTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 33), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfSingleHostViolationAdminTrapEnable.setStatus('current')
if mibBuilder.loadTexts: swIfSingleHostViolationAdminTrapEnable.setDescription('This variable indicates whether to create a SNMP trap in single authorized.')
swIfSingleHostViolationOperTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 34), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfSingleHostViolationOperTrapEnable.setStatus('current')
if mibBuilder.loadTexts: swIfSingleHostViolationOperTrapEnable.setDescription('This variable indicates whether a SNMP trap can be created in the single authorized.')
swIfSingleHostViolationOperTrapCount = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfSingleHostViolationOperTrapCount.setStatus('current')
if mibBuilder.loadTexts: swIfSingleHostViolationOperTrapCount.setDescription("This variable indicates the trap counter status per ifIndex (i.e. number of received packets since the last trap sent due to a packet which was received on this ifIndex). It's relevant only in single authorized while trap is enabled.")
swIfSingleHostViolationAdminTrapFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000000)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfSingleHostViolationAdminTrapFrequency.setStatus('current')
if mibBuilder.loadTexts: swIfSingleHostViolationAdminTrapFrequency.setDescription("This variable indicates the minimal frequency (in seconds) of sending a trap per ifIndex. It's relevant only in single authorized and in trap enabled.")
swIfLockLimitationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("dynamic", 2), ("secure-permanent", 3), ("secure-delete-on-reset", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfLockLimitationMode.setStatus('current')
if mibBuilder.loadTexts: swIfLockLimitationMode.setDescription("This variable indicates what is the learning limitation on the locked interface. Possible values: disabled - learning is stopped. The dynamic addresses associated with the port are not aged out or relearned on other port as long as the port is locked. dynamic - dynamic addresses can be learned up to the maximum dynamic addresses allowed on the port. Relearning and aging of the dynamic addresses are enabled. The learned addresses aren't kept after reset. secure-permanent - secure addresses can be learned up to the maximum addresses allowed on the port. Relearning and aging of addresses are disabled. The learned addresses are kept after reset. secure-delete-on-reset - secure addresses can be learned up to the maximum addresses allowed on the port. Relearning and aging of addresses are disabled. The learned addresses are not kept after reset.")
swIfLockMaxMacAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfLockMaxMacAddresses.setStatus('current')
if mibBuilder.loadTexts: swIfLockMaxMacAddresses.setDescription("This variable defines the maximum number of dynamic addresses that can be asscoiated with the locked interface. It isn't relevant in disabled limitation mode.")
swIfLockMacAddressesCount = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfLockMacAddressesCount.setStatus('current')
if mibBuilder.loadTexts: swIfLockMacAddressesCount.setDescription("This variable indicates the actual number of dynamic addresses that can be asscoiated with the locked interface. It isn't relevant in disabled limitation mode.")
swIfAdminSpeedDuplexAutoNegotiationLocalCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 40), AutoNegCapabilitiesBits().clone(namedValues=NamedValues(("default", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfAdminSpeedDuplexAutoNegotiationLocalCapabilities.setStatus('current')
if mibBuilder.loadTexts: swIfAdminSpeedDuplexAutoNegotiationLocalCapabilities.setDescription("Administrative auto negotiation capabilities of the interface that can be advertised when swIfSpeedDuplexAutoNegotiation is enabled. default bit means advertise all the port's capabilities according to its type.")
swIfOperSpeedDuplexAutoNegotiationLocalCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 41), AutoNegCapabilitiesBits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfOperSpeedDuplexAutoNegotiationLocalCapabilities.setStatus('current')
if mibBuilder.loadTexts: swIfOperSpeedDuplexAutoNegotiationLocalCapabilities.setDescription('Operative auto negotiation capabilities of the remote link. unknown bit means that port operative status is not up.')
swIfSpeedDuplexNegotiationRemoteCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 42), AutoNegCapabilitiesBits()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfSpeedDuplexNegotiationRemoteCapabilities.setStatus('current')
if mibBuilder.loadTexts: swIfSpeedDuplexNegotiationRemoteCapabilities.setDescription('Operative auto negotiation capabilities of the remote link. unknown bit means that port operative status is not up, or auto negotiation process not complete, or remote link is not auto negotiation able.')
swIfAdminComboMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("force-fiber", 1), ("force-copper", 2), ("prefer-fiber", 3), ("prefer-copper", 4))).clone('prefer-fiber')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfAdminComboMode.setStatus('current')
if mibBuilder.loadTexts: swIfAdminComboMode.setDescription('This variable specifies the administrative mode of a combo Ethernet interface.')
swIfOperComboMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 1, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fiber", 1), ("copper", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfOperComboMode.setStatus('current')
if mibBuilder.loadTexts: swIfOperComboMode.setDescription('This variable specifies the operative mode of a combo Ethernet interface.')
swIfMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfMibVersion.setStatus('current')
if mibBuilder.loadTexts: swIfMibVersion.setDescription("The swIfTable Mib's version, the current version is 3.")
swIfPortLockSupport = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfPortLockSupport.setStatus('current')
if mibBuilder.loadTexts: swIfPortLockSupport.setDescription('indicates if the locked port package is supported.')
swIfPortLockActionSupport = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfPortLockActionSupport.setStatus('current')
if mibBuilder.loadTexts: swIfPortLockActionSupport.setDescription('indicates which port lock actions are supported: (bit 0 is the most significant bit) bit 0 - discard bit 1 - forwardNormal bit 2 - discardDisable')
swIfPortLockTrapSupport = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfPortLockTrapSupport.setStatus('current')
if mibBuilder.loadTexts: swIfPortLockTrapSupport.setDescription('indicates with which port lock actions the trap option is supported (e.g. discard indicates that trap is supported only when the portlock action is discard): (bit 0 is the most significant bit) bit 0 - discard bit 1 - forwardNormal bit 2 - discardDisable')
swIfPortLockIfRangeTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 6), )
if mibBuilder.loadTexts: swIfPortLockIfRangeTable.setStatus('current')
if mibBuilder.loadTexts: swIfPortLockIfRangeTable.setDescription('Port lock interfaces range configuration')
swIfPortLockIfRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 6, 1), ).setIndexNames((0, "DLINK-3100-rlInterfaces", "swIfPortLockIfRangeIndex"))
if mibBuilder.loadTexts: swIfPortLockIfRangeEntry.setStatus('current')
if mibBuilder.loadTexts: swIfPortLockIfRangeEntry.setDescription('Defines the contents of each line in the swIfPortLockIfRangeTable table.')
swIfPortLockIfRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swIfPortLockIfRangeIndex.setStatus('current')
if mibBuilder.loadTexts: swIfPortLockIfRangeIndex.setDescription('Index to the swIfPortLockIfRangeTable.')
swIfPortLockIfRange = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 6, 1, 2), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfPortLockIfRange.setStatus('current')
if mibBuilder.loadTexts: swIfPortLockIfRange.setDescription('The set of interfaces to which the port lock parameters should be configured')
swIfPortLockIfRangeLockStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("locked", 1), ("unlocked", 2))).clone('unlocked')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfPortLockIfRangeLockStatus.setStatus('current')
if mibBuilder.loadTexts: swIfPortLockIfRangeLockStatus.setDescription('This variable indicates whether the interfaces range should operate in locked or unlocked mode. In unlocked mode the device learns all MAC addresses from these interfaces and forwards all frames arrived at these interfaces. In locked mode no new MAC addresses are learned and only frames with known source MAC addresses are forwarded.')
swIfPortLockIfRangeAction = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("discard", 1), ("forwardNormal", 2), ("discardDisable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfPortLockIfRangeAction.setStatus('current')
if mibBuilder.loadTexts: swIfPortLockIfRangeAction.setDescription('This variable indicates which action for these interfaces should be take in locked mode and therefore relevant only in locked mode. Possible actions: discard(1) - every packet is dropped. forwardNormal(2) - every packet is forwarded according to the DST address. discardDisable(3) - drops the first packet and suspends the port.')
swIfPortLockIfRangeTrapEn = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 6, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfPortLockIfRangeTrapEn.setStatus('current')
if mibBuilder.loadTexts: swIfPortLockIfRangeTrapEn.setDescription('This variable indicates whether to create a SNMP trap in the locked mode.')
swIfPortLockIfRangeTrapFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfPortLockIfRangeTrapFreq.setStatus('current')
if mibBuilder.loadTexts: swIfPortLockIfRangeTrapFreq.setDescription("This variable indicates the minimal frequency (in seconds) of sending a trap for these interfaces. It's relevant only in locked mode and in trap enabled.")
swIfExtTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 7), )
if mibBuilder.loadTexts: swIfExtTable.setStatus('current')
if mibBuilder.loadTexts: swIfExtTable.setDescription('Display information and configuration of the device interfaces.')
swIfExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: swIfExtEntry.setStatus('current')
if mibBuilder.loadTexts: swIfExtEntry.setDescription('Defines the contents of each row in the swIfExtTable.')
swIfExtSFPSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 43, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("eth100M", 2), ("eth1G", 3))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swIfExtSFPSpeed.setStatus('current')
if mibBuilder.loadTexts: swIfExtSFPSpeed.setDescription('Configure speed of an SFP Ethernet interface.')
rlIfMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIfMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlIfMibVersion.setDescription("MIB's version, the current version is 1.")
rlIfNumOfPhPorts = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIfNumOfPhPorts.setStatus('current')
if mibBuilder.loadTexts: rlIfNumOfPhPorts.setDescription('Total number of physical ports on this device (including all stack units)')
rlIfMapOfOnPhPorts = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIfMapOfOnPhPorts.setStatus('current')
if mibBuilder.loadTexts: rlIfMapOfOnPhPorts.setDescription("Each bit in this octet string indicates that the correspondig port's ifOperStatus is ON if set. The mapping of port number to bits in this octet string is as follows: The port with the L2 interface number 1 is mapped to the least significant bit of the 1st octet, the port with L2 ifNumber 2 to the next significant bit in the 1st octet, port 8 to the most-significant bit of the in the 1st octet, port 9 to the least significant bit of the 2nd octet, etc. and in general, port n to bit corresponding to 2**((n mod 8) -1) in byte n/8 + 1")
rlIfClearPortMibCounters = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 4), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIfClearPortMibCounters.setStatus('current')
if mibBuilder.loadTexts: rlIfClearPortMibCounters.setDescription('Each bit that is set in this portList represent a port that its mib counters should be reset.')
rlIfNumOfUserDefinedPorts = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIfNumOfUserDefinedPorts.setStatus('current')
if mibBuilder.loadTexts: rlIfNumOfUserDefinedPorts.setDescription('The number of user defined ports on this device.')
rlIfFirstOutOfBandIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIfFirstOutOfBandIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlIfFirstOutOfBandIfIndex.setDescription('First ifIndex of out-of-band port. This scalar exists only the device has out of band ports.')
rlIfNumOfLoopbackPorts = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIfNumOfLoopbackPorts.setStatus('current')
if mibBuilder.loadTexts: rlIfNumOfLoopbackPorts.setDescription('The number of loopback ports on this device.')
rlIfFirstLoopbackIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIfFirstLoopbackIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlIfFirstLoopbackIfIndex.setDescription('First ifIndex of loopback port. This scalar will exists only if rlIfNumOfLoopbackPorts is different from 0.')
rlIfExistingPortList = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 9), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIfExistingPortList.setStatus('current')
if mibBuilder.loadTexts: rlIfExistingPortList.setDescription("Indicates which ports/trunks exist in the system. It doesn't indicate which are present.")
rlIfBaseMACAddressPerIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIfBaseMACAddressPerIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlIfBaseMACAddressPerIfIndex.setDescription('Indicates if the system will assign a unique MAC per Ethernet port or not.')
rlFlowControlCascadeMode = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlFlowControlCascadeMode.setStatus('current')
if mibBuilder.loadTexts: rlFlowControlCascadeMode.setDescription('enable disable flow control on cascade ports')
rlFlowControlCascadeType = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internalonly", 1), ("internalexternal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlFlowControlCascadeType.setStatus('current')
if mibBuilder.loadTexts: rlFlowControlCascadeType.setDescription('define which type of ports will be affected by flow control on cascade ports')
rlFlowControlRxPerSystem = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 13), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlFlowControlRxPerSystem.setStatus('current')
if mibBuilder.loadTexts: rlFlowControlRxPerSystem.setDescription('define if flow control RX is supported per system.')
rlCascadePortProtectionAction = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 14), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCascadePortProtectionAction.setStatus('current')
if mibBuilder.loadTexts: rlCascadePortProtectionAction.setDescription('As a result of this set all of the local cascade ports will stop being consider unstable and will be force up.')
rlManagementIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 15), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlManagementIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlManagementIfIndex.setDescription('Specify L2 bound management interface index in a single IP address system when configurable management interface is supported.')
rlIfClearStackPortsCounters = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 16), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIfClearStackPortsCounters.setStatus('current')
if mibBuilder.loadTexts: rlIfClearStackPortsCounters.setDescription('As a result of this set all counters of all external cascade ports will be cleared.')
rlIfClearPortMacAddresses = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 94, 89, 89, 54, 17), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIfClearPortMacAddresses.setStatus('current')
if mibBuilder.loadTexts: rlIfClearPortMacAddresses.setDescription('if port is non secure, its all dynamic MAC addresses are cleared. if port is secure, its all secure MAC addresses which have learned or configured are cleared.')
mibBuilder.exportSymbols("DLINK-3100-rlInterfaces", swIfSingleHostViolationOperTrapEnable=swIfSingleHostViolationOperTrapEnable, swIfLockLimitationMode=swIfLockLimitationMode, swIfStatus=swIfStatus, swIfIndex=swIfIndex, swIfAdminMdix=swIfAdminMdix, swIfOperSuspendedStatus=swIfOperSuspendedStatus, swIfHostMode=swIfHostMode, swIfPortLockIfRangeTable=swIfPortLockIfRangeTable, rlIfExistingPortList=rlIfExistingPortList, swIfPortLockActionSupport=swIfPortLockActionSupport, rlIfNumOfUserDefinedPorts=rlIfNumOfUserDefinedPorts, swIfPortLockIfRangeIndex=swIfPortLockIfRangeIndex, rlFlowControlCascadeType=rlFlowControlCascadeType, swIfSingleHostViolationAdminTrapFrequency=swIfSingleHostViolationAdminTrapFrequency, swIfLockMaxMacAddresses=swIfLockMaxMacAddresses, swIfEntry=swIfEntry, swIfLockMacAddressesCount=swIfLockMacAddressesCount, swIfLockAdminTrapFrequency=swIfLockAdminTrapFrequency, swIfBackPressureMode=swIfBackPressureMode, rlFlowControlCascadeMode=rlFlowControlCascadeMode, rlIfMibVersion=rlIfMibVersion, swIfDefaultPriority=swIfDefaultPriority, rlFlowControlRxPerSystem=rlFlowControlRxPerSystem, swIfSingleHostViolationAdminAction=swIfSingleHostViolationAdminAction, swIfPortLockIfRangeTrapFreq=swIfPortLockIfRangeTrapFreq, swIfLockOperTrapCount=swIfLockOperTrapCount, rlIfFirstLoopbackIfIndex=rlIfFirstLoopbackIfIndex, swIfSingleHostViolationAdminTrapEnable=swIfSingleHostViolationAdminTrapEnable, swIfSpeedDuplexAutoNegotiation=swIfSpeedDuplexAutoNegotiation, swIfAdminLockAction=swIfAdminLockAction, swIfExtSFPSpeed=swIfExtSFPSpeed, swIfAdminLockTrapEnable=swIfAdminLockTrapEnable, swIfSpeedDuplexNegotiationRemoteCapabilities=swIfSpeedDuplexNegotiationRemoteCapabilities, swIfDuplexAdminMode=swIfDuplexAdminMode, swIfOperLockAction=swIfOperLockAction, swIfAdminSpeedDuplexAutoNegotiationLocalCapabilities=swIfAdminSpeedDuplexAutoNegotiationLocalCapabilities, swIfExtEntry=swIfExtEntry, rlIfNumOfPhPorts=rlIfNumOfPhPorts, swIfMibVersion=swIfMibVersion, swIfSpeedAdminMode=swIfSpeedAdminMode, rlCascadePortProtectionAction=rlCascadePortProtectionAction, swIfPhysAddressType=swIfPhysAddressType, swIfAdminComboMode=swIfAdminComboMode, swIfTaggedMode=swIfTaggedMode, swIfPortLockIfRangeLockStatus=swIfPortLockIfRangeLockStatus, swIfTable=swIfTable, swIfLockAdminStatus=swIfLockAdminStatus, swIfReActivate=swIfReActivate, rlIfClearPortMacAddresses=rlIfClearPortMacAddresses, swIfOperFlowControlMode=swIfOperFlowControlMode, swIfOperComboMode=swIfOperComboMode, rlIfClearStackPortsCounters=rlIfClearStackPortsCounters, rlIfNumOfLoopbackPorts=rlIfNumOfLoopbackPorts, swIfOperSpeedDuplexAutoNegotiationLocalCapabilities=swIfOperSpeedDuplexAutoNegotiationLocalCapabilities, rlIfFirstOutOfBandIfIndex=rlIfFirstOutOfBandIfIndex, swIfFlowControlMode=swIfFlowControlMode, rlIfBaseMACAddressPerIfIndex=rlIfBaseMACAddressPerIfIndex, AutoNegCapabilitiesBits=AutoNegCapabilitiesBits, swIfPortLockIfRange=swIfPortLockIfRange, swIfOperSpeedDuplexAutoNegotiation=swIfOperSpeedDuplexAutoNegotiation, swIfSingleHostViolationOperAction=swIfSingleHostViolationOperAction, swIfSingleHostViolationOperTrapCount=swIfSingleHostViolationOperTrapCount, swIfLockOperStatus=swIfLockOperStatus, swIfOperMdix=swIfOperMdix, rlIfClearPortMibCounters=rlIfClearPortMibCounters, swIfDefaultTag=swIfDefaultTag, swIfTransceiverType=swIfTransceiverType, swIfPortLockIfRangeAction=swIfPortLockIfRangeAction, swIfDuplexOperMode=swIfDuplexOperMode, swIfExtTable=swIfExtTable, swIfPortLockTrapSupport=swIfPortLockTrapSupport, rlManagementIfIndex=rlManagementIfIndex, swIfType=swIfType, swIfOperBackPressureMode=swIfOperBackPressureMode, swIfPortLockIfRangeTrapEn=swIfPortLockIfRangeTrapEn, swIfPortLockIfRangeEntry=swIfPortLockIfRangeEntry, swIfOperLockTrapEnable=swIfOperLockTrapEnable, swIfPortLockSupport=swIfPortLockSupport, rlIfMapOfOnPhPorts=rlIfMapOfOnPhPorts)

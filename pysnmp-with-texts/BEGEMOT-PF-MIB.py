#
# PySNMP MIB module BEGEMOT-PF-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BEGEMOT-PF-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:37:07 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
begemot, = mibBuilder.importSymbols("BEGEMOT-MIB", "begemot")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Bits, ObjectIdentity, Integer32, TimeTicks, Unsigned32, NotificationType, IpAddress, MibIdentifier, Counter32, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Bits", "ObjectIdentity", "Integer32", "TimeTicks", "Unsigned32", "NotificationType", "IpAddress", "MibIdentifier", "Counter32", "Counter64")
TextualConvention, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue")
begemotPf = ModuleIdentity((1, 3, 6, 1, 4, 1, 12325, 1, 200))
if mibBuilder.loadTexts: begemotPf.setLastUpdated('200501240000Z')
if mibBuilder.loadTexts: begemotPf.setOrganization('NixSys BVBA')
if mibBuilder.loadTexts: begemotPf.setContactInfo(' Philip Paeps Postal: NixSys BVBA Louizastraat 14 BE-2800 Mechelen Belgium E-Mail: philip@FreeBSD.org')
if mibBuilder.loadTexts: begemotPf.setDescription('The Begemot MIB for the pf packet filter.')
begemotPfObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1))
pfStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 1))
pfCounter = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 2))
pfStateTable = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 3))
pfSrcNodes = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 4))
pfLimits = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 5))
pfTimeouts = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6))
pfLogInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7))
pfInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8))
pfTables = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9))
pfAltq = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10))
pfStatusRunning = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStatusRunning.setStatus('current')
if mibBuilder.loadTexts: pfStatusRunning.setDescription('True if pf is currently enabled.')
pfStatusRuntime = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 1, 2), TimeTicks()).setUnits('1/100th of a Second').setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStatusRuntime.setStatus('current')
if mibBuilder.loadTexts: pfStatusRuntime.setDescription('Indicates how long pf has been enabled. If pf is not currently enabled, indicates how long it has been disabled. If pf has not been enabled or disabled since the system was started, the value will be 0.')
pfStatusDebug = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("urgent", 1), ("misc", 2), ("loud", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStatusDebug.setStatus('current')
if mibBuilder.loadTexts: pfStatusDebug.setDescription('Indicates the debug level at which pf is running.')
pfStatusHostId = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStatusHostId.setStatus('current')
if mibBuilder.loadTexts: pfStatusHostId.setDescription('The (unique) host identifier of the machine running pf.')
pfCounterMatch = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 2, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfCounterMatch.setStatus('current')
if mibBuilder.loadTexts: pfCounterMatch.setDescription('Number of packets that matched a filter rule.')
pfCounterBadOffset = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 2, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfCounterBadOffset.setStatus('current')
if mibBuilder.loadTexts: pfCounterBadOffset.setDescription('Number of packets with bad offset.')
pfCounterFragment = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 2, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfCounterFragment.setStatus('current')
if mibBuilder.loadTexts: pfCounterFragment.setDescription('Number of fragmented packets.')
pfCounterShort = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 2, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfCounterShort.setStatus('current')
if mibBuilder.loadTexts: pfCounterShort.setDescription('Number of short packets.')
pfCounterNormalize = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 2, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfCounterNormalize.setStatus('current')
if mibBuilder.loadTexts: pfCounterNormalize.setDescription('Number of normalized packets.')
pfCounterMemDrop = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 2, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfCounterMemDrop.setStatus('current')
if mibBuilder.loadTexts: pfCounterMemDrop.setDescription('Number of packets dropped due to memory limitations.')
pfStateTableCount = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 3, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStateTableCount.setStatus('current')
if mibBuilder.loadTexts: pfStateTableCount.setDescription('Number of entries in the state table.')
pfStateTableSearches = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 3, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStateTableSearches.setStatus('current')
if mibBuilder.loadTexts: pfStateTableSearches.setDescription('Number of searches against the state table.')
pfStateTableInserts = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 3, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStateTableInserts.setStatus('current')
if mibBuilder.loadTexts: pfStateTableInserts.setDescription('Number of entries inserted into the state table.')
pfStateTableRemovals = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 3, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStateTableRemovals.setStatus('current')
if mibBuilder.loadTexts: pfStateTableRemovals.setDescription('Number of entries removed from the state table.')
pfSrcNodesCount = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 4, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfSrcNodesCount.setStatus('current')
if mibBuilder.loadTexts: pfSrcNodesCount.setDescription('Number of entries in the source tracking table.')
pfSrcNodesSearches = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 4, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfSrcNodesSearches.setStatus('current')
if mibBuilder.loadTexts: pfSrcNodesSearches.setDescription('Number of searches against the source tracking table.')
pfSrcNodesInserts = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 4, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfSrcNodesInserts.setStatus('current')
if mibBuilder.loadTexts: pfSrcNodesInserts.setDescription('Number of entries inserted into the source tracking table.')
pfSrcNodesRemovals = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 4, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfSrcNodesRemovals.setStatus('current')
if mibBuilder.loadTexts: pfSrcNodesRemovals.setDescription('Number of entries removed from the source tracking table.')
pfLimitsStates = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 5, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLimitsStates.setStatus('current')
if mibBuilder.loadTexts: pfLimitsStates.setDescription("Maximum number of 'keep state' rules in the ruleset.")
pfLimitsSrcNodes = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 5, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLimitsSrcNodes.setStatus('current')
if mibBuilder.loadTexts: pfLimitsSrcNodes.setDescription("Maximum number of 'sticky-address' or 'source-track' rules in the ruleset.")
pfLimitsFrags = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 5, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLimitsFrags.setStatus('current')
if mibBuilder.loadTexts: pfLimitsFrags.setDescription("Maximum number of 'scrub' rules in the ruleset.")
pfTimeoutsTcpFirst = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsTcpFirst.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsTcpFirst.setDescription('State after the first packet in a connection.')
pfTimeoutsTcpOpening = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsTcpOpening.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsTcpOpening.setDescription('State before the destination host ever sends a packet.')
pfTimeoutsTcpEstablished = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsTcpEstablished.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsTcpEstablished.setDescription('The fully established state.')
pfTimeoutsTcpClosing = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsTcpClosing.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsTcpClosing.setDescription('State after the first FIN has been sent.')
pfTimeoutsTcpFinWait = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsTcpFinWait.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsTcpFinWait.setDescription('State after both FINs have been exchanged and the connection is closed.')
pfTimeoutsTcpClosed = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsTcpClosed.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsTcpClosed.setDescription('State after one endpoint sends an RST.')
pfTimeoutsUdpFirst = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsUdpFirst.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsUdpFirst.setDescription('State after the first packet.')
pfTimeoutsUdpSingle = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsUdpSingle.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsUdpSingle.setDescription('State if the source host sends more than one packet but the destination host has never sent one back.')
pfTimeoutsUdpMultiple = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsUdpMultiple.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsUdpMultiple.setDescription('State if both hosts have sent packets.')
pfTimeoutsIcmpFirst = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsIcmpFirst.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsIcmpFirst.setDescription('State after the first packet.')
pfTimeoutsIcmpError = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsIcmpError.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsIcmpError.setDescription('State after an ICMP error came back in response to an ICMP packet.')
pfTimeoutsOtherFirst = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsOtherFirst.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsOtherFirst.setDescription('State after the first packet.')
pfTimeoutsOtherSingle = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsOtherSingle.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsOtherSingle.setDescription('State if the source host sends more than one packet but the destination host has never sent one back.')
pfTimeoutsOtherMultiple = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsOtherMultiple.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsOtherMultiple.setDescription('State if both hosts have sent packets.')
pfTimeoutsFragment = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsFragment.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsFragment.setDescription('Seconds before an unassembled fragment is expired.')
pfTimeoutsInterval = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsInterval.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsInterval.setDescription('Interval between purging expired states and fragments.')
pfTimeoutsAdaptiveStart = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsAdaptiveStart.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsAdaptiveStart.setDescription('When the number of state entries exceeds this value, adaptive scaling begins.')
pfTimeoutsAdaptiveEnd = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsAdaptiveEnd.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsAdaptiveEnd.setDescription('When reaching this number of state entries, all timeout values become zero, effectively purging all state entries immediately.')
pfTimeoutsSrcNode = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsSrcNode.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsSrcNode.setDescription('Length of time to retain a source tracking entry after the last state expires.')
pfLogInterfaceName = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceName.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceName.setDescription("The name of the interface configured with 'set loginterface'. If no interface has been configured, the object will be empty.")
pfLogInterfaceIp4BytesIn = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp4BytesIn.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp4BytesIn.setDescription('Number of IPv4 bytes passed in on the loginterface.')
pfLogInterfaceIp4BytesOut = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp4BytesOut.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp4BytesOut.setDescription('Number of IPv4 bytes passed out on the loginterface.')
pfLogInterfaceIp4PktsInPass = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsInPass.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsInPass.setDescription('Number of IPv4 packets passed in on the loginterface.')
pfLogInterfaceIp4PktsInDrop = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsInDrop.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsInDrop.setDescription('Number of IPv4 packets dropped coming in on the loginterface.')
pfLogInterfaceIp4PktsOutPass = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsOutPass.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsOutPass.setDescription('Number of IPv4 packets passed out on the loginterface.')
pfLogInterfaceIp4PktsOutDrop = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsOutDrop.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsOutDrop.setDescription('Number of IPv4 packets dropped going out on the loginterface.')
pfLogInterfaceIp6BytesIn = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp6BytesIn.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp6BytesIn.setDescription('Number of IPv6 bytes passed in on the loginterface.')
pfLogInterfaceIp6BytesOut = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp6BytesOut.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp6BytesOut.setDescription('Number of IPv6 bytes passed out on the loginterface.')
pfLogInterfaceIp6PktsInPass = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsInPass.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsInPass.setDescription('Number of IPv6 packets passed in on the loginterface.')
pfLogInterfaceIp6PktsInDrop = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsInDrop.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsInDrop.setDescription('Number of IPv6 packets dropped coming in on the loginterface.')
pfLogInterfaceIp6PktsOutPass = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsOutPass.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsOutPass.setDescription('Number of IPv6 packets passed out on the loginterface.')
pfLogInterfaceIp6PktsOutDrop = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsOutDrop.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsOutDrop.setDescription('Number of IPv6 packets dropped going out on the loginterface.')
pfInterfacesIfNumber = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIfNumber.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfNumber.setDescription('The number of network interfaces on this system.')
pfInterfacesIfTable = MibTable((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2), )
if mibBuilder.loadTexts: pfInterfacesIfTable.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfTable.setDescription('Table of network interfaces, indexed on pfInterfacesIfNumber.')
pfInterfacesIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1), ).setIndexNames((0, "BEGEMOT-PF-MIB", "pfInterfacesIfIndex"))
if mibBuilder.loadTexts: pfInterfacesIfEntry.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfEntry.setDescription('An entry in the pfInterfacesIfTable containing information about a particular network interface in the machine.')
pfInterfacesIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pfInterfacesIfIndex.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfIndex.setDescription('A unique value, greater than zero, for each interface.')
pfInterfacesIfDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIfDescr.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfDescr.setDescription('The name of the interface.')
pfInterfacesIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("group", 0), ("instance", 1), ("detached", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIfType.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfType.setDescription('Indicates whether the interface is a group inteface, an interface instance, or whether it has been removed or destroyed.')
pfInterfacesIfTZero = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 4), TimeTicks()).setUnits('1/100th of a Second').setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIfTZero.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfTZero.setDescription('Time since statistics were last reset or since the interface was loaded.')
pfInterfacesIfRefsState = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIfRefsState.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfRefsState.setDescription('The number of state and/or source track entries referencing this interface.')
pfInterfacesIfRefsRule = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIfRefsRule.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfRefsRule.setDescription('The number of rules referencing this interface.')
pfInterfacesIf4BytesInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4BytesInPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4BytesInPass.setDescription('The number of IPv4 bytes passed coming in on this interface.')
pfInterfacesIf4BytesInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4BytesInBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4BytesInBlock.setDescription('The number of IPv4 bytes blocked coming in on this interface.')
pfInterfacesIf4BytesOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4BytesOutPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4BytesOutPass.setDescription('The number of IPv4 bytes passed going out on this interface.')
pfInterfacesIf4BytesOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4BytesOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4BytesOutBlock.setDescription('The number of IPv4 bytes blocked going out on this interface.')
pfInterfacesIf4PktsInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4PktsInPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4PktsInPass.setDescription('The number of IPv4 packets passed coming in on this interface.')
pfInterfacesIf4PktsInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4PktsInBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4PktsInBlock.setDescription('The number of IPv4 packets blocked coming in on this interface.')
pfInterfacesIf4PktsOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4PktsOutPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4PktsOutPass.setDescription('The number of IPv4 packets passed going out on this interface.')
pfInterfacesIf4PktsOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4PktsOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4PktsOutBlock.setDescription('The number of IPv4 packets blocked going out on this interface.')
pfInterfacesIf6BytesInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6BytesInPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6BytesInPass.setDescription('The number of IPv6 bytes passed coming in on this interface.')
pfInterfacesIf6BytesInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6BytesInBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6BytesInBlock.setDescription('The number of IPv6 bytes blocked coming in on this interface.')
pfInterfacesIf6BytesOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6BytesOutPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6BytesOutPass.setDescription('The number of IPv6 bytes passed going out on this interface.')
pfInterfacesIf6BytesOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6BytesOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6BytesOutBlock.setDescription('The number of IPv6 bytes blocked going out on this interface.')
pfInterfacesIf6PktsInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6PktsInPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6PktsInPass.setDescription('The number of IPv6 packets passed coming in on this interface.')
pfInterfacesIf6PktsInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6PktsInBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6PktsInBlock.setDescription('The number of IPv6 packets blocked coming in on this interface.')
pfInterfacesIf6PktsOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6PktsOutPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6PktsOutPass.setDescription('The number of IPv6 packets passed going out on this interface.')
pfInterfacesIf6PktsOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6PktsOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6PktsOutBlock.setDescription('The number of IPv6 packets blocked going out on this interface.')
pfTablesTblNumber = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblNumber.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblNumber.setDescription('The number of tables on this system.')
pfTablesTblTable = MibTable((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2), )
if mibBuilder.loadTexts: pfTablesTblTable.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblTable.setDescription('Table of tables, index on pfTablesTblIndex.')
pfTablesTblEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1), ).setIndexNames((0, "BEGEMOT-PF-MIB", "pfTablesTblIndex"))
if mibBuilder.loadTexts: pfTablesTblEntry.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblEntry.setDescription('Any entry in the pfTablesTblTable containing information about a particular table on the system.')
pfTablesTblIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pfTablesTblIndex.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblIndex.setDescription('A unique value, greater than zero, for each table.')
pfTablesTblDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblDescr.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblDescr.setDescription('The name of the table.')
pfTablesTblCount = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblCount.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblCount.setDescription('The number of addresses in the table.')
pfTablesTblTZero = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 4), TimeTicks()).setUnits('1/100th of a Second').setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblTZero.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblTZero.setDescription('The time passed since the statistics of this table were last cleared or the time since this table was loaded, whichever is sooner.')
pfTablesTblRefsAnchor = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblRefsAnchor.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblRefsAnchor.setDescription('The number of anchors referencing this table.')
pfTablesTblRefsRule = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblRefsRule.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblRefsRule.setDescription('The number of rules referencing this table.')
pfTablesTblEvalMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblEvalMatch.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblEvalMatch.setDescription('The number of evaluations returning a match.')
pfTablesTblEvalNoMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblEvalNoMatch.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblEvalNoMatch.setDescription('The number of evaluations not returning a match.')
pfTablesTblBytesInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblBytesInPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblBytesInPass.setDescription('The number of bytes passed in matching the table.')
pfTablesTblBytesInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblBytesInBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblBytesInBlock.setDescription('The number of bytes blocked coming in matching the table.')
pfTablesTblBytesInXPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblBytesInXPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblBytesInXPass.setDescription('The number of bytes statefully passed in where the state entry refers to the table, but the table no longer contains the address in question.')
pfTablesTblBytesOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblBytesOutPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblBytesOutPass.setDescription('The number of bytes passed out matching the table.')
pfTablesTblBytesOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblBytesOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblBytesOutBlock.setDescription('The number of bytes blocked going out matching the table.')
pfTablesTblBytesOutXPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblBytesOutXPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblBytesOutXPass.setDescription('The number of bytes statefully passed out where the state entry refers to the table, but the table no longer contains the address in question.')
pfTablesTblPktsInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblPktsInPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblPktsInPass.setDescription('The number of packets passed in matching the table.')
pfTablesTblPktsInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblPktsInBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblPktsInBlock.setDescription('The number of packets blocked coming in matching the table.')
pfTablesTblPktsInXPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblPktsInXPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblPktsInXPass.setDescription('The number of packets statefully passed in where the state entry refers to the table, but the table no longer contains the address in question.')
pfTablesTblPktsOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblPktsOutPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblPktsOutPass.setDescription('The number of packets passed out matching the table.')
pfTablesTblPktsOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblPktsOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblPktsOutBlock.setDescription('The number of packets blocked going out matching the table.')
pfTablesTblPktsOutXPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblPktsOutXPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblPktsOutXPass.setDescription('The number of packets statefully passed out where the state entry refers to the table, but the table no longer contains the address in question.')
pfTablesAddrTable = MibTable((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3), )
if mibBuilder.loadTexts: pfTablesAddrTable.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrTable.setDescription('Table of addresses from every table on the system.')
pfTablesAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1), ).setIndexNames((0, "BEGEMOT-PF-MIB", "pfTablesAddrIndex"))
if mibBuilder.loadTexts: pfTablesAddrEntry.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrEntry.setDescription('An entry in the pfTablesAddrTable containing information about a particular entry in a table.')
pfTablesAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pfTablesAddrIndex.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrIndex.setDescription('A unique value, greater than zero, for each address.')
pfTablesAddrNet = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrNet.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrNet.setDescription('The IP address of this particular table entry.')
pfTablesAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrMask.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrMask.setDescription('The CIDR netmask of this particular table entry.')
pfTablesAddrTZero = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 4), TimeTicks()).setUnits('1/100th of a Second').setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrTZero.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrTZero.setDescription("The time passed since this entry's statistics were last cleared, or the time passed since this entry was loaded into the table, whichever is sooner.")
pfTablesAddrBytesInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrBytesInPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrBytesInPass.setDescription('The number of inbound bytes passed as a result of this entry.')
pfTablesAddrBytesInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrBytesInBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrBytesInBlock.setDescription('The number of inbound bytes blocked as a result of this entry.')
pfTablesAddrBytesOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrBytesOutPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrBytesOutPass.setDescription('The number of outbound bytes passed as a result of this entry.')
pfTablesAddrBytesOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrBytesOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrBytesOutBlock.setDescription('The number of outbound bytes blocked as a result of this entry.')
pfTablesAddrPktsInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrPktsInPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrPktsInPass.setDescription('The number of inbound packets passed as a result of this entry.')
pfTablesAddrPktsInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrPktsInBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrPktsInBlock.setDescription('The number of inbound packets blocked as a result of this entry.')
pfTablesAddrPktsOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrPktsOutPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrPktsOutPass.setDescription('The number of outbound packets passed as a result of this entry.')
pfTablesAddrPktsOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrPktsOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrPktsOutBlock.setDescription('The number of outbound packets blocked as a result of this entry.')
pfAltqQueueNumber = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfAltqQueueNumber.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueNumber.setDescription('The number of queues in the active set.')
pfAltqQueueTable = MibTable((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2), )
if mibBuilder.loadTexts: pfAltqQueueTable.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueTable.setDescription('Table containing the rules that are active on this system.')
pfAltqQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1), ).setIndexNames((0, "BEGEMOT-PF-MIB", "pfAltqQueueIndex"))
if mibBuilder.loadTexts: pfAltqQueueEntry.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueEntry.setDescription('An entry in the pfAltqQueueTable table.')
pfAltqQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pfAltqQueueIndex.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueIndex.setDescription('A unique value, greater than zero, for each queue.')
pfAltqQueueDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfAltqQueueDescr.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueDescr.setDescription('The name of the queue.')
pfAltqQueueParent = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfAltqQueueParent.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueParent.setDescription("Name of the queue's parent if it has one.")
pfAltqQueueScheduler = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 8, 11))).clone(namedValues=NamedValues(("cbq", 1), ("hfsc", 8), ("priq", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfAltqQueueScheduler.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueScheduler.setDescription('Scheduler algorithm implemented by this queue.')
pfAltqQueueBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfAltqQueueBandwidth.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueBandwidth.setDescription('Bandwitch assigned to this queue.')
pfAltqQueuePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfAltqQueuePriority.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueuePriority.setDescription('Priority level of the queue.')
pfAltqQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfAltqQueueLimit.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueLimit.setDescription('Maximum number of packets in the queue.')
mibBuilder.exportSymbols("BEGEMOT-PF-MIB", pfTablesTblIndex=pfTablesTblIndex, pfLogInterfaceIp4PktsOutPass=pfLogInterfaceIp4PktsOutPass, pfTimeoutsTcpOpening=pfTimeoutsTcpOpening, pfStatusRunning=pfStatusRunning, pfStateTableCount=pfStateTableCount, pfSrcNodesSearches=pfSrcNodesSearches, pfCounterBadOffset=pfCounterBadOffset, pfStateTableSearches=pfStateTableSearches, pfTablesTblTable=pfTablesTblTable, pfInterfacesIf6PktsInPass=pfInterfacesIf6PktsInPass, pfInterfacesIf6BytesOutBlock=pfInterfacesIf6BytesOutBlock, pfTablesTblPktsOutPass=pfTablesTblPktsOutPass, pfLogInterfaceIp6BytesOut=pfLogInterfaceIp6BytesOut, pfStatusRuntime=pfStatusRuntime, pfLogInterfaceIp4PktsInDrop=pfLogInterfaceIp4PktsInDrop, pfInterfacesIf4PktsInBlock=pfInterfacesIf4PktsInBlock, pfAltqQueueParent=pfAltqQueueParent, pfInterfacesIfEntry=pfInterfacesIfEntry, pfTablesTblEvalNoMatch=pfTablesTblEvalNoMatch, pfTablesTblBytesOutPass=pfTablesTblBytesOutPass, PYSNMP_MODULE_ID=begemotPf, pfStatusHostId=pfStatusHostId, pfLogInterfaceIp4BytesOut=pfLogInterfaceIp4BytesOut, pfTablesAddrEntry=pfTablesAddrEntry, pfTablesTblPktsInXPass=pfTablesTblPktsInXPass, pfTimeoutsTcpClosing=pfTimeoutsTcpClosing, pfLogInterfaceIp6PktsOutDrop=pfLogInterfaceIp6PktsOutDrop, pfTablesTblBytesInPass=pfTablesTblBytesInPass, pfAltqQueueDescr=pfAltqQueueDescr, pfTimeoutsOtherFirst=pfTimeoutsOtherFirst, pfTablesTblBytesOutBlock=pfTablesTblBytesOutBlock, pfAltqQueueLimit=pfAltqQueueLimit, pfTablesTblPktsInBlock=pfTablesTblPktsInBlock, pfAltqQueueBandwidth=pfAltqQueueBandwidth, pfCounterMemDrop=pfCounterMemDrop, pfInterfacesIf6BytesInBlock=pfInterfacesIf6BytesInBlock, pfInterfaces=pfInterfaces, pfTimeoutsUdpFirst=pfTimeoutsUdpFirst, pfStateTable=pfStateTable, pfInterfacesIf4PktsOutBlock=pfInterfacesIf4PktsOutBlock, pfTimeoutsAdaptiveEnd=pfTimeoutsAdaptiveEnd, pfTablesTblEvalMatch=pfTablesTblEvalMatch, pfInterfacesIfNumber=pfInterfacesIfNumber, pfTablesTblRefsRule=pfTablesTblRefsRule, pfTimeoutsOtherMultiple=pfTimeoutsOtherMultiple, pfTimeoutsTcpFinWait=pfTimeoutsTcpFinWait, pfLogInterfaceIp6BytesIn=pfLogInterfaceIp6BytesIn, pfTablesTblPktsOutXPass=pfTablesTblPktsOutXPass, pfLimits=pfLimits, pfLogInterface=pfLogInterface, pfTimeoutsTcpEstablished=pfTimeoutsTcpEstablished, pfLogInterfaceIp6PktsInPass=pfLogInterfaceIp6PktsInPass, pfAltq=pfAltq, pfTablesTblBytesInXPass=pfTablesTblBytesInXPass, pfTablesTblTZero=pfTablesTblTZero, pfTablesTblRefsAnchor=pfTablesTblRefsAnchor, pfTablesAddrBytesInBlock=pfTablesAddrBytesInBlock, pfInterfacesIf4PktsOutPass=pfInterfacesIf4PktsOutPass, pfTimeoutsTcpClosed=pfTimeoutsTcpClosed, pfInterfacesIf6PktsOutPass=pfInterfacesIf6PktsOutPass, pfTablesAddrPktsInBlock=pfTablesAddrPktsInBlock, begemotPfObjects=begemotPfObjects, pfStateTableRemovals=pfStateTableRemovals, pfTablesAddrBytesInPass=pfTablesAddrBytesInPass, pfTablesTblPktsOutBlock=pfTablesTblPktsOutBlock, pfCounterFragment=pfCounterFragment, pfTimeoutsIcmpFirst=pfTimeoutsIcmpFirst, pfInterfacesIf4BytesOutPass=pfInterfacesIf4BytesOutPass, pfTablesAddrTable=pfTablesAddrTable, pfInterfacesIf4PktsInPass=pfInterfacesIf4PktsInPass, pfLogInterfaceIp6PktsInDrop=pfLogInterfaceIp6PktsInDrop, pfStatusDebug=pfStatusDebug, pfTimeouts=pfTimeouts, pfInterfacesIf4BytesOutBlock=pfInterfacesIf4BytesOutBlock, pfTablesAddrMask=pfTablesAddrMask, pfLogInterfaceIp4BytesIn=pfLogInterfaceIp4BytesIn, pfInterfacesIfTZero=pfInterfacesIfTZero, pfInterfacesIf6PktsOutBlock=pfInterfacesIf6PktsOutBlock, pfCounter=pfCounter, pfTablesAddrBytesOutPass=pfTablesAddrBytesOutPass, pfInterfacesIf6BytesInPass=pfInterfacesIf6BytesInPass, pfTimeoutsUdpSingle=pfTimeoutsUdpSingle, pfInterfacesIfRefsState=pfInterfacesIfRefsState, pfTables=pfTables, pfSrcNodesCount=pfSrcNodesCount, pfTimeoutsFragment=pfTimeoutsFragment, pfInterfacesIfDescr=pfInterfacesIfDescr, pfInterfacesIf6PktsInBlock=pfInterfacesIf6PktsInBlock, pfLogInterfaceIp4PktsOutDrop=pfLogInterfaceIp4PktsOutDrop, pfTablesTblEntry=pfTablesTblEntry, pfInterfacesIf4BytesInBlock=pfInterfacesIf4BytesInBlock, pfTablesAddrTZero=pfTablesAddrTZero, pfTimeoutsOtherSingle=pfTimeoutsOtherSingle, pfLogInterfaceIp4PktsInPass=pfLogInterfaceIp4PktsInPass, pfAltqQueuePriority=pfAltqQueuePriority, pfLogInterfaceIp6PktsOutPass=pfLogInterfaceIp6PktsOutPass, pfTimeoutsAdaptiveStart=pfTimeoutsAdaptiveStart, pfTimeoutsIcmpError=pfTimeoutsIcmpError, begemotPf=begemotPf, pfInterfacesIfIndex=pfInterfacesIfIndex, pfLimitsSrcNodes=pfLimitsSrcNodes, pfCounterMatch=pfCounterMatch, pfInterfacesIfType=pfInterfacesIfType, pfLimitsFrags=pfLimitsFrags, pfCounterNormalize=pfCounterNormalize, pfStateTableInserts=pfStateTableInserts, pfTimeoutsSrcNode=pfTimeoutsSrcNode, pfSrcNodes=pfSrcNodes, pfTimeoutsUdpMultiple=pfTimeoutsUdpMultiple, pfAltqQueueTable=pfAltqQueueTable, pfTablesTblPktsInPass=pfTablesTblPktsInPass, pfAltqQueueNumber=pfAltqQueueNumber, pfStatus=pfStatus, pfTablesTblNumber=pfTablesTblNumber, pfTablesAddrBytesOutBlock=pfTablesAddrBytesOutBlock, pfTablesAddrPktsOutBlock=pfTablesAddrPktsOutBlock, pfAltqQueueIndex=pfAltqQueueIndex, pfSrcNodesInserts=pfSrcNodesInserts, pfInterfacesIf4BytesInPass=pfInterfacesIf4BytesInPass, pfTablesTblDescr=pfTablesTblDescr, pfSrcNodesRemovals=pfSrcNodesRemovals, pfTablesTblCount=pfTablesTblCount, pfTablesAddrPktsInPass=pfTablesAddrPktsInPass, pfInterfacesIf6BytesOutPass=pfInterfacesIf6BytesOutPass, pfTablesTblBytesInBlock=pfTablesTblBytesInBlock, pfLimitsStates=pfLimitsStates, pfTablesAddrIndex=pfTablesAddrIndex, pfTimeoutsTcpFirst=pfTimeoutsTcpFirst, pfAltqQueueEntry=pfAltqQueueEntry, pfTablesAddrNet=pfTablesAddrNet, pfCounterShort=pfCounterShort, pfTimeoutsInterval=pfTimeoutsInterval, pfAltqQueueScheduler=pfAltqQueueScheduler, pfTablesTblBytesOutXPass=pfTablesTblBytesOutXPass, pfTablesAddrPktsOutPass=pfTablesAddrPktsOutPass, pfInterfacesIfTable=pfInterfacesIfTable, pfLogInterfaceName=pfLogInterfaceName, pfInterfacesIfRefsRule=pfInterfacesIfRefsRule)

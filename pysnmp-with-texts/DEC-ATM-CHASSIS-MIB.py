#
# PySNMP MIB module DEC-ATM-CHASSIS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DEC-ATM-CHASSIS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:37:23 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, TimeTicks, Counter32, Integer32, Counter64, NotificationType, ModuleIdentity, ObjectIdentity, Bits, iso, enterprises, MibIdentifier, IpAddress, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "TimeTicks", "Counter32", "Integer32", "Counter64", "NotificationType", "ModuleIdentity", "ObjectIdentity", "Bits", "iso", "enterprises", "MibIdentifier", "IpAddress", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
dec = MibIdentifier((1, 3, 6, 1, 4, 1, 36))
ema = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2))
decMIBextension = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18))
decAtmChassisMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 30))
decAtmChassisMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1))
decAtmSysGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 1))
decAtmSysType = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("an2", 2), ("gigaswitchAtm", 3), ("hubSwitch", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmSysType.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmSysType.setDescription('Indicates the overall type of chassis.')
decAtmKeyswitchPosition = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noKeyswitch", 1), ("fault", 2), ("secure", 3), ("local", 4), ("remote", 5), ("worldAccess", 6), ("unknown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmKeyswitchPosition.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmKeyswitchPosition.setDescription("Indicates the position of the keyswitch. The keyswitch position determines the type of access allowed to network management and to out-of-band management. For SNMP access, 'secure' means no SNMP access. 'Local' means read-only SNMP access. Other values allow read- write SNMP access. Access is still subject to community string, IP address, and privileged port restrictions. Now that I think about it, the 'secure' value (which was copied from GIGAswitch/FDDI) is silly. If the keyswitch is in that position, you will not be able to read <this> object (unless SNMP makes a special exception).")
decAtmSlot = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 2))
decAtmSlotNumber = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmSlotNumber.setDescription('The number of slots in the box.')
decAtmMasterLinecardSlot = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmMasterLinecardSlot.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmMasterLinecardSlot.setDescription('Identifies the slot that the master line card occupies. A value of 0 will be returned if a master has not been chosen, or if the concept of a master line card has no meaning for the chassis.')
decAtmStandbyLinecardSlot = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmStandbyLinecardSlot.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmStandbyLinecardSlot.setDescription('Identifies the slot which the standby master occupies. A value of 0 will be returned if a standby master has not been chosen, or if the concept of a standby master has no meaning for the chassis.')
decAtmSlotTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 2, 4), )
if mibBuilder.loadTexts: decAtmSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmSlotTable.setDescription('Describes the current configuration of the box.')
decAtmSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 2, 4, 1), ).setIndexNames((0, "DEC-ATM-CHASSIS-MIB", "decAtmSlotIndex"))
if mibBuilder.loadTexts: decAtmSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmSlotEntry.setDescription('Each entry contains the description and status of one linecard.')
decAtmSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmSlotIndex.setDescription('The slot number. Varies from 1 to decAtmSlotNumber.')
decAtmCardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notPresent", 1), ("powerDown", 2), ("powerUp", 3), ("powerDownThenUp", 4), ("fault", 5), ("revisionMismatch", 6), ("selfTestInProgress", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decAtmCardStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmCardStatus.setDescription("The status of the card. If the value is read as 'notPresent(1)', then the entire entry should be considered invalid. Writing a value of 'powerDown(2)' will cause the switch to power down the card. Writing a value of 'powerUp(3)' will cause the switch to power up the card. Writing a value of 'powerDownThenUp(4)' will cause the switch to power cycle the line card. Attempts to set any other values will result in a badValue error. Cards which are fundamental to switch operation cannot be powered up or down through this object. Unpopulated slots will either be 'notPresent(1)' or missing from the table, and cannot be powered up or down.")
decAtmCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("none", 1), ("other", 2), ("clockCard", 3), ("qlc10", 4), ("qlc15", 5), ("qlc16", 6), ("qlc20", 7), ("qlc622", 8), ("hubSwitch", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmCardType.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmCardType.setDescription('The type of the card.')
decAtmCardHasModPhys = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmCardHasModPhys.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmCardHasModPhys.setDescription('Indicates whether the linecard has modular physical connectors.')
decAtmCardHwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 2, 4, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmCardHwRev.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmCardHwRev.setDescription('The hardware revision of the card.')
decAtmCardFwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 2, 4, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmCardFwRev.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmCardFwRev.setDescription('The firmware revision of the card.')
decAtmCardFault = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 2, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmCardFault.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmCardFault.setDescription("Contains a diagnostic code which may aid in troubleshooting faulty cards. Meaningless if decAtmCardStatus is not equal to 'fault'.")
decAtmPort = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 3))
decAtmPortTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 3, 1), )
if mibBuilder.loadTexts: decAtmPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPortTable.setDescription('Describes the current configuration of the box.')
decAtmPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 3, 1, 1), ).setIndexNames((0, "DEC-ATM-CHASSIS-MIB", "decAtmSlotIndex"), (0, "DEC-ATM-CHASSIS-MIB", "decAtmPortIndex"))
if mibBuilder.loadTexts: decAtmPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPortEntry.setDescription('Each entry describes one physical port.')
decAtmPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPortIndex.setDescription('The port number. Varies from 1 to the number of ATM ports on the linecard.')
decAtmPortConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("other", 1), ("notPresent", 2), ("sts3cSingleModeFiber", 3), ("sts3cMultiModeFiber", 4), ("sts3cTwistedPair", 5), ("t3", 6), ("e3", 7), ("e1", 8), ("sts1TwistedPair", 9), ("e3Hdlc", 10), ("e3Proto", 11), ("sts12cSingleModeFiber", 12), ("sts12cMultiModeFiber", 13), ("t1", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPortConnector.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPortConnector.setDescription('The type of physical layer hardware currently in use by this ATM port.')
decAtmLed = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 4))
decAtmSlotLedTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 4, 1), )
if mibBuilder.loadTexts: decAtmSlotLedTable.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmSlotLedTable.setDescription('A list of LED entries, one for each module LED.')
decAtmSlotLedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 4, 1, 1), ).setIndexNames((0, "DEC-ATM-CHASSIS-MIB", "decAtmSlotIndex"), (0, "DEC-ATM-CHASSIS-MIB", "decAtmSlotLedIndex"))
if mibBuilder.loadTexts: decAtmSlotLedEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmSlotLedEntry.setDescription('Each entry describes the state of one module LED.')
decAtmSlotLedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmSlotLedIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmSlotLedIndex.setDescription("Secondary index which allows us to model cards with more than one module LED. The mapping between 'decAtmSlotLedIndex' and physical LEDs will be consistent for each 'decAtmCardType'.")
decAtmSlotLedDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 4, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmSlotLedDescr.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmSlotLedDescr.setDescription('A textual description of the information which the LED is meant to convey. i.e.: +5 Volt Power, DC Okay ATM port activity. Diagnostic status.')
decAtmSlotLedProgram = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 4, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmSlotLedProgram.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmSlotLedProgram.setDescription("The decAtmSlotLedProgram string is a sequence of instructions for the LED state. The LED constantly repeats the program. Each LED state is represented by a two octet sequence where the value of the first octet of the pair indicates the color of the LED, and the value of the second octet of the pair indicates the duration in which that color will be present. +----------+----------+ --/ /-- +----------+----------+ | Color | Duration | | Color | Duration | +----------+----------+ --/ /-- +----------+----------+ The 'color' octet may have one of the following values: 0 - off 1 - other 2 - red 3 - yellow 4 - green 5 - blue 6 - red-blinking 7 - yellow-blinking 8 - blue-blinking 9 - green-blinking The value 'off' indicates that the LED is off. The value 'other' indicates a color not covered by any others in the list. The value of the second octet in each pair indicates the duration in which that color will be present. A value of zero indicates that the LED is off. A value of 0xff indicates that the LED is always on. Values in between 0 and 0xff indicate the duration in 10 ms ticks. A zero length string may be returned if the LED is 'not present'. This indicates that the LED is currently not visible. Activity LEDs are a special case. Activity LEDs are defined as LEDs which blink whenever data is received on the line. They are typically on solid under heavy activity. Since these LEDs can change rapidly, the following rules apply: o The initial state of activity LEDs is off. o If the line shows activity any time in a 10 second period, then the LED is shown as on. o If the line shown inactivity any time in a 10 second period, then the LED is shown as off. See the 'pcomLedProgram' object in the DECHUB900-COMMON MIB for examples.")
decAtmPortLedTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 4, 2), )
if mibBuilder.loadTexts: decAtmPortLedTable.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPortLedTable.setDescription('A list of LED entries, one for each port LED.')
decAtmPortLedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 4, 2, 1), ).setIndexNames((0, "DEC-ATM-CHASSIS-MIB", "decAtmSlotIndex"), (0, "DEC-ATM-CHASSIS-MIB", "decAtmPortIndex"), (0, "DEC-ATM-CHASSIS-MIB", "decAtmPortLedIndex"))
if mibBuilder.loadTexts: decAtmPortLedEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPortLedEntry.setDescription('Each entry describes the state of one port LED.')
decAtmPortLedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPortLedIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPortLedIndex.setDescription('Secondary index which lets us model ports with multiple LEDs.')
decAtmPortLedDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPortLedDescr.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPortLedDescr.setDescription('A textual description of the information which the LED is meant to convey. i.e.: +5 Volt Power, DC Okay ATM port activity. Diagnostic status.')
decAtmPortLedProgram = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 4, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPortLedProgram.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPortLedProgram.setDescription("The decAtmLedProgram string is a sequence of instructions for the LED state. The LED constantly repeats the program. Each LED state is represented by a two octet sequence where the value of the first octet of the pair indicates the color of the LED, and the value of the second octet of the pair indicates the duration in which that color will be present. +----------+----------+ --/ /-- +----------+----------+ | Color | Duration | | Color | Duration | +----------+----------+ --/ /-- +----------+----------+ The 'color' octet may have one of the following values: 0 - off 1 - other 2 - red 3 - yellow 4 - green 5 - blue 6 - red-blinking 7 - yellow-blinking 8 - blue-blinking 9 - green-blinking The value 'off' indicates that the LED is off. The value 'other' indicates a color not covered by any others in the list. The value of the second octet in each pair indicates the duration in which that color will be present. A value of zero indicates that the LED is off. A value of 0xff indicates that the LED is always on. Values in between 0 and 0xff indicate the duration in 10 ms ticks. A zero length string may be returned if the LED is 'not present'. This indicates that the LED is currently not visible. Activity LEDs are a special case. Activity LEDs are defined as LEDs which blink whenever data is received on the line. They are typically on solid under heavy activity. Since these LEDs can change rapidly, the following rules apply: o The initial state of activity LEDs is off. o If the line shows activity any time in a 10 second period, then the LED is shown as on. o If the line shown inactivity any time in a 10 second period, then the LED is shown as off. See the 'pcomLedProgram' object in the DECHUB900-COMMON MIB for examples.")
decAtmLedInterestingChanges = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmLedInterestingChanges.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmLedInterestingChanges.setDescription('This counter may be polled to determine if any interesting changes in the decAtmSlotLedTable or decAtmPortLedTable have occurred.')
decAtmClockCard = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 5))
decAtmMgmtMemoryAvail = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmMgmtMemoryAvail.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmMgmtMemoryAvail.setDescription('The number of unused bytes of management memory available on the clock card. The management memory is used for storing management parameters.')
decAtmMgmtMemoryAction = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("rewrite", 2), ("rewriting", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decAtmMgmtMemoryAction.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmMgmtMemoryAction.setDescription('This object, when read, returns a value of other(1) unless the switch is in the middle of rewriting management memory. At such times, it will return rewriting(3). The state will revert to other(1) when the action is completed. Setting this variable to rewrite(2) will cause the switch to attempt to rewrite the management memory on the clock-card. Attempts to set this variable to all other values will result in an error. Rewriting the management memory gets rid of duplicate duplicate entries, and thus may increase the available space. This action should be allowed to complete before you intentionally remove power from the switch.')
decGigaAtmIntEthPktsSent = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decGigaAtmIntEthPktsSent.setStatus('mandatory')
if mibBuilder.loadTexts: decGigaAtmIntEthPktsSent.setDescription('The number of packets which the clock card has transmitted over the internal Ethernet.')
decGigaAtmIntEthPktsRcvd = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decGigaAtmIntEthPktsRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: decGigaAtmIntEthPktsRcvd.setDescription('The number of packets which the clock card has received from the internal Ethernet.')
decGigaAtmExtEthPktsSent = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 5, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decGigaAtmExtEthPktsSent.setStatus('mandatory')
if mibBuilder.loadTexts: decGigaAtmExtEthPktsSent.setDescription('The number of packets which the clock card has transmitted over the external Ethernet.')
decGigaAtmExtEthPktsRcvd = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 5, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decGigaAtmExtEthPktsRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: decGigaAtmExtEthPktsRcvd.setDescription('The number of packets which the clock card has received from the external Ethernet.')
decAtmPsc = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 6))
decAtmPscStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notPresent", 1), ("okay", 2), ("fault", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPscStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPscStatus.setDescription('The status of the Power System Controller (PSC).')
decAtmPscFwRev = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 6, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPscFwRev.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPscFwRev.setDescription('The firmware revision of the Power System Controller (PSC). This is only meaningful if the PSC is present.')
decAtmPscHwRev = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 6, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPscHwRev.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPscHwRev.setDescription('The hardware revision of the Power System Controller (PSC). This is only meaningful if the PSC is present.')
decAtmPscFwImageStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("okay", 1), ("downloadRequired", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPscFwImageStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPscFwImageStatus.setDescription('The status of the PSC firmware image. If the value of this object is downloadRequired(2), the manager should download a new firmware image to the PSC. This can be done by using objects in the gigaUpgradeSoftware group.')
decAtmPscBackplaneStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("okay", 1), ("fault", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPscBackplaneStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPscBackplaneStatus.setDescription('The status of the GIGAswitch backplane.')
decAtmPscFaultLedProgram = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 6, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPscFaultLedProgram.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPscFaultLedProgram.setDescription("The decAtmPscFaultLedProgram string is a sequence of instructions for the power supply controller fault LED state. The coding rules are as described for decAtmSlotLedProgram. A zero-length string may be returned if the LED is 'not present', or if the state of the LED is unknown.")
decAtmPowerSupply = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 7))
decAtmPowerSupplyTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 7, 1), )
if mibBuilder.loadTexts: decAtmPowerSupplyTable.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPowerSupplyTable.setDescription('A table describing all of the power supplies for this chassis.')
decAtmPowerSupplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 7, 1, 1), ).setIndexNames((0, "DEC-ATM-CHASSIS-MIB", "decAtmPowerIndex"))
if mibBuilder.loadTexts: decAtmPowerSupplyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPowerSupplyEntry.setDescription('Each table entry describes one power supply.')
decAtmPowerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPowerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPowerIndex.setDescription('A unique index identifying each power supply. For a GIGAswitch/ATM chassis, the left power supply unit always has index 1, and the right power supply unit always has index 2.')
decAtmPowerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notPresent", 1), ("okay", 2), ("fault", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPowerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPowerStatus.setDescription('The status of the power supply unit.')
decAtmPowerInputSource = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("acLine", 1), ("dc48V", 2), ("decHub", 3), ("none", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPowerInputSource.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPowerInputSource.setDescription("The input source of the power supply. A value of acLine(1) is returned if the power supply is connected to an AC line. A value of dc48V(2) is returned if the power supply is connected to a 48 volt DC (telecommunications) line. A value of decHub(3) is returned if the module's power is being provided by a DEChub900. A value of none(4) is returned if the power unit is not present or not powered on. See the batteryUsing object to see if the battery or this power source is being used. ")
decAtmPowerVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 7, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPowerVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPowerVoltage.setDescription('Voltage of power supply.')
decAtmPowerOutputInWatts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 7, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decAtmPowerOutputInWatts.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPowerOutputInWatts.setDescription("Output power of power supply, in watts. This is normally read-only. However, the full-sized GIGAswitch/ATM accepts both 15 and 20 amp supplies - and has no way of automatically determining which is installed. The agent may optionally permit write access to this object, in which case the following rules apply: To inform a GIGAswitch/ATM that it has a 20 amp power supply, write 1300 to this object. Warning: Don't do this until the new power supply is installed. Otherwise, the switch may crash and reboot. To inform a GIGAswitch/ATM that it has a 15 amp power supply, write 950 to this object. Warning: Note that this may cause line cards to be shut down, as the switch readjusts to the lower power budget. ")
decAtmPowerFaultLedProgram = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 7, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPowerFaultLedProgram.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPowerFaultLedProgram.setDescription("The decAtmPowerFaultLedProgram string is a sequence of instructions for the power supply fault LED state. The coding rules are as described for decAtmSlotLedProgram. A zero-length string may be returned if the LED is 'not present', or if the state of the LED is unknown.")
decAtmPowerOkLedProgram = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 7, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmPowerOkLedProgram.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmPowerOkLedProgram.setDescription("The decAtmPowerOkLedProgram string is a sequence of instructions for the power supply OK LED state. The coding rules are as described for decAtmSlotLedProgram. A zero-length string may be returned if the LED is 'not present', or if the state of the LED is unknown.")
decAtmBattery = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 8))
decAtmBatteryStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notPresent", 1), ("okay", 2), ("fault", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmBatteryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmBatteryStatus.setDescription('The status of the backup battery.')
decAtmBatteryUsing = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("batteryPower", 1), ("externalPower", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmBatteryUsing.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmBatteryUsing.setDescription('The source of power being used for the box. The value batteryPower(2) indicates that the backup battery unit is being used to power the switch. The external power line can be any standard power supply (e.g., either AC or 48V DC telecommunications power for GIGAswitch/ATM).')
decAtmBatteryCharge = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fullyCharged", 1), ("okay", 2), ("low", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmBatteryCharge.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmBatteryCharge.setDescription('The charge-level of the backup battery. Meaningful only if the battery is present.')
decAtmBatteryTest = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 8, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("pass", 1), ("fail", 2), ("test", 3), ("notTested", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decAtmBatteryTest.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmBatteryTest.setDescription('This shows the result of the last battery test performed. Testing the battery is risky -- the system is temporarily switched to run off the battery, so if the battery backup subsystem is not working, the system fails and restarts. Only the value test(3) can be written. Writes of other values are erroneous. This object is meaningful only if the battery is present.')
decAtmTemperature = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 9))
decAtmCabinetTemperature = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("normal", 1), ("high", 2), ("excessivelyHigh", 3), ("low", 4), ("excessivelyLow", 5), ("noSensor", 6), ("unknown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmCabinetTemperature.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmCabinetTemperature.setDescription("The cabinet temperature. Chassis types which do not have temperature sensors will always return 'noSensor(6)'.")
decAtmTemperatureWarning = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("heedWarning", 1), ("ignoreWarning", 2), ("noWarningFeature", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decAtmTemperatureWarning.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmTemperatureWarning.setDescription("The value of this variable determines how the switch will respond to a condition of too high or too low cabinet temperature, or a condition of all fans being inoperative. If the value is 'heedWarning(1)', the system will be shut down when the temperature goes outside the designed limits or when too many of its fans become inoperative. If the value is 'ignoreWarning(2)', the system will continue to operate when either of these conditions occur. Setting this variable to 'ignoreWarning(2)' lets a manager cause a system that is too hot or too cold to continue to run. This setting will also allow the system to run while no fans are operative. Managers should note that this may be detrimental to the equipment. This object has a default value of 'heedWarning(1)'. Note that some switches may lack auto-shutdown capability; they will have a value of 'noWarningFeature(3) for this object.")
decAtmTemperatureLedProgram = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 9, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmTemperatureLedProgram.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmTemperatureLedProgram.setDescription("The decAtmTemperatureLedProgram string is a sequence of instructions for the temperature LED state. The coding rules are as described for decAtmSlotLedProgram. A zero-length string may be returned if the LED is 'not present', or if the state of the LED is unknown.")
decAtmFan = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 10))
decAtmFanSpeed = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("maximum", 1), ("normal", 2), ("unknown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decAtmFanSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmFanSpeed.setDescription("The speed of the fans. Set this variable to 'maximum(1)' for maximum cooling where noise does not matter. Set this variable to normal(2) to cause fan speeds to be under temperature control.")
decAtmFanTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 10, 2), )
if mibBuilder.loadTexts: decAtmFanTable.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmFanTable.setDescription('A table describing all of the fans for this chassis.')
decAtmFanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 10, 2, 1), ).setIndexNames((0, "DEC-ATM-CHASSIS-MIB", "decAtmFanIndex"))
if mibBuilder.loadTexts: decAtmFanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmFanEntry.setDescription('Each table entry describes one fan.')
decAtmFanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmFanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmFanIndex.setDescription('A unique index identifying each fan. For a GIGAswitch/ATM chassis, the left fan tray always has an index of 1, while the right fan tray always has an index of 2.')
decAtmFanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notPresent", 1), ("okay", 2), ("fault", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmFanStatus.setDescription('The status of the fan.')
decAtmFanFaultLedProgram = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 10, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmFanFaultLedProgram.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmFanFaultLedProgram.setDescription("The decAtmFanFaultLedProgram string is a sequence of instructions for the fan tray fault LED state. The coding rules are as described for decAtmSlotLedProgram. A zero-length string may be returned if the LED is 'not present', or if the state of the LED is unknown.")
decAtmFppnTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 11), )
if mibBuilder.loadTexts: decAtmFppnTable.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmFppnTable.setDescription('A list of front panel port number to MIB-II interface number mappings.')
decAtmFppnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 11, 1), ).setIndexNames((0, "DEC-ATM-CHASSIS-MIB", "decAtmFppnSlotNumber"), (0, "DEC-ATM-CHASSIS-MIB", "decAtmFppnPortOfThatSlot"))
if mibBuilder.loadTexts: decAtmFppnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmFppnEntry.setDescription('Assigns the MIB-II interface ifIndex for a physical datalink (cable) connection to the box.')
decAtmFppnSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmFppnSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmFppnSlotNumber.setDescription('The 1-based slot number of the module.')
decAtmFppnPortOfThatSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmFppnPortOfThatSlot.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmFppnPortOfThatSlot.setDescription('The 1-based media connection to the module.')
decAtmFppnIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 11, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmFppnIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmFppnIfIndex.setDescription("The assigned MIB-II ifIndex. For an ATM port, this is the ifIndex of the 'atm' interface, as opposed to the index of the AAL5 entity or the physical (SONET, DS3) interface.")
decAtmUpgradeSoftware = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 12))
decAtmLoad = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 12, 1))
decAtmLoadAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("start-reboot", 2), ("start-read-BootP", 3), ("start-read-TFTP", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decAtmLoadAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmLoadAdminStatus.setDescription('This object is used to control the program load process of a device. When read, the value other(1) is returned. When set to start-reboot (2) the device reloads the stored firmware. When set to start-read-BootP(3) the device clears the address and host configuration file location in NVRAM and initiates a BootP read operation to find and read a new program image. When set to start-read-TFTP(4) the device saves the local host address and host configuration file location in NVRAM and initiates a TFTP read operation to read a new program image. A device always resets during a successful load attempt. It may not reset upon unsuccessful completion of the load attempt.')
decAtmLoadOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("success", 2), ("failure", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmLoadOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmLoadOperStatus.setDescription("The final state of the last load attempt. none(1) indicates that no load has been attempted, ever. This object is non-volatile. It's default value is none(1).")
decAtmLoadFilename = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 12, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decAtmLoadFilename.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmLoadFilename.setDescription("The name of the file in which to load. When the device is reading, this is the name of the file to be read. If the device can not check the file name then this object is ignored. The initial and default value is set by the 'bootp' operation.")
decAtmLoadIpHostAddr = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 12, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decAtmLoadIpHostAddr.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmLoadIpHostAddr.setDescription("The IP address of the host from which to load. When the device is reading, this is the IP address of the host in which the read will be directed. When the device is being written, this is the IP address of the only host in which writes will be accepted. This object is non-volatile. The initial and default value of this object is set by the 'bootp' operation.")
decAtmLoadDevSpecific = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 12, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decAtmLoadDevSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmLoadDevSpecific.setDescription('A device specific parameter which may be used to indicate detailed error information about the last attempted load. This object is non-volatile.')
decAtmConfigIpHostAddr = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 12, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decAtmConfigIpHostAddr.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmConfigIpHostAddr.setDescription("The IP address of the host from which to load. When the device is reading, this is the IP address of the host in which the read will be directed. When the device is being written, this is the IP address of the only host in which writes will be accepted. This object is non-volatile. The initial and default value of this object is set by the 'bootp' operation.")
decAtmConfigDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 12, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decAtmConfigDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmConfigDefaultGateway.setDescription("IP address of default gateway (router) to use if file IP address is off LAN. If this value is NOT set, no default will be used. this object is non-volatile. The initial and default value of this object is set by the 'bootp' operation.")
decAtmConfigFilename = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 12, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decAtmConfigFilename.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmConfigFilename.setDescription('The name of the file to read or write. When the device is reading, this is the name of the file to be read. When the device is being written, this is the only name of the file in which a write will be accepted - provided the device can check that the file does not exist. It is the duty of the NMS triggering the device to load this object.')
decAtmConfigStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 30, 1, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("other", 1), ("start-read", 2), ("start-write", 3), ("start-read-inprogress", 4), ("start-read-complete", 5), ("start-write-inprogress", 6), ("start-write-complete", 7), ("read-error", 8), ("write-error", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decAtmConfigStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decAtmConfigStatus.setDescription("This object is used to control the reading and writing of Nvram. When read, the value (1) is returned if no decAtmConfigStatus action has been initiated since the last reboot. If a 'start-read' operation has been initiated, then a 'start-read-inprogress' will be returned until the start-read is complete, then a 'start-read-complete' will be returned. If a 'start-write' operation has been initiated, then a 'start-write-inprogress' will be returned until the start-write is complete, then a 'start-write-complete' will be returned. When set to start-read(2) the device initiates a TFTP read operation to read the saved Nvram image. When set to start-write(3) the device checks to ensure that the file name that the Nvram image will be saved in does not exist. If this test is successful, a TFTP write operation will save the configuration.")
mibBuilder.exportSymbols("DEC-ATM-CHASSIS-MIB", decAtmChassisMIBObjects=decAtmChassisMIBObjects, decAtmCabinetTemperature=decAtmCabinetTemperature, decAtmCardType=decAtmCardType, decAtmCardFwRev=decAtmCardFwRev, decAtmPortLedDescr=decAtmPortLedDescr, decAtmBatteryCharge=decAtmBatteryCharge, decAtmPowerSupply=decAtmPowerSupply, decAtmPowerSupplyTable=decAtmPowerSupplyTable, decGigaAtmIntEthPktsSent=decGigaAtmIntEthPktsSent, decAtmFanEntry=decAtmFanEntry, decAtmFanTable=decAtmFanTable, decAtmPowerIndex=decAtmPowerIndex, decAtmMasterLinecardSlot=decAtmMasterLinecardSlot, decAtmPortConnector=decAtmPortConnector, decAtmLedInterestingChanges=decAtmLedInterestingChanges, decAtmSysType=decAtmSysType, decAtmCardHwRev=decAtmCardHwRev, decAtmPowerOkLedProgram=decAtmPowerOkLedProgram, decGigaAtmExtEthPktsSent=decGigaAtmExtEthPktsSent, decAtmBattery=decAtmBattery, decAtmCardHasModPhys=decAtmCardHasModPhys, decAtmPowerInputSource=decAtmPowerInputSource, decAtmPsc=decAtmPsc, decAtmFppnIfIndex=decAtmFppnIfIndex, decAtmSlotTable=decAtmSlotTable, decAtmPortIndex=decAtmPortIndex, decAtmLoadAdminStatus=decAtmLoadAdminStatus, decAtmCardFault=decAtmCardFault, decAtmSlotLedEntry=decAtmSlotLedEntry, decAtmFppnSlotNumber=decAtmFppnSlotNumber, decAtmPscFaultLedProgram=decAtmPscFaultLedProgram, decAtmBatteryStatus=decAtmBatteryStatus, decAtmPortLedProgram=decAtmPortLedProgram, decAtmSlot=decAtmSlot, decAtmLoadFilename=decAtmLoadFilename, decAtmPowerVoltage=decAtmPowerVoltage, decAtmMgmtMemoryAction=decAtmMgmtMemoryAction, decAtmConfigFilename=decAtmConfigFilename, decAtmConfigDefaultGateway=decAtmConfigDefaultGateway, decAtmPortEntry=decAtmPortEntry, decAtmPort=decAtmPort, decAtmConfigStatus=decAtmConfigStatus, decAtmSlotLedTable=decAtmSlotLedTable, decAtmTemperatureLedProgram=decAtmTemperatureLedProgram, decAtmPowerStatus=decAtmPowerStatus, decAtmPscBackplaneStatus=decAtmPscBackplaneStatus, decAtmSlotLedIndex=decAtmSlotLedIndex, decAtmFanIndex=decAtmFanIndex, decAtmTemperature=decAtmTemperature, decAtmLoad=decAtmLoad, decAtmFppnPortOfThatSlot=decAtmFppnPortOfThatSlot, decAtmPscFwRev=decAtmPscFwRev, decAtmSlotLedDescr=decAtmSlotLedDescr, decAtmSysGroup=decAtmSysGroup, decAtmLed=decAtmLed, decAtmFan=decAtmFan, decAtmFanFaultLedProgram=decAtmFanFaultLedProgram, decAtmBatteryUsing=decAtmBatteryUsing, decAtmPscFwImageStatus=decAtmPscFwImageStatus, decAtmLoadIpHostAddr=decAtmLoadIpHostAddr, decAtmFppnEntry=decAtmFppnEntry, decAtmBatteryTest=decAtmBatteryTest, decAtmPscHwRev=decAtmPscHwRev, decAtmSlotLedProgram=decAtmSlotLedProgram, decAtmPowerFaultLedProgram=decAtmPowerFaultLedProgram, decAtmMgmtMemoryAvail=decAtmMgmtMemoryAvail, decAtmStandbyLinecardSlot=decAtmStandbyLinecardSlot, decAtmPortLedEntry=decAtmPortLedEntry, decAtmClockCard=decAtmClockCard, decAtmPortLedIndex=decAtmPortLedIndex, decAtmPowerOutputInWatts=decAtmPowerOutputInWatts, decAtmLoadOperStatus=decAtmLoadOperStatus, decAtmSlotNumber=decAtmSlotNumber, decAtmCardStatus=decAtmCardStatus, decAtmPscStatus=decAtmPscStatus, decAtmUpgradeSoftware=decAtmUpgradeSoftware, decAtmPortTable=decAtmPortTable, decAtmChassisMIB=decAtmChassisMIB, decAtmFanSpeed=decAtmFanSpeed, dec=dec, decAtmFanStatus=decAtmFanStatus, decAtmFppnTable=decAtmFppnTable, decAtmKeyswitchPosition=decAtmKeyswitchPosition, decMIBextension=decMIBextension, decAtmLoadDevSpecific=decAtmLoadDevSpecific, decAtmSlotEntry=decAtmSlotEntry, decGigaAtmIntEthPktsRcvd=decGigaAtmIntEthPktsRcvd, decAtmSlotIndex=decAtmSlotIndex, ema=ema, decGigaAtmExtEthPktsRcvd=decGigaAtmExtEthPktsRcvd, decAtmConfigIpHostAddr=decAtmConfigIpHostAddr, decAtmPowerSupplyEntry=decAtmPowerSupplyEntry, decAtmTemperatureWarning=decAtmTemperatureWarning, decAtmPortLedTable=decAtmPortLedTable)

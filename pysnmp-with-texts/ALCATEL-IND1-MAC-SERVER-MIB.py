#
# PySNMP MIB module ALCATEL-IND1-MAC-SERVER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ALCATEL-IND1-MAC-SERVER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:18:32 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
hardentIND1Physical, = mibBuilder.importSymbols("ALCATEL-IND1-BASE", "hardentIND1Physical")
physicalIndex, = mibBuilder.importSymbols("ALCATEL-IND1-CHASSIS-MIB", "physicalIndex")
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
entPhysicalIndex, = mibBuilder.importSymbols("ENTITY-MIB", "entPhysicalIndex")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
Counter32, NotificationType, Integer32, Unsigned32, TimeTicks, Gauge32, ModuleIdentity, MibIdentifier, Bits, ObjectIdentity, iso, IpAddress, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "NotificationType", "Integer32", "Unsigned32", "TimeTicks", "Gauge32", "ModuleIdentity", "MibIdentifier", "Bits", "ObjectIdentity", "iso", "IpAddress", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
MacAddress, RowStatus, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "RowStatus", "DisplayString", "TextualConvention")
alcatelIND1MacServerMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3))
alcatelIND1MacServerMIB.setRevisions(('2010-05-13 00:00', '2007-04-03 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: alcatelIND1MacServerMIB.setRevisionsDescriptions(('Fixed the Notifications to use MIB Module OID.0 as Notifications root.', 'The MIB module for Chassis Supervision Mac Server entity.',))
if mibBuilder.loadTexts: alcatelIND1MacServerMIB.setLastUpdated('201005130000Z')
if mibBuilder.loadTexts: alcatelIND1MacServerMIB.setOrganization('Alcatel-Lucent, Enterprise Solutions Division')
if mibBuilder.loadTexts: alcatelIND1MacServerMIB.setContactInfo('Please consult with Customer Service to ensure the most appropriate version of this document is used with the products in question: Alcatel-Lucent, Enterprise Solutions Division (Formerly Alcatel Internetworking, Incorporated) 26801 West Agoura Road Agoura Hills, CA 91301-5122 United States Of America Telephone: North America +1 800 995 2696 Latin America +1 877 919 9526 Europe +31 23 556 0100 Asia +65 394 7933 All Other +1 818 878 4507 Electronic Mail: support@ind.alcatel.com World Wide Web: http://alcatel-lucent.com/wps/portal/enterprise File Transfer Protocol: ftp://ftp.ind.alcatel.com/pub/products/mibs')
if mibBuilder.loadTexts: alcatelIND1MacServerMIB.setDescription('This module describes an authoritative enterprise-specific Simple Network Management Protocol (SNMP) Management Information Base (MIB): For the Birds Of Prey Product Line, this is the Chassis Supervision MAC Server MIB for allocating MACs to applications (like routing). The right to make changes in specification and other information contained in this document without prior notice is reserved. No liability shall be assumed for any incidental, indirect, special, or consequential damages whatsoever arising from or related to this document or the information contained herein. Vendors, end-users, and other interested parties are granted non-exclusive license to use this specification in connection with management of the products for which it is intended to be used. Copyright (C) 1995-2007 Alcatel-Lucent ALL RIGHTS RESERVED WORLDWIDE')
alcatelIND1MacServerMIBNotifications = ObjectIdentity((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 0))
if mibBuilder.loadTexts: alcatelIND1MacServerMIBNotifications.setStatus('current')
if mibBuilder.loadTexts: alcatelIND1MacServerMIBNotifications.setDescription('Branch For Mac Server MIB Subsystem Notifications.')
alcatelIND1MacServerMIBObjects = ObjectIdentity((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1))
if mibBuilder.loadTexts: alcatelIND1MacServerMIBObjects.setStatus('current')
if mibBuilder.loadTexts: alcatelIND1MacServerMIBObjects.setDescription('Branch For Chassis Supervision MAC Server MIB Subsystem Managed Objects.')
alcatelIND1MacServerMIBConformance = ObjectIdentity((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 2))
if mibBuilder.loadTexts: alcatelIND1MacServerMIBConformance.setStatus('current')
if mibBuilder.loadTexts: alcatelIND1MacServerMIBConformance.setDescription('Branch For Chassis Supervision MAC Server MIB Subsystem Conformance Information.')
alcatelIND1MacServerMIBGroups = ObjectIdentity((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 2, 1))
if mibBuilder.loadTexts: alcatelIND1MacServerMIBGroups.setStatus('current')
if mibBuilder.loadTexts: alcatelIND1MacServerMIBGroups.setDescription('Branch For Chassis Supervision MAC Server MIB Subsystem Units Of Conformance.')
alcatelIND1MacServerMIBCompliances = ObjectIdentity((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 2, 2))
if mibBuilder.loadTexts: alcatelIND1MacServerMIBCompliances.setStatus('current')
if mibBuilder.loadTexts: alcatelIND1MacServerMIBCompliances.setDescription('Branch For Chassis Supervision MAC Server MIB Subsystem Compliance Statements.')
class MacAddrGlobalLocalStatusType(TextualConvention, Integer32):
    description = 'The MAC Address administration type'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("notApplicable", 1), ("globallyAdministered", 2), ("locallyAdministered", 3), ("globallyAdministeredOverlap", 4))

class MacRangeIndex(TextualConvention, Integer32):
    description = 'The MAC Address index value.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 20)

chasMacAddressRangeTable = MibTable((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 1), )
if mibBuilder.loadTexts: chasMacAddressRangeTable.setStatus('current')
if mibBuilder.loadTexts: chasMacAddressRangeTable.setDescription('Information about the MAC Address Ranges for a particular physical entity. This data is only available for the interfacing CMM.')
chasMacAddrRangeTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "ALCATEL-IND1-MAC-SERVER-MIB", "chasMacRangeIndex"))
if mibBuilder.loadTexts: chasMacAddrRangeTableEntry.setStatus('current')
if mibBuilder.loadTexts: chasMacAddrRangeTableEntry.setDescription('Definition of the MAC Address Ranges table entry for a particular physical entity. This data is only available for the interfacing CMM. There can be up to MacRangeIndex MAC ranges per physical entity. The chasMacAddressRangeTable on the Primary should be identical to the one on the Secondary. For creation of a MAC Address range, the following 4 fields in ChasMacAddrRangeTableEntry are required (must have all 4): chasMacAddressStart chasMacAddressCount chasGlobalLocal chasMacRowStatus : must be set last For deletion of a MAC Address range, the following 2 fields in ChasMacAddrRangeTableEntry are required (must have all 2): chasMacRangeIndex chasMacRowStatus : must be set last')
chasMacRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 1, 1, 1), MacRangeIndex())
if mibBuilder.loadTexts: chasMacRangeIndex.setStatus('current')
if mibBuilder.loadTexts: chasMacRangeIndex.setDescription('Represents the index of the MAC Address range.')
chasMacAddressStart = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 1, 1, 2), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chasMacAddressStart.setStatus('current')
if mibBuilder.loadTexts: chasMacAddressStart.setDescription('This is the starting MAC Address in the range. This field is required for the creation of a MAC Address range.')
chasMacAddressCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chasMacAddressCount.setStatus('current')
if mibBuilder.loadTexts: chasMacAddressCount.setDescription('This is the number of MAC addresses in the range. This field is required for the creation of a MAC Address range.')
chasGlobalLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 1, 1, 4), MacAddrGlobalLocalStatusType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chasGlobalLocal.setStatus('current')
if mibBuilder.loadTexts: chasGlobalLocal.setDescription(' Specifies whether the MAC Address/range is locally/globally administered. This field is required for the creation of a MAC Address range.')
chasMacRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chasMacRowStatus.setStatus('current')
if mibBuilder.loadTexts: chasMacRowStatus.setDescription('Row status for creating/deleting mac ranges.')
chasMacAddressAllocTable = MibTable((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 2), )
if mibBuilder.loadTexts: chasMacAddressAllocTable.setStatus('current')
if mibBuilder.loadTexts: chasMacAddressAllocTable.setDescription('Information specifying whether the MAC Address has been allocated for a particular Mac Range on a physical entity. This data is only available for the interfacing CMM.')
chasMacAddressAllocTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 2, 1), ).setIndexNames((0, "ALCATEL-IND1-MAC-SERVER-MIB", "chasAppId"), (0, "ALCATEL-IND1-MAC-SERVER-MIB", "chasObjectId"))
if mibBuilder.loadTexts: chasMacAddressAllocTableEntry.setStatus('current')
if mibBuilder.loadTexts: chasMacAddressAllocTableEntry.setDescription('Definition of the entry chasMacAddressAllocTable for a particular object managed by a particular application.')
chasAppId = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: chasAppId.setStatus('current')
if mibBuilder.loadTexts: chasAppId.setDescription('Represents the Id of the application requesting the allocation of a MAC Address.')
chasObjectId = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: chasObjectId.setStatus('current')
if mibBuilder.loadTexts: chasObjectId.setDescription('Represents the Id of the application requesting the allocation/ deallocation of a MAC Address.')
chasAllocMacRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 2, 1, 3), MacRangeIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasAllocMacRangeIndex.setStatus('current')
if mibBuilder.loadTexts: chasAllocMacRangeIndex.setDescription('Represents the object Id for which the MAC Address has been allocated /deallocated')
chasAllocMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 2, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasAllocMacAddress.setStatus('current')
if mibBuilder.loadTexts: chasAllocMacAddress.setDescription('This the Mac Address that has been allocated.')
chasAllocRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 2, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chasAllocRowStatus.setStatus('current')
if mibBuilder.loadTexts: chasAllocRowStatus.setDescription('Row status for allocating/deallocating a Mac address for a particular chaAppId/chasObjectId.')
chasMacAddrDupAllocStatusTable = MibIdentifier((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 3))
chasMacAddrDuplicationStatus = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasMacAddrDuplicationStatus.setStatus('current')
if mibBuilder.loadTexts: chasMacAddrDuplicationStatus.setDescription('Information specifying whether the MAC Address ranges from the EEPROM should be duplicated with the local bit set. This will provide additional ranges (locally administered ranges) for allocation. This data is only available for the interfacing CMM.')
chasMacAddrAllocLocallyAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasMacAddrAllocLocallyAdminStatus.setStatus('current')
if mibBuilder.loadTexts: chasMacAddrAllocLocallyAdminStatus.setDescription('Information specifying whether ONLY the locally administered MAC Address should be allocated. This data is only available for the interfacing CMM.')
chasMacAddrRetentionObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 4))
chasMacAddrRetentionStatus = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasMacAddrRetentionStatus.setStatus('current')
if mibBuilder.loadTexts: chasMacAddrRetentionStatus.setDescription('Information specifying the status of MAC Address retention functionality.')
chasPossibleDuplicateMacTrapStatus = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasPossibleDuplicateMacTrapStatus.setStatus('current')
if mibBuilder.loadTexts: chasPossibleDuplicateMacTrapStatus.setDescription('Information specifying the status of duplicate MAC address trap.')
chasRingStatus = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("present", 1), ("notPresent", 2))).clone('notPresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasRingStatus.setStatus('current')
if mibBuilder.loadTexts: chasRingStatus.setDescription('Information specifying the whether the ring is present in the stack or not.')
chasBaseMacAddrSource = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("retained", 1), ("eEPROM", 2))).clone('eEPROM')).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasBaseMacAddrSource.setStatus('current')
if mibBuilder.loadTexts: chasBaseMacAddrSource.setDescription('Information specifying the source of the currently used System base MAC.')
chasBaseMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 4, 5), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasBaseMacAddr.setStatus('current')
if mibBuilder.loadTexts: chasBaseMacAddr.setDescription('Base MAC address used in the system currently.')
chasBaseMacReleaseAction = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notSignificant", 0), ("releaseMac", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasBaseMacReleaseAction.setStatus('current')
if mibBuilder.loadTexts: chasBaseMacReleaseAction.setDescription('This object performs the action to release the retained base MAC address')
chasBaseMacAddrRetentionTimer = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 4, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasBaseMacAddrRetentionTimer.setStatus('current')
if mibBuilder.loadTexts: chasBaseMacAddrRetentionTimer.setDescription('This object specifies the time in minutes between the assumption of a retained MAC address and the generation of a log message and the duplicate MAC address trap')
alaMacServerTrapObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 5))
chasTrapMacRangeIndex = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 5, 1), MacRangeIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasTrapMacRangeIndex.setStatus('current')
if mibBuilder.loadTexts: chasTrapMacRangeIndex.setDescription('The mac range index of the involved object.')
baseMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 1, 5, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: baseMacAddress.setStatus('current')
if mibBuilder.loadTexts: baseMacAddress.setDescription('The base MAC Address.')
chassisTrapsMacOverlap = NotificationType((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 0, 1)).setObjects(("ALCATEL-IND1-CHASSIS-MIB", "physicalIndex"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasTrapMacRangeIndex"))
if mibBuilder.loadTexts: chassisTrapsMacOverlap.setStatus('current')
if mibBuilder.loadTexts: chassisTrapsMacOverlap.setDescription('A MAC range overlap was found in the backplane eeprom')
chassisTrapsPossibleDuplicateMac = NotificationType((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 0, 2)).setObjects(("ALCATEL-IND1-CHASSIS-MIB", "physicalIndex"), ("ALCATEL-IND1-MAC-SERVER-MIB", "baseMacAddress"))
if mibBuilder.loadTexts: chassisTrapsPossibleDuplicateMac.setStatus('current')
if mibBuilder.loadTexts: chassisTrapsPossibleDuplicateMac.setDescription('The old Master chassis cannot be detected in the VirtualChassis. There is a possiblity of duplicate MAC address in the network.')
chassisTrapsDuplicateMacCleared = NotificationType((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 0, 3)).setObjects(("ALCATEL-IND1-CHASSIS-MIB", "physicalIndex"), ("ALCATEL-IND1-MAC-SERVER-MIB", "baseMacAddress"))
if mibBuilder.loadTexts: chassisTrapsDuplicateMacCleared.setStatus('current')
if mibBuilder.loadTexts: chassisTrapsDuplicateMacCleared.setDescription('The old Master chassis has rejoined the VirtualChassis as a slave. There is no longer a possiblity of duplicate MAC address in the network.')
alcatelIND1MacServerMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 2, 2, 1)).setObjects(("ALCATEL-IND1-MAC-SERVER-MIB", "chasMacAddrRangeGroup"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasMacAddressAllocGroup"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasMacAddrDupAllocStatusGroup"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasTrapsMacOverlapGroup"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasMacAddrRetentionGroup"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasTrapsPossibleDuplicateMacGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    alcatelIND1MacServerMIBCompliance = alcatelIND1MacServerMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: alcatelIND1MacServerMIBCompliance.setDescription('Compliance statement for Chassis Supervision.')
chasMacAddrRangeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 2, 1, 1)).setObjects(("ALCATEL-IND1-MAC-SERVER-MIB", "chasMacAddressStart"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasMacAddressCount"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasGlobalLocal"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasMacRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    chasMacAddrRangeGroup = chasMacAddrRangeGroup.setStatus('current')
if mibBuilder.loadTexts: chasMacAddrRangeGroup.setDescription('Chassis Supervision MAC Address Range Group.')
chasMacAddressAllocGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 2, 1, 2)).setObjects(("ALCATEL-IND1-MAC-SERVER-MIB", "chasAllocMacRangeIndex"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasAllocMacAddress"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasAllocRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    chasMacAddressAllocGroup = chasMacAddressAllocGroup.setStatus('current')
if mibBuilder.loadTexts: chasMacAddressAllocGroup.setDescription('Chassis Supervision MAC Address Physical Allocation Group.')
chasMacAddrDupAllocStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 2, 1, 3)).setObjects(("ALCATEL-IND1-MAC-SERVER-MIB", "chasMacAddrDuplicationStatus"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasMacAddrAllocLocallyAdminStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    chasMacAddrDupAllocStatusGroup = chasMacAddrDupAllocStatusGroup.setStatus('current')
if mibBuilder.loadTexts: chasMacAddrDupAllocStatusGroup.setDescription('Chassis Supervision MAC Address Physical Duplication Allocation Status Group.')
chasTrapsMacOverlapGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 2, 1, 4)).setObjects(("ALCATEL-IND1-MAC-SERVER-MIB", "chassisTrapsMacOverlap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    chasTrapsMacOverlapGroup = chasTrapsMacOverlapGroup.setStatus('current')
if mibBuilder.loadTexts: chasTrapsMacOverlapGroup.setDescription('MAC range overlap Notification Group.')
chasMacAddrRetentionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 2, 1, 5)).setObjects(("ALCATEL-IND1-MAC-SERVER-MIB", "chasMacAddrRetentionStatus"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasPossibleDuplicateMacTrapStatus"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasRingStatus"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasBaseMacAddrSource"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasBaseMacAddr"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasBaseMacReleaseAction"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasBaseMacAddrRetentionTimer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    chasMacAddrRetentionGroup = chasMacAddrRetentionGroup.setStatus('current')
if mibBuilder.loadTexts: chasMacAddrRetentionGroup.setDescription('Chassis Supervision MAC Address Physical Duplication Allocation Status Group.')
chasTrapsPossibleDuplicateMacGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 2, 1, 6)).setObjects(("ALCATEL-IND1-MAC-SERVER-MIB", "chassisTrapsPossibleDuplicateMac"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chassisTrapsDuplicateMacCleared"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    chasTrapsPossibleDuplicateMacGroup = chasTrapsPossibleDuplicateMacGroup.setStatus('current')
if mibBuilder.loadTexts: chasTrapsPossibleDuplicateMacGroup.setDescription('Duplicate MAC address Notification Group.')
chasNotificationObjectGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6486, 801, 1, 1, 1, 1, 3, 2, 1, 7)).setObjects(("ALCATEL-IND1-MAC-SERVER-MIB", "baseMacAddress"), ("ALCATEL-IND1-MAC-SERVER-MIB", "chasTrapMacRangeIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    chasNotificationObjectGroup = chasNotificationObjectGroup.setStatus('current')
if mibBuilder.loadTexts: chasNotificationObjectGroup.setDescription('Chassis Supervision MAC Server notification object Status Group.')
mibBuilder.exportSymbols("ALCATEL-IND1-MAC-SERVER-MIB", alcatelIND1MacServerMIBGroups=alcatelIND1MacServerMIBGroups, chasMacAddrRetentionObjects=chasMacAddrRetentionObjects, alcatelIND1MacServerMIBCompliances=alcatelIND1MacServerMIBCompliances, chasBaseMacAddrRetentionTimer=chasBaseMacAddrRetentionTimer, chasMacAddrRetentionStatus=chasMacAddrRetentionStatus, chasMacAddressCount=chasMacAddressCount, chasObjectId=chasObjectId, chasPossibleDuplicateMacTrapStatus=chasPossibleDuplicateMacTrapStatus, chasMacAddrRangeTableEntry=chasMacAddrRangeTableEntry, chasBaseMacAddr=chasBaseMacAddr, alcatelIND1MacServerMIBCompliance=alcatelIND1MacServerMIBCompliance, chasAllocMacAddress=chasAllocMacAddress, chasMacAddrRetentionGroup=chasMacAddrRetentionGroup, chasMacAddressAllocTableEntry=chasMacAddressAllocTableEntry, chasMacAddressRangeTable=chasMacAddressRangeTable, chasBaseMacAddrSource=chasBaseMacAddrSource, chasNotificationObjectGroup=chasNotificationObjectGroup, chasMacAddressAllocTable=chasMacAddressAllocTable, MacRangeIndex=MacRangeIndex, chasMacAddrDuplicationStatus=chasMacAddrDuplicationStatus, chasTrapMacRangeIndex=chasTrapMacRangeIndex, alaMacServerTrapObjs=alaMacServerTrapObjs, chasGlobalLocal=chasGlobalLocal, chasRingStatus=chasRingStatus, chasBaseMacReleaseAction=chasBaseMacReleaseAction, chasTrapsMacOverlapGroup=chasTrapsMacOverlapGroup, chassisTrapsDuplicateMacCleared=chassisTrapsDuplicateMacCleared, chasMacAddrDupAllocStatusGroup=chasMacAddrDupAllocStatusGroup, chasAppId=chasAppId, chasAllocMacRangeIndex=chasAllocMacRangeIndex, chasMacAddressStart=chasMacAddressStart, chassisTrapsPossibleDuplicateMac=chassisTrapsPossibleDuplicateMac, chasTrapsPossibleDuplicateMacGroup=chasTrapsPossibleDuplicateMacGroup, chasMacAddressAllocGroup=chasMacAddressAllocGroup, chasMacRangeIndex=chasMacRangeIndex, chassisTrapsMacOverlap=chassisTrapsMacOverlap, alcatelIND1MacServerMIBConformance=alcatelIND1MacServerMIBConformance, chasMacAddrRangeGroup=chasMacAddrRangeGroup, chasMacAddrAllocLocallyAdminStatus=chasMacAddrAllocLocallyAdminStatus, alcatelIND1MacServerMIBNotifications=alcatelIND1MacServerMIBNotifications, chasMacRowStatus=chasMacRowStatus, chasMacAddrDupAllocStatusTable=chasMacAddrDupAllocStatusTable, alcatelIND1MacServerMIBObjects=alcatelIND1MacServerMIBObjects, baseMacAddress=baseMacAddress, PYSNMP_MODULE_ID=alcatelIND1MacServerMIB, alcatelIND1MacServerMIB=alcatelIND1MacServerMIB, chasAllocRowStatus=chasAllocRowStatus, MacAddrGlobalLocalStatusType=MacAddrGlobalLocalStatusType)

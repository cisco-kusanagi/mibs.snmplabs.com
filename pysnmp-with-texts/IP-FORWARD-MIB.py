#
# PySNMP MIB module IP-FORWARD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IP-FORWARD-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:17:56 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
IANAipRouteProtocol, = mibBuilder.importSymbols("IANA-RTPROTO-MIB", "IANAipRouteProtocol")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAutonomousSystemNumber, InetAddress, InetAddressType, InetAddressPrefixLength = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAutonomousSystemNumber", "InetAddress", "InetAddressType", "InetAddressPrefixLength")
ip, = mibBuilder.importSymbols("IP-MIB", "ip")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
IpAddress, MibIdentifier, NotificationType, Unsigned32, ModuleIdentity, Gauge32, Counter32, Counter64, ObjectIdentity, TimeTicks, Integer32, Bits, iso, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "MibIdentifier", "NotificationType", "Unsigned32", "ModuleIdentity", "Gauge32", "Counter32", "Counter64", "ObjectIdentity", "TimeTicks", "Integer32", "Bits", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
RowStatus, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "DisplayString", "TextualConvention")
ipForward = ModuleIdentity((1, 3, 6, 1, 2, 1, 4, 24))
ipForward.setRevisions(('2006-02-01 00:00', '1996-09-19 00:00', '1992-07-02 21:56',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ipForward.setRevisionsDescriptions(('IPv4/v6 version-independent revision. Minimal changes were made to the original RFC 2096 MIB, to allow easy upgrade of existing IPv4 implementations to the version-independent MIB. These changes include: Adding inetCidrRouteDiscards as a replacement for the deprecated ipRoutingDiscards and ipv6DiscardedRoutes objects. Adding a new conformance statement to support the implementation of the IP Forwarding MIB in a read-only mode. The inetCidrRouteTable replaces the IPv4-specific ipCidrRouteTable, its related objects, and related conformance statements. Published as RFC 4292.', 'Revised to support CIDR routes. Published as RFC 2096.', 'Initial version, published as RFC 1354.',))
if mibBuilder.loadTexts: ipForward.setLastUpdated('200602010000Z')
if mibBuilder.loadTexts: ipForward.setOrganization('IETF IPv6 Working Group http://www.ietf.org/html.charters/ipv6-charter.html')
if mibBuilder.loadTexts: ipForward.setContactInfo('Editor: Brian Haberman Johns Hopkins University - Applied Physics Laboratory Mailstop 17-S442 11100 Johns Hopkins Road Laurel MD, 20723-6099 USA Phone: +1-443-778-1319 Email: brian@innovationslab.net Send comments to <ipv6@ietf.org>')
if mibBuilder.loadTexts: ipForward.setDescription('The MIB module for the management of CIDR multipath IP Routes. Copyright (C) The Internet Society (2006). This version of this MIB module is a part of RFC 4292; see the RFC itself for full legal notices.')
inetCidrRouteNumber = MibScalar((1, 3, 6, 1, 2, 1, 4, 24, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inetCidrRouteNumber.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteNumber.setDescription('The number of current inetCidrRouteTable entries that are not invalid.')
inetCidrRouteDiscards = MibScalar((1, 3, 6, 1, 2, 1, 4, 24, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inetCidrRouteDiscards.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteDiscards.setDescription('The number of valid route entries discarded from the inetCidrRouteTable. Discarded route entries do not appear in the inetCidrRouteTable. One possible reason for discarding an entry would be to free-up buffer space for other route table entries.')
inetCidrRouteTable = MibTable((1, 3, 6, 1, 2, 1, 4, 24, 7), )
if mibBuilder.loadTexts: inetCidrRouteTable.setReference('RFC 1213 Section 6.6, The IP Group')
if mibBuilder.loadTexts: inetCidrRouteTable.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteTable.setDescription("This entity's IP Routing table.")
inetCidrRouteEntry = MibTableRow((1, 3, 6, 1, 2, 1, 4, 24, 7, 1), ).setIndexNames((0, "IP-FORWARD-MIB", "inetCidrRouteDestType"), (0, "IP-FORWARD-MIB", "inetCidrRouteDest"), (0, "IP-FORWARD-MIB", "inetCidrRoutePfxLen"), (0, "IP-FORWARD-MIB", "inetCidrRoutePolicy"), (0, "IP-FORWARD-MIB", "inetCidrRouteNextHopType"), (0, "IP-FORWARD-MIB", "inetCidrRouteNextHop"))
if mibBuilder.loadTexts: inetCidrRouteEntry.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteEntry.setDescription('A particular route to a particular destination, under a particular policy (as reflected in the inetCidrRoutePolicy object). Dynamically created rows will survive an agent reboot. Implementers need to be aware that if the total number of elements (octets or sub-identifiers) in inetCidrRouteDest, inetCidrRoutePolicy, and inetCidrRouteNextHop exceeds 111 then OIDs of column instances in this table will have more than 128 sub- identifiers and cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3.')
inetCidrRouteDestType = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 1), InetAddressType())
if mibBuilder.loadTexts: inetCidrRouteDestType.setReference('RFC 4001')
if mibBuilder.loadTexts: inetCidrRouteDestType.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteDestType.setDescription('The type of the inetCidrRouteDest address, as defined in the InetAddress MIB. Only those address types that may appear in an actual routing table are allowed as values of this object.')
inetCidrRouteDest = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 2), InetAddress())
if mibBuilder.loadTexts: inetCidrRouteDest.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteDest.setDescription('The destination IP address of this route. The type of this address is determined by the value of the inetCidrRouteDestType object. The values for the index objects inetCidrRouteDest and inetCidrRoutePfxLen must be consistent. When the value of inetCidrRouteDest (excluding the zone index, if one is present) is x, then the bitwise logical-AND of x with the value of the mask formed from the corresponding index object inetCidrRoutePfxLen MUST be equal to x. If not, then the index pair is not consistent and an inconsistentName error must be returned on SET or CREATE requests.')
inetCidrRoutePfxLen = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: inetCidrRoutePfxLen.setStatus('current')
if mibBuilder.loadTexts: inetCidrRoutePfxLen.setDescription('Indicates the number of leading one bits which form the mask to be logical-ANDed with the destination address before being compared to the value in the inetCidrRouteDest field. The values for the index objects inetCidrRouteDest and inetCidrRoutePfxLen must be consistent. When the value of inetCidrRouteDest (excluding the zone index, if one is present) is x, then the bitwise logical-AND of x with the value of the mask formed from the corresponding index object inetCidrRoutePfxLen MUST be equal to x. If not, then the index pair is not consistent and an inconsistentName error must be returned on SET or CREATE requests.')
inetCidrRoutePolicy = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 4), ObjectIdentifier())
if mibBuilder.loadTexts: inetCidrRoutePolicy.setStatus('current')
if mibBuilder.loadTexts: inetCidrRoutePolicy.setDescription('This object is an opaque object without any defined semantics. Its purpose is to serve as an additional index that may delineate between multiple entries to the same destination. The value { 0 0 } shall be used as the default value for this object.')
inetCidrRouteNextHopType = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 5), InetAddressType())
if mibBuilder.loadTexts: inetCidrRouteNextHopType.setReference('RFC 4001')
if mibBuilder.loadTexts: inetCidrRouteNextHopType.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteNextHopType.setDescription('The type of the inetCidrRouteNextHop address, as defined in the InetAddress MIB. Value should be set to unknown(0) for non-remote routes. Only those address types that may appear in an actual routing table are allowed as values of this object.')
inetCidrRouteNextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 6), InetAddress())
if mibBuilder.loadTexts: inetCidrRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteNextHop.setDescription('On remote routes, the address of the next system en route. For non-remote routes, a zero length string. The type of this address is determined by the value of the inetCidrRouteNextHopType object.')
inetCidrRouteIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 7), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteIfIndex.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteIfIndex.setDescription('The ifIndex value that identifies the local interface through which the next hop of this route should be reached. A value of 0 is valid and represents the scenario where no interface is specified.')
inetCidrRouteType = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("reject", 2), ("local", 3), ("remote", 4), ("blackhole", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteType.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteType.setDescription('The type of route. Note that local(3) refers to a route for which the next hop is the final destination; remote(4)refers to a route for which the next hop is not the final destination. Routes that do not result in traffic forwarding or rejection should not be displayed even if the implementation keeps them stored internally. reject(2) refers to a route that, if matched, discards the message as unreachable and returns a notification (e.g. ICMP error) to the message sender. This is used in some protocols as a means of correctly aggregating routes. blackhole(5) refers to a route which, if matched, discards the message silently.')
inetCidrRouteProto = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 9), IANAipRouteProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inetCidrRouteProto.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteProto.setDescription('The routing mechanism via which this route was learned. Inclusion of values for gateway routing protocols is not intended to imply that hosts should support those protocols.')
inetCidrRouteAge = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inetCidrRouteAge.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteAge.setDescription("The number of seconds since this route was last updated or otherwise determined to be correct. Note that no semantics of 'too old' can be implied except through knowledge of the routing protocol by which the route was learned.")
inetCidrRouteNextHopAS = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 11), InetAutonomousSystemNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteNextHopAS.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteNextHopAS.setDescription("The Autonomous System Number of the Next Hop. The semantics of this object are determined by the routing- protocol specified in the route's inetCidrRouteProto value. When this object is unknown or not relevant its value should be set to zero.")
inetCidrRouteMetric1 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 12), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteMetric1.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteMetric1.setDescription("The primary routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's inetCidrRouteProto value. If this metric is not used, its value should be set to -1.")
inetCidrRouteMetric2 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 13), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteMetric2.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteMetric2.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's inetCidrRouteProto value. If this metric is not used, its value should be set to -1.")
inetCidrRouteMetric3 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 14), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteMetric3.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteMetric3.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's inetCidrRouteProto value. If this metric is not used, its value should be set to -1.")
inetCidrRouteMetric4 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 15), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteMetric4.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteMetric4.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's inetCidrRouteProto value. If this metric is not used, its value should be set to -1.")
inetCidrRouteMetric5 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 16), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteMetric5.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteMetric5.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's inetCidrRouteProto value. If this metric is not used, its value should be set to -1.")
inetCidrRouteStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 17), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteStatus.setStatus('current')
if mibBuilder.loadTexts: inetCidrRouteStatus.setDescription('The row status variable, used according to row installation and removal conventions. A row entry cannot be modified when the status is marked as active(1).')
ipForwardConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 4, 24, 5))
ipForwardGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 4, 24, 5, 1))
ipForwardCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 4, 24, 5, 2))
ipForwardFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 4, 24, 5, 2, 3)).setObjects(("IP-FORWARD-MIB", "inetForwardCidrRouteGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipForwardFullCompliance = ipForwardFullCompliance.setStatus('current')
if mibBuilder.loadTexts: ipForwardFullCompliance.setDescription('When this MIB is implemented for read-create, the implementation can claim full compliance. There are a number of INDEX objects that cannot be represented in the form of OBJECT clauses in SMIv2, but for which there are compliance requirements, expressed in OBJECT clause form in this description: -- OBJECT inetCidrRouteDestType -- SYNTAX InetAddressType (ipv4(1), ipv6(2), -- ipv4z(3), ipv6z(4)) -- DESCRIPTION -- This MIB requires support for global and -- non-global ipv4 and ipv6 addresses. -- -- OBJECT inetCidrRouteDest -- SYNTAX InetAddress (SIZE (4 | 8 | 16 | 20)) -- DESCRIPTION -- This MIB requires support for global and -- non-global IPv4 and IPv6 addresses. -- -- OBJECT inetCidrRouteNextHopType -- SYNTAX InetAddressType (unknown(0), ipv4(1), -- ipv6(2), ipv4z(3) -- ipv6z(4)) -- DESCRIPTION -- This MIB requires support for global and -- non-global ipv4 and ipv6 addresses. -- -- OBJECT inetCidrRouteNextHop -- SYNTAX InetAddress (SIZE (0 | 4 | 8 | 16 | 20)) -- DESCRIPTION -- This MIB requires support for global and -- non-global IPv4 and IPv6 addresses. ')
ipForwardReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 4, 24, 5, 2, 4)).setObjects(("IP-FORWARD-MIB", "inetForwardCidrRouteGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipForwardReadOnlyCompliance = ipForwardReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: ipForwardReadOnlyCompliance.setDescription('When this MIB is implemented without support for read- create (i.e., in read-only mode), the implementation can claim read-only compliance.')
inetForwardCidrRouteGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 4, 24, 5, 1, 4)).setObjects(("IP-FORWARD-MIB", "inetCidrRouteDiscards"), ("IP-FORWARD-MIB", "inetCidrRouteIfIndex"), ("IP-FORWARD-MIB", "inetCidrRouteType"), ("IP-FORWARD-MIB", "inetCidrRouteProto"), ("IP-FORWARD-MIB", "inetCidrRouteAge"), ("IP-FORWARD-MIB", "inetCidrRouteNextHopAS"), ("IP-FORWARD-MIB", "inetCidrRouteMetric1"), ("IP-FORWARD-MIB", "inetCidrRouteMetric2"), ("IP-FORWARD-MIB", "inetCidrRouteMetric3"), ("IP-FORWARD-MIB", "inetCidrRouteMetric4"), ("IP-FORWARD-MIB", "inetCidrRouteMetric5"), ("IP-FORWARD-MIB", "inetCidrRouteStatus"), ("IP-FORWARD-MIB", "inetCidrRouteNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    inetForwardCidrRouteGroup = inetForwardCidrRouteGroup.setStatus('current')
if mibBuilder.loadTexts: inetForwardCidrRouteGroup.setDescription('The IP version-independent CIDR Route Table.')
ipCidrRouteNumber = MibScalar((1, 3, 6, 1, 2, 1, 4, 24, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCidrRouteNumber.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteNumber.setDescription('The number of current ipCidrRouteTable entries that are not invalid. This object is deprecated in favor of inetCidrRouteNumber and the inetCidrRouteTable.')
ipCidrRouteTable = MibTable((1, 3, 6, 1, 2, 1, 4, 24, 4), )
if mibBuilder.loadTexts: ipCidrRouteTable.setReference('RFC 1213 Section 6.6, The IP Group')
if mibBuilder.loadTexts: ipCidrRouteTable.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteTable.setDescription("This entity's IP Routing table. This table has been deprecated in favor of the IP version neutral inetCidrRouteTable.")
ipCidrRouteEntry = MibTableRow((1, 3, 6, 1, 2, 1, 4, 24, 4, 1), ).setIndexNames((0, "IP-FORWARD-MIB", "ipCidrRouteDest"), (0, "IP-FORWARD-MIB", "ipCidrRouteMask"), (0, "IP-FORWARD-MIB", "ipCidrRouteTos"), (0, "IP-FORWARD-MIB", "ipCidrRouteNextHop"))
if mibBuilder.loadTexts: ipCidrRouteEntry.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteEntry.setDescription('A particular route to a particular destination, under a particular policy.')
ipCidrRouteDest = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCidrRouteDest.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteDest.setDescription('The destination IP address of this route. This object may not take a Multicast (Class D) address value. Any assignment (implicit or otherwise) of an instance of this object to a value x must be rejected if the bitwise logical-AND of x with the value of the corresponding instance of the ipCidrRouteMask object is not equal to x.')
ipCidrRouteMask = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCidrRouteMask.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteMask.setDescription('Indicate the mask to be logical-ANDed with the destination address before being compared to the value in the ipCidrRouteDest field. For those systems that do not support arbitrary subnet masks, an agent constructs the value of the ipCidrRouteMask by reference to the IP Address Class. Any assignment (implicit or otherwise) of an instance of this object to a value x must be rejected if the bitwise logical-AND of x with the value of the corresponding instance of the ipCidrRouteDest object is not equal to ipCidrRouteDest.')
ipCidrRouteTos = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCidrRouteTos.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteTos.setDescription('The policy specifier is the IP TOS Field. The encoding of IP TOS is as specified by the following convention. Zero indicates the default path if no more specific policy applies. +-----+-----+-----+-----+-----+-----+-----+-----+ | | | | | PRECEDENCE | TYPE OF SERVICE | 0 | | | | | +-----+-----+-----+-----+-----+-----+-----+-----+ IP TOS IP TOS Field Policy Field Policy Contents Code Contents Code 0 0 0 0 ==> 0 0 0 0 1 ==> 2 0 0 1 0 ==> 4 0 0 1 1 ==> 6 0 1 0 0 ==> 8 0 1 0 1 ==> 10 0 1 1 0 ==> 12 0 1 1 1 ==> 14 1 0 0 0 ==> 16 1 0 0 1 ==> 18 1 0 1 0 ==> 20 1 0 1 1 ==> 22 1 1 0 0 ==> 24 1 1 0 1 ==> 26 1 1 1 0 ==> 28 1 1 1 1 ==> 30')
ipCidrRouteNextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCidrRouteNextHop.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteNextHop.setDescription('On remote routes, the address of the next system en route; Otherwise, 0.0.0.0.')
ipCidrRouteIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteIfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteIfIndex.setDescription('The ifIndex value that identifies the local interface through which the next hop of this route should be reached.')
ipCidrRouteType = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("reject", 2), ("local", 3), ("remote", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteType.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteType.setDescription('The type of route. Note that local(3) refers to a route for which the next hop is the final destination; remote(4) refers to a route for which the next hop is not the final destination. Routes that do not result in traffic forwarding or rejection should not be displayed even if the implementation keeps them stored internally. reject (2) refers to a route that, if matched, discards the message as unreachable. This is used in some protocols as a means of correctly aggregating routes.')
ipCidrRouteProto = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("isIs", 9), ("esIs", 10), ("ciscoIgrp", 11), ("bbnSpfIgp", 12), ("ospf", 13), ("bgp", 14), ("idpr", 15), ("ciscoEigrp", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCidrRouteProto.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteProto.setDescription('The routing mechanism via which this route was learned. Inclusion of values for gateway routing protocols is not intended to imply that hosts should support those protocols.')
ipCidrRouteAge = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCidrRouteAge.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteAge.setDescription("The number of seconds since this route was last updated or otherwise determined to be correct. Note that no semantics of `too old' can be implied except through knowledge of the routing protocol by which the route was learned.")
ipCidrRouteInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 9), ObjectIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteInfo.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol that is responsible for this route, as determined by the value specified in the route's ipCidrRouteProto value. If this information is not present, its value should be set to the OBJECT IDENTIFIER { 0 0 }, which is a syntactically valid object identifier, and any implementation conforming to ASN.1 and the Basic Encoding Rules must be able to generate and recognize this value.")
ipCidrRouteNextHopAS = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteNextHopAS.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteNextHopAS.setDescription("The Autonomous System Number of the Next Hop. The semantics of this object are determined by the routing- protocol specified in the route's ipCidrRouteProto value. When this object is unknown or not relevant its value should be set to zero.")
ipCidrRouteMetric1 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 11), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteMetric1.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteMetric1.setDescription("The primary routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's ipCidrRouteProto value. If this metric is not used, its value should be set to -1.")
ipCidrRouteMetric2 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 12), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteMetric2.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteMetric2.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's ipCidrRouteProto value. If this metric is not used, its value should be set to -1.")
ipCidrRouteMetric3 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 13), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteMetric3.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteMetric3.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's ipCidrRouteProto value. If this metric is not used, its value should be set to -1.")
ipCidrRouteMetric4 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 14), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteMetric4.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteMetric4.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's ipCidrRouteProto value. If this metric is not used, its value should be set to -1.")
ipCidrRouteMetric5 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 15), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteMetric5.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteMetric5.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's ipCidrRouteProto value. If this metric is not used, its value should be set to -1.")
ipCidrRouteStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 16), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteStatus.setStatus('deprecated')
if mibBuilder.loadTexts: ipCidrRouteStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
ipForwardCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 4, 24, 5, 2, 1)).setObjects(("IP-FORWARD-MIB", "ipForwardCidrRouteGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipForwardCompliance = ipForwardCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ipForwardCompliance.setDescription('The compliance statement for SNMPv2 entities that implement the ipForward MIB. This compliance statement has been deprecated and replaced with ipForwardFullCompliance and ipForwardReadOnlyCompliance.')
ipForwardCidrRouteGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 4, 24, 5, 1, 3)).setObjects(("IP-FORWARD-MIB", "ipCidrRouteNumber"), ("IP-FORWARD-MIB", "ipCidrRouteDest"), ("IP-FORWARD-MIB", "ipCidrRouteMask"), ("IP-FORWARD-MIB", "ipCidrRouteTos"), ("IP-FORWARD-MIB", "ipCidrRouteNextHop"), ("IP-FORWARD-MIB", "ipCidrRouteIfIndex"), ("IP-FORWARD-MIB", "ipCidrRouteType"), ("IP-FORWARD-MIB", "ipCidrRouteProto"), ("IP-FORWARD-MIB", "ipCidrRouteAge"), ("IP-FORWARD-MIB", "ipCidrRouteInfo"), ("IP-FORWARD-MIB", "ipCidrRouteNextHopAS"), ("IP-FORWARD-MIB", "ipCidrRouteMetric1"), ("IP-FORWARD-MIB", "ipCidrRouteMetric2"), ("IP-FORWARD-MIB", "ipCidrRouteMetric3"), ("IP-FORWARD-MIB", "ipCidrRouteMetric4"), ("IP-FORWARD-MIB", "ipCidrRouteMetric5"), ("IP-FORWARD-MIB", "ipCidrRouteStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipForwardCidrRouteGroup = ipForwardCidrRouteGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ipForwardCidrRouteGroup.setDescription('The CIDR Route Table. This group has been deprecated and replaced with inetForwardCidrRouteGroup.')
ipForwardNumber = MibScalar((1, 3, 6, 1, 2, 1, 4, 24, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardNumber.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardNumber.setDescription('The number of current ipForwardTable entries that are not invalid.')
ipForwardTable = MibTable((1, 3, 6, 1, 2, 1, 4, 24, 2), )
if mibBuilder.loadTexts: ipForwardTable.setReference('RFC 1213 Section 6.6, The IP Group')
if mibBuilder.loadTexts: ipForwardTable.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardTable.setDescription("This entity's IP Routing table.")
ipForwardEntry = MibTableRow((1, 3, 6, 1, 2, 1, 4, 24, 2, 1), ).setIndexNames((0, "IP-FORWARD-MIB", "ipForwardDest"), (0, "IP-FORWARD-MIB", "ipForwardProto"), (0, "IP-FORWARD-MIB", "ipForwardPolicy"), (0, "IP-FORWARD-MIB", "ipForwardNextHop"))
if mibBuilder.loadTexts: ipForwardEntry.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardEntry.setDescription('A particular route to a particular destination, under a particular policy.')
ipForwardDest = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardDest.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardDest.setDescription('The destination IP address of this route. An entry with a value of 0.0.0.0 is considered a default route. This object may not take a Multicast (Class D) address value. Any assignment (implicit or otherwise) of an instance of this object to a value x must be rejected if the bitwise logical-AND of x with the value of the corresponding instance of the ipForwardMask object is not equal to x.')
ipForwardMask = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardMask.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardMask.setDescription('Indicate the mask to be logical-ANDed with the destination address before being compared to the value in the ipForwardDest field. For those systems that do not support arbitrary subnet masks, an agent constructs the value of the ipForwardMask by reference to the IP Address Class. Any assignment (implicit or otherwise) of an instance of this object to a value x must be rejected if the bitwise logical-AND of x with the value of the corresponding instance of the ipForwardDest object is not equal to ipForwardDest.')
ipForwardPolicy = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardPolicy.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardPolicy.setDescription("The general set of conditions that would cause the selection of one multipath route (set of next hops for a given destination) is referred to as 'policy'. Unless the mechanism indicated by ipForwardProto specifies otherwise, the policy specifier is the IP TOS Field. The encoding of IP TOS is as specified by the following convention. Zero indicates the default path if no more specific policy applies. +-----+-----+-----+-----+-----+-----+-----+-----+ | | | | | PRECEDENCE | TYPE OF SERVICE | 0 | | | | | +-----+-----+-----+-----+-----+-----+-----+-----+ IP TOS IP TOS Field Policy Field Policy Contents Code Contents Code 0 0 0 0 ==> 0 0 0 0 1 ==> 2 0 0 1 0 ==> 4 0 0 1 1 ==> 6 0 1 0 0 ==> 8 0 1 0 1 ==> 10 0 1 1 0 ==> 12 0 1 1 1 ==> 14 1 0 0 0 ==> 16 1 0 0 1 ==> 18 1 0 1 0 ==> 20 1 0 1 1 ==> 22 1 1 0 0 ==> 24 1 1 0 1 ==> 26 1 1 1 0 ==> 28 1 1 1 1 ==> 30 Protocols defining 'policy' otherwise must either define a set of values that are valid for this object or must implement an integer-instanced policy table for which this object's value acts as an index.")
ipForwardNextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardNextHop.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardNextHop.setDescription('On remote routes, the address of the next system en route; otherwise, 0.0.0.0.')
ipForwardIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardIfIndex.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardIfIndex.setDescription('The ifIndex value that identifies the local interface through which the next hop of this route should be reached.')
ipForwardType = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("local", 3), ("remote", 4))).clone('invalid')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardType.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardType.setDescription('The type of route. Note that local(3) refers to a route for which the next hop is the final destination; remote(4) refers to a route for which the next hop is not the final destination. Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the ipForwardTable object. That is, it effectively disassociates the destination identified with said entry from the route identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use. Proper interpretation of such entries requires examination of the relevant ipForwardType object.')
ipForwardProto = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("is-is", 9), ("es-is", 10), ("ciscoIgrp", 11), ("bbnSpfIgp", 12), ("ospf", 13), ("bgp", 14), ("idpr", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardProto.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardProto.setDescription('The routing mechanism via which this route was learned. Inclusion of values for gateway routing protocols is not intended to imply that hosts should support those protocols.')
ipForwardAge = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardAge.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardAge.setDescription("The number of seconds since this route was last updated or otherwise determined to be correct. Note that no semantics of `too old' can be implied except through knowledge of the routing protocol by which the route was learned.")
ipForwardInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 9), ObjectIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardInfo.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol that is responsible for this route, as determined by the value specified in the route's ipForwardProto value. If this information is not present, its value should be set to the OBJECT IDENTIFIER { 0 0 }, which is a syntactically valid object identifier, and any implementation conforming to ASN.1 and the Basic Encoding Rules must be able to generate and recognize this value.")
ipForwardNextHopAS = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardNextHopAS.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardNextHopAS.setDescription('The Autonomous System Number of the Next Hop. When this is unknown or not relevant to the protocol indicated by ipForwardProto, zero.')
ipForwardMetric1 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 11), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardMetric1.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardMetric1.setDescription("The primary routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's ipForwardProto value. If this metric is not used, its value should be set to -1.")
ipForwardMetric2 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 12), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardMetric2.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardMetric2.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's ipForwardProto value. If this metric is not used, its value should be set to -1.")
ipForwardMetric3 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 13), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardMetric3.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardMetric3.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's ipForwardProto value. If this metric is not used, its value should be set to -1.")
ipForwardMetric4 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 14), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardMetric4.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardMetric4.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's ipForwardProto value. If this metric is not used, its value should be set to -1.")
ipForwardMetric5 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 15), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardMetric5.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardMetric5.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's ipForwardProto value. If this metric is not used, its value should be set to -1.")
ipForwardOldCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 4, 24, 5, 2, 2)).setObjects(("IP-FORWARD-MIB", "ipForwardMultiPathGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipForwardOldCompliance = ipForwardOldCompliance.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardOldCompliance.setDescription('The compliance statement for SNMP entities which implement the ipForward MIB.')
ipForwardMultiPathGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 4, 24, 5, 1, 2)).setObjects(("IP-FORWARD-MIB", "ipForwardNumber"), ("IP-FORWARD-MIB", "ipForwardDest"), ("IP-FORWARD-MIB", "ipForwardMask"), ("IP-FORWARD-MIB", "ipForwardPolicy"), ("IP-FORWARD-MIB", "ipForwardNextHop"), ("IP-FORWARD-MIB", "ipForwardIfIndex"), ("IP-FORWARD-MIB", "ipForwardType"), ("IP-FORWARD-MIB", "ipForwardProto"), ("IP-FORWARD-MIB", "ipForwardAge"), ("IP-FORWARD-MIB", "ipForwardInfo"), ("IP-FORWARD-MIB", "ipForwardNextHopAS"), ("IP-FORWARD-MIB", "ipForwardMetric1"), ("IP-FORWARD-MIB", "ipForwardMetric2"), ("IP-FORWARD-MIB", "ipForwardMetric3"), ("IP-FORWARD-MIB", "ipForwardMetric4"), ("IP-FORWARD-MIB", "ipForwardMetric5"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipForwardMultiPathGroup = ipForwardMultiPathGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ipForwardMultiPathGroup.setDescription('IP Multipath Route Table.')
mibBuilder.exportSymbols("IP-FORWARD-MIB", inetCidrRouteEntry=inetCidrRouteEntry, ipForward=ipForward, ipCidrRouteInfo=ipCidrRouteInfo, ipForwardProto=ipForwardProto, ipCidrRouteNextHop=ipCidrRouteNextHop, ipForwardNumber=ipForwardNumber, ipForwardMask=ipForwardMask, inetCidrRouteDest=inetCidrRouteDest, ipForwardMultiPathGroup=ipForwardMultiPathGroup, ipForwardType=ipForwardType, ipForwardNextHop=ipForwardNextHop, inetCidrRouteMetric4=inetCidrRouteMetric4, ipForwardNextHopAS=ipForwardNextHopAS, inetCidrRouteStatus=inetCidrRouteStatus, inetCidrRouteType=inetCidrRouteType, inetCidrRoutePolicy=inetCidrRoutePolicy, inetCidrRouteNextHop=inetCidrRouteNextHop, ipCidrRouteEntry=ipCidrRouteEntry, ipForwardCompliance=ipForwardCompliance, ipForwardMetric3=ipForwardMetric3, ipForwardInfo=ipForwardInfo, inetCidrRouteProto=inetCidrRouteProto, ipForwardPolicy=ipForwardPolicy, ipCidrRouteMask=ipCidrRouteMask, ipForwardOldCompliance=ipForwardOldCompliance, ipCidrRouteIfIndex=ipCidrRouteIfIndex, ipCidrRouteNumber=ipCidrRouteNumber, ipForwardEntry=ipForwardEntry, inetCidrRouteNextHopType=inetCidrRouteNextHopType, ipForwardConformance=ipForwardConformance, ipCidrRouteTos=ipCidrRouteTos, inetCidrRoutePfxLen=inetCidrRoutePfxLen, inetCidrRouteMetric2=inetCidrRouteMetric2, inetCidrRouteMetric3=inetCidrRouteMetric3, ipForwardCompliances=ipForwardCompliances, ipForwardFullCompliance=ipForwardFullCompliance, ipCidrRouteAge=ipCidrRouteAge, ipForwardTable=ipForwardTable, ipForwardReadOnlyCompliance=ipForwardReadOnlyCompliance, inetCidrRouteAge=inetCidrRouteAge, ipForwardGroups=ipForwardGroups, ipCidrRouteMetric5=ipCidrRouteMetric5, ipForwardIfIndex=ipForwardIfIndex, ipCidrRouteType=ipCidrRouteType, ipForwardMetric5=ipForwardMetric5, ipCidrRouteTable=ipCidrRouteTable, ipForwardAge=ipForwardAge, ipForwardMetric1=ipForwardMetric1, ipForwardMetric2=ipForwardMetric2, inetCidrRouteDiscards=inetCidrRouteDiscards, inetCidrRouteTable=inetCidrRouteTable, inetCidrRouteIfIndex=inetCidrRouteIfIndex, inetForwardCidrRouteGroup=inetForwardCidrRouteGroup, inetCidrRouteMetric1=inetCidrRouteMetric1, ipCidrRouteNextHopAS=ipCidrRouteNextHopAS, inetCidrRouteNumber=inetCidrRouteNumber, inetCidrRouteNextHopAS=inetCidrRouteNextHopAS, ipCidrRouteDest=ipCidrRouteDest, ipCidrRouteProto=ipCidrRouteProto, ipCidrRouteMetric3=ipCidrRouteMetric3, ipCidrRouteMetric4=ipCidrRouteMetric4, ipCidrRouteMetric1=ipCidrRouteMetric1, inetCidrRouteMetric5=inetCidrRouteMetric5, ipForwardMetric4=ipForwardMetric4, ipForwardCidrRouteGroup=ipForwardCidrRouteGroup, inetCidrRouteDestType=inetCidrRouteDestType, ipCidrRouteStatus=ipCidrRouteStatus, PYSNMP_MODULE_ID=ipForward, ipForwardDest=ipForwardDest, ipCidrRouteMetric2=ipCidrRouteMetric2)

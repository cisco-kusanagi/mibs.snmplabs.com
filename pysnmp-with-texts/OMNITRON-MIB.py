#
# PySNMP MIB module OMNITRON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/OMNITRON-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:34:02 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection")
omnitron, OstModeType, OstPortList, icAgent, OstVlanId, OstPortNumber = mibBuilder.importSymbols("OMNITRON-TC-MIB", "omnitron", "OstModeType", "OstPortList", "icAgent", "OstVlanId", "OstPortNumber")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Unsigned32, Integer32, TimeTicks, Counter32, ModuleIdentity, iso, IpAddress, Gauge32, Bits, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Integer32", "TimeTicks", "Counter32", "ModuleIdentity", "iso", "IpAddress", "Gauge32", "Bits", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Counter64")
TimeInterval, DisplayString, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TimeInterval", "DisplayString", "TruthValue", "TextualConvention")
omnitronMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 7342, 3))
omnitronMIB.setRevisions(('2015-10-21 12:00', '2015-01-19 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: omnitronMIB.setRevisionsDescriptions(('Added modHwRev and modPcbRev ', 'Initial version of v5.2 MIB. Updated resetmod and modreset to allow reboot from backup ',))
if mibBuilder.loadTexts: omnitronMIB.setLastUpdated('201510211200Z')
if mibBuilder.loadTexts: omnitronMIB.setOrganization('Omnitron Systems Technology, Inc.')
if mibBuilder.loadTexts: omnitronMIB.setContactInfo('Omnitron Systems Technology, Inc. 38 Tesla Irvine, CA 92618-4670 USA Tel: (949) 250 6510 Fax: (949) 250 6514 E-mail: info@omnitron-systems.com International: +1 949 250 6510 Technical Support and Customer Service Tel: (800) 675 8410 E-mail: support@omnitron-systems.com International: +1 949 250 6510')
if mibBuilder.loadTexts: omnitronMIB.setDescription('Omnitron MIB for use with v5.2 iConverter Management Modules and NetOutlook Copyright 2015 Omnitron Systems Technology, Inc. All rights reserved ')
prodAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 7342, 2))
omnitronConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 7342, 4))
omnitronProducts = MibIdentifier((1, 3, 6, 1, 4, 1, 7342, 5))
managementModule = MibIdentifier((1, 3, 6, 1, 4, 1, 7342, 5, 1))
chassis = MibScalar((1, 3, 6, 1, 4, 1, 7342, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassis.setStatus('current')
if mibBuilder.loadTexts: chassis.setDescription('Holds the chassis number of the selected IP')
selfSlot = MibScalar((1, 3, 6, 1, 4, 1, 7342, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: selfSlot.setStatus('current')
if mibBuilder.loadTexts: selfSlot.setDescription('Holds the slot number of the selected IP')
chassisTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 1, 1), )
if mibBuilder.loadTexts: chassisTable.setStatus('current')
if mibBuilder.loadTexts: chassisTable.setDescription('This a table of chassis and their modules.')
chassisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1), ).setIndexNames((0, "OMNITRON-MIB", "chassisnum"), (0, "OMNITRON-MIB", "slotnum"))
if mibBuilder.loadTexts: chassisEntry.setStatus('current')
if mibBuilder.loadTexts: chassisEntry.setDescription('Chassis modules.')
chassisnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisnum.setStatus('current')
if mibBuilder.loadTexts: chassisnum.setDescription('The chassis where the module resides. Ranges in value from 1 - 19.')
slotnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotnum.setStatus('current')
if mibBuilder.loadTexts: slotnum.setDescription('The slot number of the module. For the 19 slot chassis it ranges in value from 1-22. For the 2 slot chassis it ranges in value from 1-2.')
chassistype = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassistype.setStatus('current')
if mibBuilder.loadTexts: chassistype.setDescription('Type of chassis: 1 = 19 module chassis 2 = 2 module chassis 3 = 5 module chassis 4 = 1 module chassis 5 = stand alone chassis 6 = 1-module redundant power chassis')
prodtype = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prodtype.setStatus('current')
if mibBuilder.loadTexts: prodtype.setDescription('The product type of the module: 61 = iConverter NMM 64 = iConverter Power Supply (19 Module) 65 = iConverter 10FL/T Ethernet 66 = iConverter 100 Fx/Tx Ethernet 67 = iConverter Fiber/Fiber 68 = iConverter 10/100 Ethernet 70 = iConverter 2FXM slave 72 = iConverter GX/X 74 = iConverter Tx/2Tx Ethernet 75 = iConverter Gx Gigabit Ethernet 76 = iConverter Tx/2Fx Ethernet 77 = iConverter T1/E1 79 = iConverter 4Tx Ethernet 80 = iConverter 10/100M 81 = iConverter GX/T Ethernet 82 = iConverter Power Supply (5 Module) 83 = iConverter GX/F Ethernet 84 = iConverter 2FX Ethernet 85 = iConverter 10T/2 Ethernet 86 = iConverter 10/100VT Ethernet 87 = iConverter 4Tx VT 88 = iConverter RS 422/485 89 = iConverter T3/E3 90 = iConverter 10/100M slave 92 = iConverter RS 232 93 = iConverter GX/TM 94 = iConverter GX/TM slave 95 = iConverter 2GXM 96 = iConverter 2FXM 97 = iConverter GM3 2xSFP 98 = iConverter 2GXM slave 99 = iConverter GM3 2xUTP 100= iConverter 10/100M2 101= iConverter 2FXM2 102= iConverter GM3 SFP/2xUTP 103= iConverter 1-Module Redundant Powered Chassis 104= iConverter Gx AN 105= iConverter GX/TM2 106= iConverter 2GX/TM2 107= iConverter 4xT1/E1 Mux 108= iConverter GM3 2xSFP/UTP 109= iConverter GM3 3xSFP 110= iConverter X.21 112= iConverter GM3 3xUTP 113= iConverter GM3 FF/UTP or SFP/UTP 114= iConverter CWDM 115= iConverter XG 117= iConverter TM3 119= iConverter 4GT 120= iConverter GM4 2xSFP/TP 136= iConverter XGT+ 137= iConverter GM4 5-Port 142= iConverter GX/T2 143= iConverter GM4-HPoE or GM4-PoE+ 253= iConverter GM3 2XSFP 254= iConverter GM3 1xSFP/2xUTP 255= iConverter Unknown')
chassisname = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisname.setStatus('current')
if mibBuilder.loadTexts: chassisname.setDescription('The name of the chassis. For the M2 modules the max size is 32 octets. For the GM3, GM4, XM5 the max size is 64 octets when a module is accessed directly through the serial port, or via its own IP address for Telnet, SSH, or SNMP. For the GM3, GM4, XM5 when the object is indirectly accessed via the backplane, through IP-less, or through 802.3ah peer-to-peer the value is truncated to 32 bytes. ')
partnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: partnum.setStatus('current')
if mibBuilder.loadTexts: partnum.setDescription('The part number of the module.')
serialnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialnum.setStatus('current')
if mibBuilder.loadTexts: serialnum.setDescription('The serial number of the module.')
manufdate = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: manufdate.setStatus('current')
if mibBuilder.loadTexts: manufdate.setDescription('The date the module was manufactured in form YYYYMMDD.')
softrev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: softrev.setStatus('current')
if mibBuilder.loadTexts: softrev.setDescription('The software revision of the module software.')
prodrev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prodrev.setStatus('current')
if mibBuilder.loadTexts: prodrev.setDescription('The product revision of the module.')
ledstat = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ledstat.setStatus('current')
if mibBuilder.loadTexts: ledstat.setDescription('The status of any first 32 LEDs on the module, excluding the power LED. If an LED is missing its number is skipped. For an eight LED position device the following is the decoding: ledstat.7 is the top LED position ledstat.6 is the second LED position ledstat.5 is the third LED position ledstat.4 is the fourth LED position ledstat.3 is the fifth LED position ledstat.2 is the sixth LED position ledstat.1 is the seventh LED position ledstat.0 is the eighth and bottom LED position For devices that have 32 or less LEDs this object contains all the LEDs. For those devices that have more than 32 LEDs, LEDs 33 and above are only covered by the modExpLedStatus object. ')
switchstat = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchstat.setStatus('current')
if mibBuilder.loadTexts: switchstat.setDescription('The status of any DIP switches on the module. DIP switch 1 is switchstat.0, DIP switch 2 is switchstat.1, DIP switch 3 is switchstat.2, etc. DIP switch bank 1 is switches 0-7 DIP switch bank 2 is switches 8-15 Front panel switches start at switchstat.7 for the top switch, switchstat.6 for the next switch, etc.')
extended1 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: extended1.setStatus('current')
if mibBuilder.loadTexts: extended1.setDescription('General extended status for the module. Normally this is the actual setting of the DIP switch selection.')
extended2 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: extended2.setStatus('current')
if mibBuilder.loadTexts: extended2.setDescription('General extended status for the module')
extended3 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: extended3.setStatus('current')
if mibBuilder.loadTexts: extended3.setDescription('General extended status for the module')
extended4 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: extended4.setStatus('current')
if mibBuilder.loadTexts: extended4.setDescription('General extended status for the module')
extended5 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: extended5.setStatus('current')
if mibBuilder.loadTexts: extended5.setDescription('General extended status for the module')
extended6 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: extended6.setStatus('current')
if mibBuilder.loadTexts: extended6.setDescription('General extended status for the module')
resetmod = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resetmod.setStatus('current')
if mibBuilder.loadTexts: resetmod.setDescription('Writing to this variable resets the module. This variable is a write only. Writing a zero (0) will reboot to the current working application image Writing a one (1) will reboot to the backup application image if available ')
wrswitch = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrswitch.setStatus('current')
if mibBuilder.loadTexts: wrswitch.setDescription('Writing to this variable updates the module switch settings. See switchstat above for the explanation.')
modulename = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modulename.setStatus('current')
if mibBuilder.loadTexts: modulename.setDescription('The name of the module')
enhancedchassisTable = MibIdentifier((1, 3, 6, 1, 4, 1, 7342, 2, 1))
moduleCount = MibScalar((1, 3, 6, 1, 4, 1, 7342, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleCount.setStatus('current')
if mibBuilder.loadTexts: moduleCount.setDescription('The number of modules in the chassis table')
moduleTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2), )
if mibBuilder.loadTexts: moduleTable.setStatus('current')
if mibBuilder.loadTexts: moduleTable.setDescription('This a table of modules in the enhances chassis table. It contains as many entries as specified by moduleCount')
moduleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"))
if mibBuilder.loadTexts: moduleEntry.setStatus('current')
if mibBuilder.loadTexts: moduleEntry.setDescription('Chassis modules.')
modchassnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modchassnum.setStatus('current')
if mibBuilder.loadTexts: modchassnum.setDescription('The chassis where the module resides.')
modslotnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modslotnum.setStatus('current')
if mibBuilder.loadTexts: modslotnum.setDescription('The slot number within a chassis.')
modchasstype = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modchasstype.setStatus('current')
if mibBuilder.loadTexts: modchasstype.setDescription('The type of chassis in which the module resides.')
modprodtype = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modprodtype.setStatus('current')
if mibBuilder.loadTexts: modprodtype.setDescription('The chassis where the module resides.')
modsoftrev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modsoftrev.setStatus('current')
if mibBuilder.loadTexts: modsoftrev.setDescription('The modules software revision.')
modprodrev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modprodrev.setStatus('current')
if mibBuilder.loadTexts: modprodrev.setDescription('The modules product revision.')
modreset = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modreset.setStatus('current')
if mibBuilder.loadTexts: modreset.setDescription('Writing to this variable resets the module. This variable is a write only. Writing a zero (0) will reboot to the current working application image Writing a one (1) will reboot to the backup application image if available ')
modnumports = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modnumports.setStatus('current')
if mibBuilder.loadTexts: modnumports.setDescription('The number of ports in this module.')
modchassname = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modchassname.setStatus('current')
if mibBuilder.loadTexts: modchassname.setDescription('The name of the chassis in which the individual module resides in. For the M2 modules the max size is 32 octets. For the GM3, GM4, XM5 the max size is 64 octets when a module is accessed directly through the serial port, or via its own IP address for Telnet, SSH, or SNMP. For the GM3, GM4, XM5 when the object is indirectly accessed via the backplane, through IP-less, or through 802.3ah peer-to-peer the value is truncated to 32 bytes. ')
modpartnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modpartnum.setStatus('current')
if mibBuilder.loadTexts: modpartnum.setDescription('The model of the individual module.')
modserialnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: modserialnum.setStatus('current')
if mibBuilder.loadTexts: modserialnum.setDescription('The serial number of the individual module.')
modmanufdate = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: modmanufdate.setStatus('current')
if mibBuilder.loadTexts: modmanufdate.setDescription('The manufacturing date of the individual module.')
modname = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modname.setStatus('current')
if mibBuilder.loadTexts: modname.setDescription('The name of the individual module.')
modportvlan = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modportvlan.setStatus('current')
if mibBuilder.loadTexts: modportvlan.setDescription('The portvlan map of an individual module. The low order bits encode the possible values. The following are the connection paths that exists between the ports on the module: Used on types 69, 72, 81, 83, 84, 86 bit0 - Port 1 to Port 2 bit1 - Port 1 to Backplane Port A bit2 - Port 1 to Backplane Port B bit3 - Port 2 to Backplane Port A bit4 - Port 2 to Backplane Port B bit5 - Backplane Port A to Backplane Port B Used on types 70, 80, 90, 93, 94, 95, 96, 98, 100, 101, 105, 106 bit0 - Port 1 to Port 2 bit1 - Port 1 to Backplane Port A bit2 - Port 1 to Backplane Port B bit3 - Port 2 to Backplane Port A bit4 - Port 2 to Backplane Port B bit5 - Backplane Port A to Backplane Port B bit6 - Port 1 to Mgt bit7 - Port 2 to Mgt bit8 - Backplane A to Mgt bit9 - Backplane B to Mgt Used on types 102, 108, 109, 112 bit0 - Port 1-2-3 interconnect bit1 - Port 1-2-3 to Backplane Port A bit2 - Port 1-2-3 to Backplane Port B bit3 - Backplane Port A to Backplane Port B bit4 - Port 1 to Mgt bit5 - Port 2 to Mgt bit6 - Port 3 to Mgt bit7 - Backplane A to Mgt bit8 - Backplane B to Mgt Used on types 97, 99, 113 bit0 - Port 1 to Port 2 bit1 - Port 1 to Backplane Port A bit2 - Port 1 to Backplane Port B bit3 - Port 2 to Backplane Port A bit4 - Port 2 to Backplane Port B bit5 - Backplane Port A to Backplane Port B bit6 - Port 1 to Mgt bit7 - Port 2 to Mgt bit8 - Backplane A to Mgt bit9 - Backplane B to Mgt Used on types 79, 87 bit0 - Port 1-2-3-4 interconnect bit1 - Port 1-2-3-4 to backplane A bit2 - Port 1-2-3-4 to backplane B bite 3 Backplane A to Backplane B Used on type 103 bit0 - Port A to Backplane A bit1 - Port A to Backplane B bit2 - Port B to Backplane A bit3 - Port B to Backplane B bit4 - Port A to Port B')
modextfeaturebits = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modextfeaturebits.setStatus('current')
if mibBuilder.loadTexts: modextfeaturebits.setDescription("The module's extended features bits. The bit definitions are: bit0 - module is capable of being field upgradeable bit1 - module supports MIB Statistics bit2 - module supports Memory I/O extended registers bit3 - module supports Tag Vlan feature bit4 - module configured as Secure Slave bit5 - module configured as Secure Proxy bit6 - module configured as Secure Master bit7 - module supports 802.3ah OAM Client bit8 - module supports SFP parameters for port1 bit9 - module supports SFP parameters for port2 bit10 - module supports SFP parameters for port3 bit11 - module supports SFP parameters for port4 bit12 - module supports AH event notification bit13 - 1-module redundant power chassis supports contact closure status bit14 - 1-module redundant power chassis supports power over ethernet bit15 - 1-module redundant power chassis RJ45 connector is installed bit16 - 1-module redundant power chassis fan is installed bit17 - when this bit is on the module is a remote slave bit18 - module supports unidirectional on port1 bit19 - module supports unidirectional on port2 bit20 - module supports unidirectional on port3 bit21 - extended power supply bit22 - module supports SNMPv3 bit23 - module is NMM2 capable bit24 - fan is installed bit25 - generic module class supports 802.1ag/Y.1731 bit26 - module GM3 class supports 802.1ag/Y.1731 bit27 - module GM4 class bit28 - port 1 is an XFP port bit29 - port 2 is an XFP port ")
modswbuildnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modswbuildnum.setStatus('current')
if mibBuilder.loadTexts: modswbuildnum.setDescription("The module's software build number.")
modenable802dot1qProcessing = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modenable802dot1qProcessing.setStatus('current')
if mibBuilder.loadTexts: modenable802dot1qProcessing.setDescription('Enables or disables 802_1q processing. 0 = disable 1 = enable')
modtagsubstitution = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modtagsubstitution.setStatus('current')
if mibBuilder.loadTexts: modtagsubstitution.setDescription('Enables or disables substitution of 802_1q tags. Currently not implemented by any supported module')
modcommitVLANchanges = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modcommitVLANchanges.setStatus('current')
if mibBuilder.loadTexts: modcommitVLANchanges.setDescription('VLAN information is applied to the module and data saved to persistent storage. This variable is a write only.')
modvlanTableClear = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modvlanTableClear.setStatus('current')
if mibBuilder.loadTexts: modvlanTableClear.setDescription('VLAN table for the module Vlan table to be cleared. This variable is a write only.')
modcommitNMMCfgChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modcommitNMMCfgChanges.setStatus('current')
if mibBuilder.loadTexts: modcommitNMMCfgChanges.setDescription('Management module configuration information is applied to the module and data saved to persistent storage. This variable is a write only.')
modLM80volts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modLM80volts.setStatus('current')
if mibBuilder.loadTexts: modLM80volts.setDescription('8 bits each of PS1 Voltage(msB), PS2 Voltage, Total Voltage and an unused byte(lsB). 1-module redundant power chassis.')
modLM80currents = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modLM80currents.setStatus('current')
if mibBuilder.loadTexts: modLM80currents.setDescription('8 bits each of PS1 Current(msB) (mA/10), PS2 Current, Total Current and an unused byte(lsB). 1-module redundant power chassis.')
modLM80misc = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modLM80misc.setStatus('current')
if mibBuilder.loadTexts: modLM80misc.setDescription('8 bits each of Temperature(msB) .5C/bit and 2 unused byte(lsB). 1-module redundant power chassis.')
modRestoreFactoryDefaults = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modRestoreFactoryDefaults.setStatus('current')
if mibBuilder.loadTexts: modRestoreFactoryDefaults.setDescription('Management module configuration information is restored to factory defaults. This variable is a write only. Different types of restore defaults are supported: restoreFactoryDefaults(0,1) Restores factory defaults restoreLocalDefaults(2) Restores defaults from local file restorePreviousConfig(3) Restores the previously saved configuration. This is useful to regress to a known working setup. restoreFactoryDefaultsKeepIp(4) Restores factory defaults but keeps IP based settings restoreLocalDefaultsKeepIp(5) Restores defaults from local file but keeps IP based settings. restorePreviousConfigKeepIp(6) Restores the previously saved configuration but keeps IP based settings. ')
coreStatusOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: coreStatusOnly.setStatus('current')
if mibBuilder.loadTexts: coreStatusOnly.setDescription('Enable(1) or disable(0) Core Status Only.')
ingressPolicingType = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressPolicingType.setStatus('current')
if mibBuilder.loadTexts: ingressPolicingType.setDescription('Sets the module global policy used to count bytes for bandwidth calculation purposes. This is available on the GM3 & GM4. This is not available on the XM5. 1 = L1 includes all bytes in frame, interframe gap and preamble 2 = L2 includes all bytes in frame, including Layer 2 header and CRC 3 = L3 includes Layer 3 information only, excludes Layer 2 header and CRC ')
vlanservicetag = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 28), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanservicetag.setStatus('current')
if mibBuilder.loadTexts: vlanservicetag.setDescription('Value for service tag.')
defaultForwardingMap = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 29), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultForwardingMap.setStatus('current')
if mibBuilder.loadTexts: defaultForwardingMap.setDescription('Bit vector for default forwarding map where: bit0 - Port 1 bit1 - Port 2 bit2 - Port 3 bit3 - Port 4 bit4 - Port BPA bit5 - Port BPB')
modFpgaRev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modFpgaRev.setStatus('current')
if mibBuilder.loadTexts: modFpgaRev.setDescription('The current revision of the FPGA.')
modExpPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modExpPartNumber.setStatus('current')
if mibBuilder.loadTexts: modExpPartNumber.setDescription('The expanded part number of the individual module. The modpartnum object indicates the compressed version of the part number name. If this field is not supported in a module it is left as a null length string. ')
modExpSoftwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 32), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modExpSoftwareRev.setStatus('current')
if mibBuilder.loadTexts: modExpSoftwareRev.setDescription("The expanded software revision of the individual module. This object allows for an enhanced version of the software revision that include a major and minor component. Major and Minor are always numeric values while the rev value can be a number or an alpha. For instance: 1.0, 1.1, 3.2A, 1.1.2. The two digit modsoftrev object includes the major and minor revision. A modsoftrev of '32' would be shown in this object as '3.2'. This object allows the minor number to be expanded beyond a single digit as shown above by '3.2A' above, even though modsoftrev would be '32'. The modswbuildnum is independent of this scheme, but the complete revision is sometimes referred together as a concatenated value. For instance is '3.2A' is the sofware rev and '1234' is the build number, the concatenated value is '3.2A.1234'. ")
modExpLedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 33), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modExpLedStatus.setStatus('current')
if mibBuilder.loadTexts: modExpLedStatus.setDescription('This object is the expanded LED status of the individual module. This object reflects the state, color, and blinking rate of each individual LED. Each LED is represented by a single octet. The first octet in the string is the first LED, the second octet in the string is the second LED, until the last LED. The length of the object indicates the number of LEDs of the modules. Non-installed (missing) LEDs return a value of all zeros. Each octet is encoded in the following way: Bits 0:1 indicate the LED color and state 0x0 = LED is off 0x1 = LED is amber 0x2 = LED is green 0x3 = LED is both amber and green (red) Bits 2:4 indicate the LED blinking frequency 0x0 = LED is solid 0x1 = LED is blinking at 10 Hz 0x2 = LED is blinking at 5 Hz 0x3 = LED is blinking at 2 Hz 0x4 = LED is blinking at 1 Hz 0x5 = LED is blinking at 1/2 Hz Bits 5:7 are currently undefined and return 0x0 for this product revision. ')
modHwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 34), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modHwRev.setStatus('current')
if mibBuilder.loadTexts: modHwRev.setDescription('The current hardware revision of the module.')
modPcbRev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 35), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modPcbRev.setStatus('current')
if mibBuilder.loadTexts: modPcbRev.setDescription('The current PCB revision of the module.')
moduleMgtCfgTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3), )
if mibBuilder.loadTexts: moduleMgtCfgTable.setStatus('current')
if mibBuilder.loadTexts: moduleMgtCfgTable.setDescription('This is a table of the management module configuration variables.')
moduleMgtCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"))
if mibBuilder.loadTexts: moduleMgtCfgEntry.setStatus('current')
if mibBuilder.loadTexts: moduleMgtCfgEntry.setDescription('Chassis modules.')
sysAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysAdminStatus.setStatus('current')
if mibBuilder.loadTexts: sysAdminStatus.setDescription("This variable provides the status for a management module's ability to make changes to the system. In backplane slave, a management module cannot make system modification. Modifications must be performed from a management module acting as a backplane master. 0 = read only (can only view configuration settings) 1 = read-write (can view and modify configuration settings).")
sysDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(19, 19)).setFixedLength(19)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDateTime.setStatus('current')
if mibBuilder.loadTexts: sysDateTime.setDescription('This variable provides the date and time in display format: nn/dd/yyyy hh:mm:ss where nn = 2 digit month, dd = 2 digit day, yyyy = 4 digit year hh - 2 digit hour 0-23, mm = 2 digit minutes 0-59, ss = 2 digit secs 0-59')
macAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(17, 17)).setFixedLength(17)).setMaxAccess("readonly")
if mibBuilder.loadTexts: macAddr.setStatus('current')
if mibBuilder.loadTexts: macAddr.setDescription('MAC address of the management module')
ipAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipAddr.setStatus('current')
if mibBuilder.loadTexts: ipAddr.setDescription('IP of the management module')
subnetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: subnetmask.setStatus('current')
if mibBuilder.loadTexts: subnetmask.setDescription('subnetmask for the management module')
gateway = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gateway.setStatus('current')
if mibBuilder.loadTexts: gateway.setDescription('IP address for the gateway the management module will use.')
readCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: readCommunity.setStatus('current')
if mibBuilder.loadTexts: readCommunity.setDescription('SNMP read community name.')
writeCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: writeCommunity.setStatus('current')
if mibBuilder.loadTexts: writeCommunity.setDescription('SNMP set community name.')
mychassnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mychassnum.setStatus('current')
if mibBuilder.loadTexts: mychassnum.setDescription('NMMs chassis number.')
mmname = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mmname.setStatus('current')
if mibBuilder.loadTexts: mmname.setDescription('Management Modules chassis name. For the M2 modules the max size is 32 octets. For the GM3, GM4, XM5 the max size is 64 octets when a module is accessed directly through the serial port, or via its own IP address for Telnet, SSH, or SNMP. For the GM3, GM4, XM5 when the object is indirectly accessed via the backplane, through IP-less, or through 802.3ah peer-to-peer the value is truncated to 32 bytes. ')
traphost1 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost1.setStatus('current')
if mibBuilder.loadTexts: traphost1.setDescription('NMMs traphost1 IP address.')
traphost2 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost2.setStatus('current')
if mibBuilder.loadTexts: traphost2.setDescription('NMMs traphost2 IP address.')
traphost3 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 13), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost3.setStatus('current')
if mibBuilder.loadTexts: traphost3.setDescription('NMMs traphost3 IP address.')
traphost4 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 14), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost4.setStatus('current')
if mibBuilder.loadTexts: traphost4.setDescription('NMMs traphost4 IP address.')
traphost5 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 15), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost5.setStatus('current')
if mibBuilder.loadTexts: traphost5.setDescription('NMMs traphost5 IP address.')
traphost6 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 16), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost6.setStatus('current')
if mibBuilder.loadTexts: traphost6.setDescription('NMMs traphost6 IP address.')
traphost7 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 17), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost7.setStatus('current')
if mibBuilder.loadTexts: traphost7.setDescription('NMMs traphost7 IP address.')
traphost8 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 18), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost8.setStatus('current')
if mibBuilder.loadTexts: traphost8.setDescription('NMMs traphost8 IP address.')
sysloc = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysloc.setStatus('current')
if mibBuilder.loadTexts: sysloc.setDescription('Management Modules system location. For the M2 modules the max size is 32 octets. For the GM3, GM4, XM5 the max size is 64 octets when a module is accessed directly through the serial port, or via its own IP address for Telnet, SSH, or SNMP. For the GM3, GM4, XM5 when the object is indirectly accessed via the backplane, through IP-less, or through 802.3ah peer-to-peer the value is truncated to 32 bytes. ')
syscon = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syscon.setStatus('current')
if mibBuilder.loadTexts: syscon.setDescription('Management Modules system Contact information. For the M2 modules the max size is 32 octets. For the GM3, GM4, XM5 the max size is 64 octets when a module is accessed directly through the serial port, or via its own IP address for Telnet, SSH, or SNMP. For the GM3, GM4, XM5 when the object is indirectly accessed via the backplane, through IP-less, or through 802.3ah peer-to-peer the value is truncated to 32 bytes. ')
serialpass = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialpass.setStatus('current')
if mibBuilder.loadTexts: serialpass.setDescription('NMMs serial interface password.')
telnetpass = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: telnetpass.setStatus('current')
if mibBuilder.loadTexts: telnetpass.setDescription('NMMs telnet interface password.')
ftppasswrd = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ftppasswrd.setStatus('current')
if mibBuilder.loadTexts: ftppasswrd.setDescription('NMMs ftp password.')
keepAliveInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: keepAliveInterval.setStatus('current')
if mibBuilder.loadTexts: keepAliveInterval.setDescription('This the interval used by the NMM to send out keep alive traps.')
vlanIdOst = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 25), OstVlanId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanIdOst.setStatus('current')
if mibBuilder.loadTexts: vlanIdOst.setDescription('Management module VLAN tagged packet ID.')
nmmCfgSerialBaudrate = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmmCfgSerialBaudrate.setStatus('current')
if mibBuilder.loadTexts: nmmCfgSerialBaudrate.setDescription('This variable defines the baud rate for the serial interface to the NMM. Where: 1 = 300 bps 2 = 1200 bps 3 = 2400 bps 4 = 4800 bps 5 = 9600 bps 6 = 19200 bps 7 = 38400 bps 8 = 57600 bps 9 = 115200 bps')
enabledFunctions = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enabledFunctions.setStatus('current')
if mibBuilder.loadTexts: enabledFunctions.setDescription('This variable defines which special functions are enabled at the NMM. Where: 0x01 = Keep Alive trap enabled 0x02 = Telnet enabled 0x04 = FTP enabled 0x08 = switch reload enabled 0x10 = VLAN enabled 0x20 = sw1 block enabled 0x40 = DHCP client enabled 0x80 = Trap 99 processing enabled')
enableSNMPFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableSNMPFunction.setStatus('current')
if mibBuilder.loadTexts: enableSNMPFunction.setDescription('This variable defines whether the SNMP Agent is enabled at the NMM. Where: 00 = SNMP disabled 01 = SNMP enabled')
nmmCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nmmCfgState.setStatus('current')
if mibBuilder.loadTexts: nmmCfgState.setDescription('This variable defines the state of the configuration changes made to the NMM. Where: 0x00 = No changes 0x02 = Changes Pending (not saved in Flash) 0x04 = Saved in Flash, Pending NMM reboot')
nmmSecureMode = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmmSecureMode.setStatus('current')
if mibBuilder.loadTexts: nmmSecureMode.setDescription('This variable defines the mode the Management module will operate in when configured for SECURE COMMUNICATIONS. Where: 0x00 = No Secure Communications 0x01 = Secure Proxy 0x02 = Secure Slave 0x03 = Secure Master')
nmmSecureConnState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nmmSecureConnState.setStatus('current')
if mibBuilder.loadTexts: nmmSecureConnState.setDescription('This variable returns the secure connection state between the proxy and secure slave. Where: 0x00 = Not connected 0x01 = Connection Pending 0x02 = Connection established 0x03 = Connection terminating')
nmmIpProtocolState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nmmIpProtocolState.setStatus('current')
if mibBuilder.loadTexts: nmmIpProtocolState.setDescription('This variable defines whether the IP protocol is active or disabled. 0 = Active 1 = Disabled')
nmmIpDisabled = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmmIpDisabled.setStatus('current')
if mibBuilder.loadTexts: nmmIpDisabled.setDescription("This variable defines the configuration value for IP protocol's desired state. 0 = ipActive 1 = ipDisabled")
vlanPri = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPri.setStatus('current')
if mibBuilder.loadTexts: vlanPri.setDescription('Management module VLAN tagged packet priority.')
enableSNMPWrites = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableSNMPWrites.setStatus('current')
if mibBuilder.loadTexts: enableSNMPWrites.setDescription('Permit SNMP SET operations.')
cpuVoltageIn = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuVoltageIn.setStatus('current')
if mibBuilder.loadTexts: cpuVoltageIn.setDescription('voltage input to cpu.')
cpuVoltageOut = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuVoltageOut.setStatus('current')
if mibBuilder.loadTexts: cpuVoltageOut.setDescription('Voltage out from the cpu.')
cpuTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuTemperature.setStatus('current')
if mibBuilder.loadTexts: cpuTemperature.setDescription('The ambient temperature of the CPU.')
nmmSecureSlaveSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nmmSecureSlaveSlot.setStatus('current')
if mibBuilder.loadTexts: nmmSecureSlaveSlot.setDescription('The slot number of the secure slave in the remote chassis when configured for SECURE COMMUNICATIONS.')
dhcpIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 40), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpIpAddr.setStatus('current')
if mibBuilder.loadTexts: dhcpIpAddr.setDescription('IP of the management module as assigned by a DHCP server')
dhcpSubnetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 41), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSubnetmask.setStatus('current')
if mibBuilder.loadTexts: dhcpSubnetmask.setDescription('subnetmask of the management module as assigned by a DHCP server')
dhcpGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 42), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpGateway.setStatus('current')
if mibBuilder.loadTexts: dhcpGateway.setDescription('Gateway IP address of the management module as assigned by a DHCP Server')
nmmOAMmgmtMode = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmmOAMmgmtMode.setStatus('current')
if mibBuilder.loadTexts: nmmOAMmgmtMode.setDescription('This variable configures the protocol the Management module will use to communicate with remote chassis when operating in secure mode. Where: 0x01 = (OAM_OFF) No Secure Communications protocol 0x02 = (Auto SECURE_OAM) Use OST proprietary protocol, force remote to switch if not in the OAM_OFF mode 0x03 = (Auto AH_OAM) Use AH protocol, force remote to switch if not in the OAM_OFF mode 0x04 = (SECURE_OAM) Use OST proprietary protocol, remote is not forced to switch and must match modes to connect 0x05 = (AH_OAM) Use AH protocol, remote is not forced to switch and must match modes to connect')
customertag = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: customertag.setStatus('current')
if mibBuilder.loadTexts: customertag.setDescription('Value for customer tag.')
servicetag = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: servicetag.setStatus('current')
if mibBuilder.loadTexts: servicetag.setDescription('Value for service tag.')
cnodeControl = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnodeControl.setStatus('current')
if mibBuilder.loadTexts: cnodeControl.setDescription('Controls whether the module is operating as a Cnode.')
cnodeCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 47), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnodeCIR.setStatus('current')
if mibBuilder.loadTexts: cnodeCIR.setDescription('Cnode CIR Where: 1 = 64 Kbps 2 = 128 Kbps 3 = 192 Kbps')
enableSNMPv3Function = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 48), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableSNMPv3Function.setStatus('current')
if mibBuilder.loadTexts: enableSNMPv3Function.setDescription('This variable defines whether the SNMPv3 Agent is enabled at the NMM. Where: 00 = SNMP disabled 01 = SNMP enabled')
slaveWrite = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slaveWrite.setStatus('current')
if mibBuilder.loadTexts: slaveWrite.setDescription('This variable defines whether the module should be allowed to make configurations to itself when in the chassis slave mode. Where: 00 = slaveWrite disabled 01 = slaveWrite enabled')
snmpTrapType = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 50), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapType.setStatus('current')
if mibBuilder.loadTexts: snmpTrapType.setDescription('This variable defines which version of SNMP traps are supported, where: 1 = SNMPv1 traps 2 = SNMPv2c traps 3 = SNMPv3 traps')
capsMask = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 51), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: capsMask.setStatus('current')
if mibBuilder.loadTexts: capsMask.setDescription('Capablility bits for this management module.')
slaveTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slaveTraps.setStatus('current')
if mibBuilder.loadTexts: slaveTraps.setDescription('This variable defines whether the module should be allowed to transmit traps out ethernet ports eventhough it is not a chassis master. Where: 00 = slaveTraps disabled 01 = slaveTraps enabled')
slaveTrapsForward = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 53), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slaveTrapsForward.setStatus('current')
if mibBuilder.loadTexts: slaveTrapsForward.setDescription('This variable defines whether the module should be allowed to forward traps to the chassis master when module is a chassis slave. Default is forward. Where: 00 = slaveTrapsForward disabled 01 = slaveTrapsForward enabled')
ipAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 54), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipAddr2.setStatus('current')
if mibBuilder.loadTexts: ipAddr2.setDescription('IP 2 of the management module')
subnetmask2 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 55), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: subnetmask2.setStatus('current')
if mibBuilder.loadTexts: subnetmask2.setDescription('subnetmask 2 for the management module')
gateway2 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 56), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gateway2.setStatus('current')
if mibBuilder.loadTexts: gateway2.setDescription('IP address for the gateway 2 the management module will use.')
ipaddrEVCassociation = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 57), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 45))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipaddrEVCassociation.setStatus('current')
if mibBuilder.loadTexts: ipaddrEVCassociation.setDescription('*** This object is deprecated *** EVC associated with ipaddr 1. ')
ipaddr2EVCassociation = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 58), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 45))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipaddr2EVCassociation.setStatus('current')
if mibBuilder.loadTexts: ipaddr2EVCassociation.setDescription('*** This object is deprecated *** EVC associated with ipaddr 2. ')
bootpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 59), TruthValue().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpEnable.setStatus('current')
if mibBuilder.loadTexts: bootpEnable.setDescription('Enable or disable BOOTP.')
tftpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 60), TruthValue().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpEnable.setStatus('current')
if mibBuilder.loadTexts: tftpEnable.setDescription('Enable or disable TFTP.')
tftpServerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 61), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: tftpServerIpAddress.setDescription('TFTP server IP address.')
dhcptftpServerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 62), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcptftpServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: dhcptftpServerIpAddress.setDescription('TFTP Server IP address as assigned by a DHCP Server')
tftpFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 63), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 23))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpFileName.setStatus('current')
if mibBuilder.loadTexts: tftpFileName.setDescription('Selects the TFTP file name.')
modeType = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 64), OstModeType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modeType.setStatus('current')
if mibBuilder.loadTexts: modeType.setDescription('Sets the module Mode Type to normal, AP, or SP.')
dhcpPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 65), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPortNumber.setStatus('current')
if mibBuilder.loadTexts: dhcpPortNumber.setDescription('Sets the DHCP port number. 2 port module: 1=None, 2=Port 1, 3=Port 2, 4=BP A, 5=BP B 3 port module: 1=None, 2=Port 1, 3=Port 2, 4=Port 3, 5=BP A, 6=BP B 5 ports and higher modules: 1=None, 2..n+1 = Port 1..n ')
dhcpTagVid = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 66), OstVlanId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpTagVid.setStatus('current')
if mibBuilder.loadTexts: dhcpTagVid.setDescription('Sets the DHCP Tag VLAN ID.')
trapSrcIpSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 67), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapSrcIpSelect.setStatus('current')
if mibBuilder.loadTexts: trapSrcIpSelect.setDescription('Selects the trap source address, IP1(1) or IP2(2).')
muxGroupDefaults = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 68), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: muxGroupDefaults.setStatus('current')
if mibBuilder.loadTexts: muxGroupDefaults.setDescription("This object when written sets the Mux Grouping defaults for a management module. When read the value always returns 'false'. Writing this sets the Mux Group EVC and bandwidth profile configurations. ")
portFwdCpu = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 69), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("all", 0), ("port1", 1), ("port2", 2), ("backplaneA", 3), ("backplaneB", 4))).clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFwdCpu.setStatus('current')
if mibBuilder.loadTexts: portFwdCpu.setDescription('This object enables forwarding of managment traffic from the selected ports only for M2 modules only. Management traffic from ports not defined is dropped. all(0) Management traffic forwarded from all ports port1(1) Management traffic forwarded from Port 1 only port2(2) Management traffic forwarded from Port 2 only backplaneA(3) Management traffic forwarded from BP A only backplaneB(4) Management traffic forwarded from BP B only ')
portFwdCpuList = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 70), OstPortList().clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFwdCpuList.setStatus('current')
if mibBuilder.loadTexts: portFwdCpuList.setDescription('This object enables forwarding of managment traffic from the selected ports only for M3, M4, and M5 modules only. Management traffic from ports not defined is dropped. ')
modulePortsTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4), )
if mibBuilder.loadTexts: modulePortsTable.setStatus('current')
if mibBuilder.loadTexts: modulePortsTable.setDescription('This a table of Ports per module. There are as many entries as specified by modnumports in the moduleEntry')
modulePortsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"), (0, "OMNITRON-MIB", "portnum"))
if mibBuilder.loadTexts: modulePortsEntry.setStatus('current')
if mibBuilder.loadTexts: modulePortsEntry.setDescription('Ports per module table.')
portnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 1), OstPortNumber())
if mibBuilder.loadTexts: portnum.setStatus('current')
if mibBuilder.loadTexts: portnum.setDescription('Used to get or set state of port.')
portState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("undefined", 0), ("disabled", 1), ("enabled", 2), ("unused", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portState.setStatus('current')
if mibBuilder.loadTexts: portState.setDescription('Used to get or set state of port.')
portEgressRate = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEgressRate.setStatus('current')
if mibBuilder.loadTexts: portEgressRate.setDescription('Used to get or set the port throughput limit selection. The following are the limits are enforced by module type: Used on types 80, 96, 70, 90, 86, 84, 87 (lower limit=0, upper limit=7) where: 0 = 100 Mbps 1 = 128 kbps 2 = 256 kbps 3 = 512 kbps 4 = 1 Mbps 5 = 2 Mbps 6 = 4 Mbps 7 = 8 Mbps Used on types 100, 101 (lower limit=1, upper limit=20) where: 1 = 64 kbps 2 = 128 kbps 3 = 256 kbps 4 = 512 kbps 5 = 768 kbps 6 = 1 Mbps 7 = 2 Mbps 8 = 3 Mbps 9 = 4 Mbps 10 = 5 Mbps 11 = 6 Mbps 12 = 7 Mbps 13 = 8 Mbps 14 = 9 Mbps 15 = 10 Mbps 16 = 20 Mbps 17 = 30 Mbps 18 = 40 Mbps 19 = 50 Mbps 20 = 100 Mbps Used on types 105, 106 (lower limit=1, upper limit=33) 1 = 64 kbps 2 = 128 kbps 3 = 256 kbps 4 = 512 kbps 5 = 768 kbps 6 = 1 Mbps 7 = 2 Mbps 8 = 3 Mbps 9 = 4 Mbps 10 = 5 Mbps 11 = 6 Mbps 12 = 7 Mbps 13 = 8 Mbps 14 = 9 Mbps 15 = 10 Mbps 16 = 20 Mbps 17 = 30 Mbps 18 = 40 Mbps 19 = 50 Mbps 20 = 60 Mbps 21 = 70 Mbps 22 = 80 Mbps 23 = 90 Mbps 24 = 100 Mbps 25 = 200 Mbps 26 = 300 Mbps 27 = 400 Mbps 28 = 500 Mbps 29 = 600 Mbps 30 = 700 Mbps 31 = 800 Mbps 32 = 900 Mbps 33 = 1000 Mbps Types 97, 99, 102, 108, 109, 112, 113 use numeric values in kpbs with a lower limit of 64 and an upper limit of 1,000,000. Types not listed have no limit.')
portpriority = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portpriority.setStatus('current')
if mibBuilder.loadTexts: portpriority.setDescription('Used to get or set port user-priority.')
portcanonicalformatIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portcanonicalformatIndicator.setStatus('current')
if mibBuilder.loadTexts: portcanonicalformatIndicator.setDescription('Used to get or set port cfi. Currently not used and defaulted to 0')
portvlanidentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portvlanidentifier.setStatus('current')
if mibBuilder.loadTexts: portvlanidentifier.setDescription('Used to get or set port VID.')
portmlistcriteria = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portmlistcriteria.setStatus('current')
if mibBuilder.loadTexts: portmlistcriteria.setDescription('Used to get or set port membership criteria.')
portingresssecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portingresssecurity.setStatus('current')
if mibBuilder.loadTexts: portingresssecurity.setDescription('Used to get or set port ingress security.')
portegresspolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portegresspolicy.setStatus('current')
if mibBuilder.loadTexts: portegresspolicy.setDescription('Used to get or set port egress policy.')
portIngressRate = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portIngressRate.setStatus('current')
if mibBuilder.loadTexts: portIngressRate.setDescription('Used to get or set the port throughput limit selection. The following are the limits are enforced by module type: Used on types 80, 96, 70, 90, 86, 84, 87 (lower limit=0, upper limit=7) where: 0 = 100 Mbps 1 = 128 kbps 2 = 256 kbps 3 = 512 kbps 4 = 1 Mbps 5 = 2 Mbps 6 = 4 Mbps 7 = 8 Mbps Used on types 100, 101 (lower limit=64, upper limit=100,000) Values are number of kbps per second, i.e. rate = value x 1000, units in bps Used on types 97, 99, 102, 105, 106, 108, 109, 112, 113 (lower limit=64, upper limit=1,000,000) Values are number of kbps per second, i.e. rate = value x 1000, units in bps Types not listed have no limit.')
portSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSpeed.setStatus('current')
if mibBuilder.loadTexts: portSpeed.setDescription('Used to get the port speed. 0 = undefined 1 = speed10Mbps 2 = speed100Mbps 3 = speed1Gbps 4 = speed10Gbps')
portUnidirectionalAhOamEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portUnidirectionalAhOamEnable.setStatus('current')
if mibBuilder.loadTexts: portUnidirectionalAhOamEnable.setDescription('Used to get/set the unidirectional support. 0 = uniDisabled 1 = uniEnabled')
portIngressRateDropOrPause = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portIngressRateDropOrPause.setStatus('current')
if mibBuilder.loadTexts: portIngressRateDropOrPause.setDescription('Used to get/set behavior on overflow. 0 = undefined 1 = inDrop 2 = inPause')
portIngressRateCBS = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 256000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portIngressRateCBS.setStatus('current')
if mibBuilder.loadTexts: portIngressRateCBS.setDescription('Used to get or set the port throughput limit selection.')
portL2CPmgntProcessing = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portL2CPmgntProcessing.setStatus('current')
if mibBuilder.loadTexts: portL2CPmgntProcessing.setDescription('Used to get or set the port L2Cp processing method. 0 = undefined 1 = inDrop 2 = inForward 3 = inTunnel')
portEgressQosPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEgressQosPolicy.setStatus('current')
if mibBuilder.loadTexts: portEgressQosPolicy.setDescription('Used to get or set the port egress QoS Policy. 0 = undefined 1 = fairWeight 2 = starving')
portAccessType = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAccessType.setStatus('current')
if mibBuilder.loadTexts: portAccessType.setDescription('Used to get or set the port access type. 0 = undefined 1 = tunnel 2 = access 3 = trunk')
portStatsClear = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portStatsClear.setStatus('current')
if mibBuilder.loadTexts: portStatsClear.setDescription('Used to clear the statistics table for this port')
portLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLinkState.setStatus('current')
if mibBuilder.loadTexts: portLinkState.setDescription('Reports the link state of the port. 0 = No link 1 = Linked')
portDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("undefined", 0), ("halfDuplex", 1), ("fullDuplex", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDuplex.setStatus('current')
if mibBuilder.loadTexts: portDuplex.setDescription('The object indcates the linked port duplex mode. undefined(0) Port is not linked or state of duplex is unknown halfDuplex(1) Port is linked at half duplex fullDuplex(2) Port is linked at full duplex ')
portMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(17, 17)).setFixedLength(17)).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMacAddress.setStatus('current')
if mibBuilder.loadTexts: portMacAddress.setDescription("MAC address of the port. If a MAC address doesn't exist on a port the value returned is all zeros.")
portStatsTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5), )
if mibBuilder.loadTexts: portStatsTable.setStatus('current')
if mibBuilder.loadTexts: portStatsTable.setDescription('This a table of Statistics per port.')
portStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"), (0, "OMNITRON-MIB", "portnum"))
if mibBuilder.loadTexts: portStatsEntry.setStatus('current')
if mibBuilder.loadTexts: portStatsEntry.setDescription('extended module statitical information.')
txOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txOctets.setStatus('current')
if mibBuilder.loadTexts: txOctets.setDescription('Statistics counter - Object name explains its usage.')
txDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txDropPkts.setStatus('current')
if mibBuilder.loadTexts: txDropPkts.setDescription('Statistics counter - Object name explains its usage.')
txBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txBroadcastPkts.setStatus('current')
if mibBuilder.loadTexts: txBroadcastPkts.setDescription('Statistics counter - Object name explains its usage.')
txMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMulticastPkts.setStatus('current')
if mibBuilder.loadTexts: txMulticastPkts.setDescription('Statistics counter - Object name explains its usage.')
txUnicastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txUnicastPkts.setStatus('current')
if mibBuilder.loadTexts: txUnicastPkts.setDescription('Statistics counter - Object name explains its usage.')
txGoodPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txGoodPkts.setStatus('current')
if mibBuilder.loadTexts: txGoodPkts.setDescription('Statistics counter - Object name explains its usage.')
txErrorPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txErrorPkts.setStatus('current')
if mibBuilder.loadTexts: txErrorPkts.setDescription('Statistics counter - Object name explains its usage.')
txPausePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txPausePkts.setStatus('current')
if mibBuilder.loadTexts: txPausePkts.setDescription('Statistics counter - Object name explains its usage.')
txCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txCollisions.setStatus('current')
if mibBuilder.loadTexts: txCollisions.setDescription('Statistics counter - Object name explains its usage.')
txSingleCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txSingleCollision.setStatus('current')
if mibBuilder.loadTexts: txSingleCollision.setDescription('Statistics counter - Object name explains its usage.')
txMultipleCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMultipleCollision.setStatus('current')
if mibBuilder.loadTexts: txMultipleCollision.setDescription('Statistics counter - Object name explains its usage.')
txDeferedTransmit = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txDeferedTransmit.setStatus('current')
if mibBuilder.loadTexts: txDeferedTransmit.setDescription('Statistics counter - Object name explains its usage.')
txLateCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txLateCollision.setStatus('current')
if mibBuilder.loadTexts: txLateCollision.setDescription('Statistics counter - Object name explains its usage.')
txExcessiveCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txExcessiveCollision.setStatus('current')
if mibBuilder.loadTexts: txExcessiveCollision.setDescription('Statistics counter - Object name explains its usage.')
txDroppedEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txDroppedEvents.setStatus('current')
if mibBuilder.loadTexts: txDroppedEvents.setDescription('Statistics counter - Object name explains its usage.')
rxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxOctets.setStatus('current')
if mibBuilder.loadTexts: rxOctets.setDescription('Statistics counter - Object name explains its usage.')
rxDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxDropPkts.setStatus('current')
if mibBuilder.loadTexts: rxDropPkts.setDescription('Statistics counter - Object name explains its usage.')
rxBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxBroadcastPkts.setStatus('current')
if mibBuilder.loadTexts: rxBroadcastPkts.setDescription('Statistics counter - Object name explains its usage.')
rxMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMulticastPkts.setStatus('current')
if mibBuilder.loadTexts: rxMulticastPkts.setDescription('Statistics counter - Object name explains its usage.')
rxUnicastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUnicastPkts.setStatus('current')
if mibBuilder.loadTexts: rxUnicastPkts.setDescription('Statistics counter - Object name explains its usage.')
rxGoodPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxGoodPkts.setStatus('current')
if mibBuilder.loadTexts: rxGoodPkts.setDescription('Statistics counter - Object name explains its usage.')
rxTotalPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxTotalPkts.setStatus('current')
if mibBuilder.loadTexts: rxTotalPkts.setDescription('Statistics counter - Object name explains its usage.')
rxErrorPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxErrorPkts.setStatus('current')
if mibBuilder.loadTexts: rxErrorPkts.setDescription('Statistics counter - Object name explains its usage.')
rxPausePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPausePkts.setStatus('current')
if mibBuilder.loadTexts: rxPausePkts.setDescription('Statistics counter - Object name explains its usage.')
rxUndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUndersizePkts.setStatus('current')
if mibBuilder.loadTexts: rxUndersizePkts.setDescription('Statistics counter - Object name explains its usage.')
rxOversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxOversizePkts.setStatus('current')
if mibBuilder.loadTexts: rxOversizePkts.setDescription('Statistics counter - Object name explains its usage.')
rxFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxFragments.setStatus('current')
if mibBuilder.loadTexts: rxFragments.setDescription('Statistics counter - Object name explains its usage.')
rxJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxJabbers.setStatus('current')
if mibBuilder.loadTexts: rxJabbers.setDescription('Statistics counter - Object name explains its usage.')
rxAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxAlignmentErrors.setStatus('current')
if mibBuilder.loadTexts: rxAlignmentErrors.setDescription('Statistics counter - Object name explains its usage.')
rxFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxFCSErrors.setStatus('current')
if mibBuilder.loadTexts: rxFCSErrors.setDescription('Statistics counter - Object name explains its usage.')
rxSymbolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxSymbolErrors.setStatus('current')
if mibBuilder.loadTexts: rxSymbolErrors.setDescription('Statistics counter - Object name explains its usage.')
rxCRCAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxCRCAlignErrors.setStatus('current')
if mibBuilder.loadTexts: rxCRCAlignErrors.setDescription('Statistics counter - Object name explains its usage.')
rxPackets64 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPackets64.setStatus('current')
if mibBuilder.loadTexts: rxPackets64.setDescription('Statistics counter - packets of octet count in object name.')
rxPackets65to127 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPackets65to127.setStatus('current')
if mibBuilder.loadTexts: rxPackets65to127.setDescription('Statistics counter - packets of octet count in object name.')
rxPackets128to255 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPackets128to255.setStatus('current')
if mibBuilder.loadTexts: rxPackets128to255.setDescription('Statistics counter - packets of octet count in object name.')
rxPackets256to511 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPackets256to511.setStatus('current')
if mibBuilder.loadTexts: rxPackets256to511.setDescription('Statistics counter - packets of octet count in object name.')
rxPackets512to1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPackets512to1023.setStatus('current')
if mibBuilder.loadTexts: rxPackets512to1023.setDescription('Statistics counter - packets of octet count in object name.')
rxPackets1024to1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPackets1024to1518.setStatus('current')
if mibBuilder.loadTexts: rxPackets1024to1518.setDescription('Statistics counter - packets of octet count in object name.')
txOctets64 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 39), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txOctets64.setStatus('current')
if mibBuilder.loadTexts: txOctets64.setDescription('64 bit octet transmission counter.')
rxOctets64 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 40), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxOctets64.setStatus('current')
if mibBuilder.loadTexts: rxOctets64.setDescription('64 bit octet receive counter.')
moduleVLANTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6), )
if mibBuilder.loadTexts: moduleVLANTable.setStatus('current')
if mibBuilder.loadTexts: moduleVLANTable.setDescription('This a table of VLAN entries per module. There is a maximum of 64 valid entries in the table')
moduleVLANEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"), (0, "OMNITRON-MIB", "index"))
if mibBuilder.loadTexts: moduleVLANEntry.setStatus('current')
if mibBuilder.loadTexts: moduleVLANEntry.setDescription('VLAN module table.')
index = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)))
if mibBuilder.loadTexts: index.setStatus('current')
if mibBuilder.loadTexts: index.setDescription('Used to get or set elements in the vlan table entry.')
validityflag = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: validityflag.setStatus('current')
if mibBuilder.loadTexts: validityflag.setDescription('Used to set or delete a VLAN table entry. 0 = entry does not exists or is to be deleted, 1 = entry to be created or re-activated (in the case the entry was modified, the module needs to be notified of the change. This would constitute a re-activation.')
vlanidentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanidentifier.setStatus('current')
if mibBuilder.loadTexts: vlanidentifier.setDescription('Used to set or get the vlan identifier. valid settable range is 0-4095')
port1Membership = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port1Membership.setStatus('current')
if mibBuilder.loadTexts: port1Membership.setDescription("Used to set or get the port's membership in the specified vlan. 0 = not a member 1 = include in membership")
port2Membership = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port2Membership.setStatus('current')
if mibBuilder.loadTexts: port2Membership.setDescription("Used to set or get the port's membership in the specified vlan. 0 = not a member 1 = include in membership")
port3Membership = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port3Membership.setStatus('current')
if mibBuilder.loadTexts: port3Membership.setDescription("Used to set or get the port's membership in the specified vlan. 0 = not a member 1 = include in membership")
port4Membership = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port4Membership.setStatus('current')
if mibBuilder.loadTexts: port4Membership.setDescription("Used to set or get the port's membership in the specified vlan. 0 = not a member 1 = include in membership")
port5Membership = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port5Membership.setStatus('current')
if mibBuilder.loadTexts: port5Membership.setDescription("Used to set or get the port's membership in the specified vlan. 0 = not a member 1 = include in membership")
port6Membership = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port6Membership.setStatus('current')
if mibBuilder.loadTexts: port6Membership.setDescription("Used to set or get the port's membership in the specified vlan. 0 = not a member 1 = include in membership")
portAHTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7), )
if mibBuilder.loadTexts: portAHTable.setStatus('current')
if mibBuilder.loadTexts: portAHTable.setDescription('This is a table of AH parameter entries per port.')
portAHEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"), (0, "OMNITRON-MIB", "portnum"))
if mibBuilder.loadTexts: portAHEntry.setStatus('current')
if mibBuilder.loadTexts: portAHEntry.setDescription('AH port table.')
ahEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahEnabled.setStatus('current')
if mibBuilder.loadTexts: ahEnabled.setDescription('Used to get or set the state of the AH protocol over specified port. 0 = disable - this port is not actively using the AH protocol 1 = enabled - this port is actively using the AH protocol')
ahLpbkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahLpbkMode.setStatus('current')
if mibBuilder.loadTexts: ahLpbkMode.setDescription('Used to get or set the state of the OAM remote loopback. 0 = off - remote loopback is not active 1 = on - remote loopback has been activated')
ahLocalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahLocalMode.setStatus('current')
if mibBuilder.loadTexts: ahLocalMode.setDescription('Used to get or set the mode AH OAM Client. 0 = PASSIVE - Does not initiate discovery or remote loopbacks 1 = ACTIVE - Initiates discovery process and may initiate remote loopbacks 2 = PASSIVE, PROTECTED - Same as PASSIVE but disallows configuration requests from link partner using AH extensions 3 = ACTIVE, PROTECTED - Same as ACTIVE but disallows configuration requests from link partner using AH extensions')
ahRemoteMode = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteMode.setStatus('current')
if mibBuilder.loadTexts: ahRemoteMode.setDescription('Used to get or set the mode AH OAM Client. 0 = PASSIVE - Does not initiate discovery or remote loopbacks 1 = ACTIVE - Initiates discovery process and may initiate remote loopbacks 2 = PASSIVE, PROTECTED - Same as PASSIVE but disallows configuration requests from link partner using AH extensions 3 = ACTIVE, PROTECTED - Same as ACTIVE but disallows configuration requests from link partner using AH extensions')
ahLocalMuxState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahLocalMuxState.setStatus('current')
if mibBuilder.loadTexts: ahLocalMuxState.setDescription('Used to get local multiplexer state. 0 = FWD - Multiplexer passes MAC client frames to subordinate sublayer 1 = DISCARD - Multiplexer discards MAC client frames')
ahRemoteMuxState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteMuxState.setStatus('current')
if mibBuilder.loadTexts: ahRemoteMuxState.setDescription('Used to get remote multiplexer state. 0 = FWD - Multiplexer passes MAC client frames to subordinate sublayer 1 = DISCARD - Multiplexer discards MAC client frames')
ahLocalParserState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahLocalParserState.setStatus('current')
if mibBuilder.loadTexts: ahLocalParserState.setDescription('Used to get local parser state. 0 = FWD - Parser passes received non-OAMPDUs to subordinate sublayer 1 = LOOPBACK - Parser passes received non-OAMPDUs to Multiplexer during remote loopback test 2 = DISCARD - Parser discards received non-OAMPDUs')
ahRemoteParserState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteParserState.setStatus('current')
if mibBuilder.loadTexts: ahRemoteParserState.setDescription('Used to get remote parser state. 0 = FWD - Parser passes received non-OAMPDUs to subordinate sublayer 1 = LOOPBACK - Parser passes received non-OAMPDUs to Multiplexer during remote loopback test 2 = DISCARD - Parser discards received non-OAMPDUs')
ahLocalSupportVar = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahLocalSupportVar.setStatus('current')
if mibBuilder.loadTexts: ahLocalSupportVar.setDescription('Used to get local configured features supported in bit encoded value. where: bit0 = OAM Mode bit1 = Unidirectional support bit2 = Loopback Support bit3 = interprets link events bit4 = Variable Retrieval bit5 = Critical Event ')
ahLocalLinkFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahLocalLinkFlags.setStatus('current')
if mibBuilder.loadTexts: ahLocalLinkFlags.setDescription('Used to get Link Event status in bit encoded value. where: bit0 = Link Fault bit1 = Dying Gasp bit2 = Critical Event bit3 = Local Evaluating bit4 = Local Stable bit5 = Remote Evaluating bit6 = Remote Stable')
ahLocalLpbkTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahLocalLpbkTimeout.setStatus('current')
if mibBuilder.loadTexts: ahLocalLpbkTimeout.setDescription('Used to get/set Remote Loopback timeout. Value is in seconds with range 0 - 300.')
ahRemoteSupportVar = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteSupportVar.setStatus('current')
if mibBuilder.loadTexts: ahRemoteSupportVar.setDescription('Used to get remote configured features supported in bit encoded value. where: bit0 = OAM Mode bit1 = Unidirectional support bit2 = Loopback Support bit3 = interprets link events bit4 = Variable Retrieval bit5 = Critical Event ')
ahRemoteLinkFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteLinkFlags.setStatus('current')
if mibBuilder.loadTexts: ahRemoteLinkFlags.setDescription('Used to get Link Event status in bit encoded value. bit0 = Link Fault bit1 = Dying Gasp bit2 = Critical Event bit3 = Local Evaluating bit4 = Local Stable bit5 = Remote Evaluating bit6 = Remote Stable')
ahRemoteLpbkTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteLpbkTimeout.setStatus('current')
if mibBuilder.loadTexts: ahRemoteLpbkTimeout.setDescription('Used to get/set Remote Loopback timeout. Value is in seconds with range 0 - 300.')
ahLocalOUI = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahLocalOUI.setStatus('current')
if mibBuilder.loadTexts: ahLocalOUI.setDescription('Used to get the Organizational Unique ID of the local port.')
ahRemoteOUI = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteOUI.setStatus('current')
if mibBuilder.loadTexts: ahRemoteOUI.setDescription('Used to get the Organizational Unique ID of the remote port.')
ahErroredSymbolPeriodWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredSymbolPeriodWindow.setStatus('current')
if mibBuilder.loadTexts: ahErroredSymbolPeriodWindow.setDescription('Used to get or set errored symbol period window for the local port.')
ahErroredSymbolPeriodThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 18), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredSymbolPeriodThreshold.setStatus('current')
if mibBuilder.loadTexts: ahErroredSymbolPeriodThreshold.setDescription('Used to get or set errored symbol period threshold for the local port.')
ahErroredFrameWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredFrameWindow.setStatus('current')
if mibBuilder.loadTexts: ahErroredFrameWindow.setDescription('Used to get or set the errored symbol window for the local port.')
ahErroredFrameThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredFrameThreshold.setStatus('current')
if mibBuilder.loadTexts: ahErroredFrameThreshold.setDescription('Used to get or set the errored symbol threshold for the local port.')
ahErroredFramePeriodWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredFramePeriodWindow.setStatus('current')
if mibBuilder.loadTexts: ahErroredFramePeriodWindow.setDescription('Used to get or set the errored frame period window for the local port.')
ahErroredFramePeriodThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredFramePeriodThreshold.setStatus('current')
if mibBuilder.loadTexts: ahErroredFramePeriodThreshold.setDescription('Used to get or set the errored frame period threshold for the local port.')
ahErroredFrameSecondsWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 900))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredFrameSecondsWindow.setStatus('current')
if mibBuilder.loadTexts: ahErroredFrameSecondsWindow.setDescription('Used to get or set the errored frame seconds window for the local port.')
ahErroredFrameSecondsThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredFrameSecondsThreshold.setStatus('current')
if mibBuilder.loadTexts: ahErroredFrameSecondsThreshold.setDescription('Used to get or set the errored frame seconds threshold for the local port.')
ahRemoteLinkPort = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteLinkPort.setStatus('current')
if mibBuilder.loadTexts: ahRemoteLinkPort.setDescription('Used to get the port number of the remote partner. Value is in the Range 1-5. A zero port number indicates no connection or not supported')
ahSymbolErrorRunningTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 26), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahSymbolErrorRunningTotal.setStatus('current')
if mibBuilder.loadTexts: ahSymbolErrorRunningTotal.setDescription('This object indicates the 802.3ah Symbol Error Running Total value from the last OAM sublayer reset or clear operation. A value of zero indicates that no symbol errors have been detected since the last reset or clear. For each symbol error detected the value of the object increments. ')
ahSymbolErrorEventTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 27), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahSymbolErrorEventTotal.setStatus('current')
if mibBuilder.loadTexts: ahSymbolErrorEventTotal.setDescription('This object indicates the number of 802.3ah Errored Symbol Period Event TLVs that have been generated since the OAM sublayer was reset or the counters have been cleared. A value of zero indicates that no Errored Symbol Period Event TLVs have been generated. For each Errored Symbol Period Event TLV generated the value of the object increments. ')
ahFrameErrorRunningTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 28), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahFrameErrorRunningTotal.setStatus('current')
if mibBuilder.loadTexts: ahFrameErrorRunningTotal.setDescription('This object indicates the sum of the 802.3ah errored frames that have been detected since the OAM sublayer was reset or clear operation. A value of zero indicates that no errored frames have been detected since the last reset or clear. For each errored frame the value of the object increments. ')
ahFrameErrorEventTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 29), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahFrameErrorEventTotal.setStatus('current')
if mibBuilder.loadTexts: ahFrameErrorEventTotal.setDescription('This object indicates the number of 802.3ah Errored Frame Event TLVs that have been generated since the OAM sublayer was reset or the counters have been cleared. A value of zero indicates that no Errored Frame Event TLVs have been generated. For each Errored Frame Event Event TLV generated the value of the object increments. ')
ahFramePeriodRunningTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 30), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahFramePeriodRunningTotal.setStatus('current')
if mibBuilder.loadTexts: ahFramePeriodRunningTotal.setDescription('This object indicates the sum of 802.3ah the frame errors that have been detected that have been since the OAM sublayer was reset or clear operation. A value of zero indicates that no errored frames have been detected since the last reset or clear. For each errored frame the value of the object increments. ')
ahFramePeriodEventTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 31), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahFramePeriodEventTotal.setStatus('current')
if mibBuilder.loadTexts: ahFramePeriodEventTotal.setDescription('This object indicates the number of 802.3ah Errored Frame Period Event TLVs that have been generated since the OAM sublayer was reset or the counters have been cleared. A value of zero indicates that no Errored Frame Period Event TLVs have been generated. For each Errored Symbol Period Event TLV generated the value of the object increments. ')
ahFrameSecondsSummaryRunningTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 32), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahFrameSecondsSummaryRunningTotal.setStatus('current')
if mibBuilder.loadTexts: ahFrameSecondsSummaryRunningTotal.setDescription('This object indicates the sum of the 802.3ah errored frame seconds that have been detected that have been since the OAM sublayer was reset or clear operation. A value of zero indicates that no errored frame seconds have been detected since the last reset or clear. For each errored frame the value of the object increments. ')
ahFrameSecondsSummaryEventTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 33), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahFrameSecondsSummaryEventTotal.setStatus('current')
if mibBuilder.loadTexts: ahFrameSecondsSummaryEventTotal.setDescription('This object indicates the number of 802.3ah Errored Frame Seconds Summary Event TLVs that have been generated since the OAM sublayer was reset or the counters have been cleared. A value of zero indicates that no Errored Frame Seconds Summary Event TLVs have been generated. For each Errored Symbol Period Event TLV generated the value of the object increments. ')
ahClearStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 34), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahClearStatistics.setStatus('current')
if mibBuilder.loadTexts: ahClearStatistics.setDescription("This object when written clears the 802.3ah statistic counters associated with a specific port. When read the value always returns 'false'. Writing this value does not change any items in the configuration table. ")
ahTransmissionRate = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 35), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 100))).setUnits('Frames/sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahTransmissionRate.setStatus('current')
if mibBuilder.loadTexts: ahTransmissionRate.setDescription('This object sets maximum 802.3ah PDU transmission rate. The default value is 10 (10 frames per second) ')
ahCriticalEventMode = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 36), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahCriticalEventMode.setStatus('current')
if mibBuilder.loadTexts: ahCriticalEventMode.setDescription('Used to get or set the state of the local critical event mode. 0 = local critical events not enabled 1 = local critical events are enabled ')
ahCriticalEventTrapList = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 37), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 45))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahCriticalEventTrapList.setStatus('current')
if mibBuilder.loadTexts: ahCriticalEventTrapList.setDescription("Used to the SNMP traps which will cause the generation of a local critical event. It is a list of zero or more trap numbers separated by a comma or range, '..'. Example values: 5 5,110,112 100..110 5,110,90..95,100..105 The default value is an emtpy string, no SNMP traps generate a local critical event. ")
portSFPTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8), )
if mibBuilder.loadTexts: portSFPTable.setStatus('current')
if mibBuilder.loadTexts: portSFPTable.setDescription('This is a table of AH parameter entries per port.')
portSFPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"), (0, "OMNITRON-MIB", "portnum"))
if mibBuilder.loadTexts: portSFPEntry.setStatus('current')
if mibBuilder.loadTexts: portSFPEntry.setDescription('SFP port table.')
portSFPstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSFPstatus.setStatus('current')
if mibBuilder.loadTexts: portSFPstatus.setDescription('Used to get present or absence of SFP device. 0 = undefined 1 = notPresent 2 = present')
portSFPpageA0 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSFPpageA0.setStatus('current')
if mibBuilder.loadTexts: portSFPpageA0.setDescription('Used to get SFP device EEPROM address A0')
portSFPpageA2 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSFPpageA2.setStatus('current')
if mibBuilder.loadTexts: portSFPpageA2.setDescription('Used to get SFP device EEPROM address A2')
portSfpBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpBitRate.setStatus('current')
if mibBuilder.loadTexts: portSfpBitRate.setDescription('SFP Bitrate in Mbps')
portSfpVendorName = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpVendorName.setStatus('current')
if mibBuilder.loadTexts: portSfpVendorName.setDescription('SFP Vendor Name')
portSfpVendorPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpVendorPartNumber.setStatus('current')
if mibBuilder.loadTexts: portSfpVendorPartNumber.setDescription('SFP Vendor Name')
portSfpVendorSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpVendorSerialNumber.setStatus('current')
if mibBuilder.loadTexts: portSfpVendorSerialNumber.setDescription('SFP Serial Number')
portSfpDateCode = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpDateCode.setStatus('current')
if mibBuilder.loadTexts: portSfpDateCode.setDescription('SFP Date Code')
portSfpTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpTemperature.setStatus('current')
if mibBuilder.loadTexts: portSfpTemperature.setDescription('SFP tempearture in degrees Centigrade')
portSfpVcc = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpVcc.setStatus('current')
if mibBuilder.loadTexts: portSfpVcc.setDescription('SFP VCC in volts')
portSfpBiasCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpBiasCurrent.setStatus('current')
if mibBuilder.loadTexts: portSfpBiasCurrent.setDescription('SFP Bias Current in millamps')
portSfpTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpTxPower.setStatus('current')
if mibBuilder.loadTexts: portSfpTxPower.setDescription('SFP Transmission power in dBm')
portSfpRxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpRxPower.setStatus('current')
if mibBuilder.loadTexts: portSfpRxPower.setDescription('SFP Transmission power in dBm')
userTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9), )
if mibBuilder.loadTexts: userTable.setStatus('current')
if mibBuilder.loadTexts: userTable.setDescription('This is a table of SNMPv3 users.')
userEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"), (0, "OMNITRON-MIB", "userIndex"))
if mibBuilder.loadTexts: userEntry.setStatus('current')
if mibBuilder.loadTexts: userEntry.setDescription('User table entry.')
userIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: userIndex.setStatus('current')
if mibBuilder.loadTexts: userIndex.setDescription('User table index')
snmpv3UserName = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpv3UserName.setStatus('current')
if mibBuilder.loadTexts: snmpv3UserName.setDescription('SNMPv3 user name.')
snmpv3SecurityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpv3SecurityLevel.setStatus('current')
if mibBuilder.loadTexts: snmpv3SecurityLevel.setDescription('SNMPv3 security level 0 = undefined 1 = no authentication/no privacy 2 = authentication/no privacy 3 = authentication/privacy')
snmpv3AuthPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpv3AuthPassword.setStatus('current')
if mibBuilder.loadTexts: snmpv3AuthPassword.setDescription('SNMPv3 user authentication password.')
snmpv3PrivPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpv3PrivPassword.setStatus('current')
if mibBuilder.loadTexts: snmpv3PrivPassword.setDescription('SNMPv3 user privacy password.')
snmpv3UserType = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpv3UserType.setStatus('current')
if mibBuilder.loadTexts: snmpv3UserType.setDescription('SNMPv3 User Type 0 = undefined 1 = admin 2 = read-write 3 = read-only 4 = deny')
ostProtocolStatusTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10), )
if mibBuilder.loadTexts: ostProtocolStatusTable.setStatus('current')
if mibBuilder.loadTexts: ostProtocolStatusTable.setDescription('This table supports the Serial, Telnet, FTP user session status.')
ostProtocolStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"), (0, "OMNITRON-MIB", "userIndex"), (0, "OMNITRON-MIB", "ostProtocolStatusIndex"))
if mibBuilder.loadTexts: ostProtocolStatusEntry.setStatus('current')
if mibBuilder.loadTexts: ostProtocolStatusEntry.setDescription('This is a user protocol table entry.')
ostProtocolStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10, 1, 1), Unsigned32())
if mibBuilder.loadTexts: ostProtocolStatusIndex.setStatus('current')
if mibBuilder.loadTexts: ostProtocolStatusIndex.setDescription('An index that is used to identify a specific user protocol session. The index should remain constant until the session is closed. ')
ostProtocolStatusType = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("serial", 1), ("telnet", 2), ("ftp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostProtocolStatusType.setStatus('current')
if mibBuilder.loadTexts: ostProtocolStatusType.setDescription('This object indicates the specific user protocol session identity state. serial (1) User protocol session type is the serial port telnet (2) User protocol session type is TELNET ftp (3) User protocol session type is FTP ')
ostProtocolStatusState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("lockedout", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostProtocolStatusState.setStatus('current')
if mibBuilder.loadTexts: ostProtocolStatusState.setDescription('This object indicates the status of the specific user protocol session state. inactive(1) User is currently inactive (reserved value, not used) active(2) User is currently authenticated and active lockedout(3) User is currently locked out for authentication and cannot become active until the locked out timeout expires and the user status goes back to idle. ')
ostProtocoManagementPort = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notDefined", 1), ("mgt1", 2), ("mgt2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostProtocoManagementPort.setStatus('current')
if mibBuilder.loadTexts: ostProtocoManagementPort.setDescription("This object indicates the status of the specific user protocol session state. It is not applicable to the 'serial' interface or to a session type that is locked out. In these cases the object is returned with a value of 'notDefined'. notDefined(1) Management port is unknown or undefined mgt1(2) Management Port 1 association mgt2(3) Management Port 2 association ")
ostProtocolStatusIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostProtocolStatusIpAddress.setStatus('current')
if mibBuilder.loadTexts: ostProtocolStatusIpAddress.setDescription("This object indicates the IP address of the specific user protocol session. It is not applicable to the 'serial' interface or to a session type that is locked out. In these cases this object is returned as '0.0.0.0'. ")
ostProtocolStatusSessionOpenLockTime = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10, 1, 6), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostProtocolStatusSessionOpenLockTime.setStatus('current')
if mibBuilder.loadTexts: ostProtocolStatusSessionOpenLockTime.setDescription('The object indicates the time a specific user protocol session has been open or is locked out, in 0.01 seconds, based upon the value of ostProtocolStatusState. ')
ostEnvironmentalStatusTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11), )
if mibBuilder.loadTexts: ostEnvironmentalStatusTable.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalStatusTable.setDescription('This table supports the module environmental status objects.')
ostEnvironmentalStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"))
if mibBuilder.loadTexts: ostEnvironmentalStatusEntry.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalStatusEntry.setDescription('This is an environmental table entry.')
ostEnvironmentalPs1Status = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("notInstalled", 1), ("installedNotPowered", 2), ("installedPowered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs1Status.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs1Status.setDescription('This object indicates the status of Power Supply PS1 or PSA. notApplicable(0) Power Supply PS1/PSA is not supported notInstalled(1) Power Supply PS1/PSA is not installed installedNotPowered(2) Power Supply PS1/PSA is installed, but not powered installedPowered(3) Power Supply PS1/PSA is installed and powered ')
ostEnvironmentalPs1VoltageIn = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 2), Integer32()).setUnits('millivolts').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs1VoltageIn.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs1VoltageIn.setDescription('This object indicates PS1/PSA voltage input in millivolts. A value of zero indicates that no voltage is applied or the power supply is incapable of supplying a voltage input reading. ')
ostEnvironmentalPs1VoltageOut = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 3), Unsigned32()).setUnits('millivolts').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs1VoltageOut.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs1VoltageOut.setDescription('This object indicates PS1/PSA voltage output in millivolts. A value of zero indicates that no voltage is output or the power supply is incapable of supplying a voltage output reading. ')
ostEnvironmentalPs1CurrentOut = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 4), Unsigned32()).setUnits('milliamps').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs1CurrentOut.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs1CurrentOut.setDescription('This object indicates PS1/PSA current output in millianmps. A value of zero indicates that no current is output or the power supply is incapable of supplying a current output reading. ')
ostEnvironmentalPs2Status = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("notInstalled", 1), ("installedNotPowered", 2), ("installedPowered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs2Status.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs2Status.setDescription('This object indicates the status of Power Supply PS2 or PSB. notApplicable(0) Power Supply PS2/PSB is not supported notInstalled(1) Power Supply PS2/PSB is not installed installedNotPowered(2) Power Supply PS2/PSB is installed, but not powered installedPowered(3) Power Supply PS2/PSB is installed and powered ')
ostEnvironmentalPs2VoltageIn = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 6), Integer32()).setUnits('millivolts').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs2VoltageIn.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs2VoltageIn.setDescription('This object indicates PS2/PSB voltage input in millivolts. A value of zero indicates that no voltage is applied or the power supply is incapable of supplying a voltage input reading. ')
ostEnvironmentalPs2VoltageOut = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 7), Unsigned32()).setUnits('millivolts').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs2VoltageOut.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs2VoltageOut.setDescription('This object indicates PS2/PSB voltage output in millivolts. A value of zero indicates that no voltage is output or the power supply is incapable of supplying a voltage output reading. ')
ostEnvironmentalPs2CurrentOut = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 8), Unsigned32()).setUnits('milliamps').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs2CurrentOut.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs2CurrentOut.setDescription('This object indicates PS2/PSB current output in millianmps. A value of zero indicates that no current is output or the power supply is incapable of supplying a current output reading. ')
ostEnvironmentalTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 9), Integer32()).setUnits('degrees centigrade').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalTemperature.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalTemperature.setDescription('This object indicates the module internal ambient temperature in degrees centigrade. A value of zero indicates that the current temperature is 0 degrees or the module incapable of supplying a temperature reading. ')
ostEnvironmentalFan1Status = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("notInstalled", 1), ("installedNotPowered", 2), ("installedPowered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalFan1Status.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalFan1Status.setDescription('This object indicates the status of Fan 1. notApplicable(0) Fan 1 is not supported notInstalled(1) Fan 1 is not installed installedNotPowered(2) Fan 1 is installed, but not powered installedPowered(3) Fan 1 is installed and powered ')
ostEnvironmentalFan1Speed = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 11), Unsigned32()).setUnits('rpm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalFan1Speed.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalFan1Speed.setDescription('This object indicates the speed of Fan 1 in RPM (revolutions per minute) A value of zero indicates that the current fan speed is 0 RPM or the fan is not supported or installed. ')
ostEnvironmentalFan2Status = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("notInstalled", 1), ("installedNotPowered", 2), ("installedPowered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalFan2Status.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalFan2Status.setDescription('This object indicates the status of Fan 2. notApplicable(0) Fan 2 is not supported notInstalled(1) Fan 2 is not installed installedNotPowered(2) Fan 2 is installed, but not powered installedPowered(3) Fan 2 is installed and powered ')
ostEnvironmentalFan2Speed = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 13), Unsigned32()).setUnits('rpm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalFan2Speed.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalFan2Speed.setDescription('This object indicates the speed of Fan 2 in RPM (revolutions per minute) A value of zero indicates that the current fan speed is 0 RPM or the fan is not supported or installed. ')
ostEnvironmentalFan3Status = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("notInstalled", 1), ("installedNotPowered", 2), ("installedPowered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalFan3Status.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalFan3Status.setDescription('This object indicates the status of Fan 3. notApplicable(0) Fan 3 is not supported notInstalled(1) Fan 3 is not installed installedNotPowered(2) Fan 3 is installed, but not powered installedPowered(3) Fan 3 is installed and powered ')
ostEnvironmentalFan3Speed = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 15), Unsigned32()).setUnits('rpm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalFan3Speed.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalFan3Speed.setDescription('This object indicates the speed of Fan 3 in RPM (revolutions per minute) A value of zero indicates that the current fan speed is 0 RPM or the fan is not supported or installed. ')
omnitronCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 7342, 4, 1))
omnitronGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 7342, 4, 2))
omnitronCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 7342, 4, 1, 1)).setObjects(("OMNITRON-MIB", "omnitronGroup"), ("OMNITRON-MIB", "omnitronSFPGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    omnitronCompliance = omnitronCompliance.setStatus('current')
if mibBuilder.loadTexts: omnitronCompliance.setDescription('The compliance statement for OMNITRON iConverter modules.')
omnitronGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 7342, 4, 2, 1))
for _omnitronGroup_obj in [[("OMNITRON-MIB", "chassis"), ("OMNITRON-MIB", "selfSlot"), ("OMNITRON-MIB", "chassisnum"), ("OMNITRON-MIB", "slotnum"), ("OMNITRON-MIB", "chassistype"), ("OMNITRON-MIB", "prodtype"), ("OMNITRON-MIB", "chassisname"), ("OMNITRON-MIB", "partnum"), ("OMNITRON-MIB", "serialnum"), ("OMNITRON-MIB", "manufdate"), ("OMNITRON-MIB", "softrev"), ("OMNITRON-MIB", "prodrev"), ("OMNITRON-MIB", "ledstat"), ("OMNITRON-MIB", "switchstat"), ("OMNITRON-MIB", "extended1"), ("OMNITRON-MIB", "extended2"), ("OMNITRON-MIB", "extended3"), ("OMNITRON-MIB", "extended4"), ("OMNITRON-MIB", "extended5"), ("OMNITRON-MIB", "extended6"), ("OMNITRON-MIB", "resetmod"), ("OMNITRON-MIB", "wrswitch"), ("OMNITRON-MIB", "modulename"), ("OMNITRON-MIB", "moduleCount"), ("OMNITRON-MIB", "modchassnum"), ("OMNITRON-MIB", "modslotnum"), ("OMNITRON-MIB", "modchasstype"), ("OMNITRON-MIB", "modprodtype"), ("OMNITRON-MIB", "modsoftrev"), ("OMNITRON-MIB", "modprodrev"), ("OMNITRON-MIB", "modreset"), ("OMNITRON-MIB", "modnumports"), ("OMNITRON-MIB", "modchassname"), ("OMNITRON-MIB", "modpartnum"), ("OMNITRON-MIB", "modserialnum"), ("OMNITRON-MIB", "modmanufdate"), ("OMNITRON-MIB", "modname"), ("OMNITRON-MIB", "modportvlan"), ("OMNITRON-MIB", "modextfeaturebits"), ("OMNITRON-MIB", "modswbuildnum"), ("OMNITRON-MIB", "modenable802dot1qProcessing"), ("OMNITRON-MIB", "modtagsubstitution"), ("OMNITRON-MIB", "modcommitVLANchanges"), ("OMNITRON-MIB", "modvlanTableClear"), ("OMNITRON-MIB", "modcommitNMMCfgChanges"), ("OMNITRON-MIB", "modLM80volts"), ("OMNITRON-MIB", "modLM80currents"), ("OMNITRON-MIB", "modLM80misc"), ("OMNITRON-MIB", "modRestoreFactoryDefaults"), ("OMNITRON-MIB", "sysAdminStatus"), ("OMNITRON-MIB", "sysDateTime"), ("OMNITRON-MIB", "macAddr"), ("OMNITRON-MIB", "ipAddr"), ("OMNITRON-MIB", "subnetmask"), ("OMNITRON-MIB", "gateway"), ("OMNITRON-MIB", "readCommunity"), ("OMNITRON-MIB", "writeCommunity"), ("OMNITRON-MIB", "mychassnum"), ("OMNITRON-MIB", "mmname"), ("OMNITRON-MIB", "traphost1"), ("OMNITRON-MIB", "traphost2"), ("OMNITRON-MIB", "traphost3"), ("OMNITRON-MIB", "traphost4"), ("OMNITRON-MIB", "traphost5"), ("OMNITRON-MIB", "traphost6"), ("OMNITRON-MIB", "traphost7"), ("OMNITRON-MIB", "traphost8"), ("OMNITRON-MIB", "sysloc"), ("OMNITRON-MIB", "syscon"), ("OMNITRON-MIB", "serialpass"), ("OMNITRON-MIB", "telnetpass"), ("OMNITRON-MIB", "ftppasswrd"), ("OMNITRON-MIB", "keepAliveInterval"), ("OMNITRON-MIB", "vlanIdOst"), ("OMNITRON-MIB", "nmmCfgSerialBaudrate"), ("OMNITRON-MIB", "enabledFunctions"), ("OMNITRON-MIB", "enableSNMPFunction"), ("OMNITRON-MIB", "nmmCfgState"), ("OMNITRON-MIB", "nmmSecureMode"), ("OMNITRON-MIB", "nmmSecureConnState"), ("OMNITRON-MIB", "nmmIpProtocolState"), ("OMNITRON-MIB", "nmmIpDisabled"), ("OMNITRON-MIB", "vlanPri"), ("OMNITRON-MIB", "enableSNMPWrites"), ("OMNITRON-MIB", "cpuVoltageIn"), ("OMNITRON-MIB", "cpuVoltageOut"), ("OMNITRON-MIB", "cpuTemperature"), ("OMNITRON-MIB", "nmmSecureSlaveSlot"), ("OMNITRON-MIB", "dhcpIpAddr"), ("OMNITRON-MIB", "dhcpSubnetmask"), ("OMNITRON-MIB", "dhcpGateway"), ("OMNITRON-MIB", "nmmOAMmgmtMode"), ("OMNITRON-MIB", "customertag"), ("OMNITRON-MIB", "servicetag"), ("OMNITRON-MIB", "cnodeControl"), ("OMNITRON-MIB", "cnodeCIR"), ("OMNITRON-MIB", "enableSNMPv3Function"), ("OMNITRON-MIB", "slaveWrite"), ("OMNITRON-MIB", "snmpTrapType"), ("OMNITRON-MIB", "capsMask"), ("OMNITRON-MIB", "slaveTraps"), ("OMNITRON-MIB", "slaveTrapsForward"), ("OMNITRON-MIB", "coreStatusOnly"), ("OMNITRON-MIB", "ingressPolicingType"), ("OMNITRON-MIB", "vlanservicetag"), ("OMNITRON-MIB", "defaultForwardingMap"), ("OMNITRON-MIB", "modFpgaRev"), ("OMNITRON-MIB", "modExpPartNumber"), ("OMNITRON-MIB", "modExpSoftwareRev"), ("OMNITRON-MIB", "modExpLedStatus"), ("OMNITRON-MIB", "modHwRev"), ("OMNITRON-MIB", "modPcbRev"), ("OMNITRON-MIB", "ipAddr2"), ("OMNITRON-MIB", "subnetmask2"), ("OMNITRON-MIB", "gateway2"), ("OMNITRON-MIB", "ipaddrEVCassociation"), ("OMNITRON-MIB", "ipaddr2EVCassociation"), ("OMNITRON-MIB", "bootpEnable"), ("OMNITRON-MIB", "tftpEnable"), ("OMNITRON-MIB", "tftpServerIpAddress"), ("OMNITRON-MIB", "dhcptftpServerIpAddress"), ("OMNITRON-MIB", "tftpFileName"), ("OMNITRON-MIB", "modeType"), ("OMNITRON-MIB", "dhcpPortNumber"), ("OMNITRON-MIB", "dhcpTagVid"), ("OMNITRON-MIB", "trapSrcIpSelect"), ("OMNITRON-MIB", "muxGroupDefaults"), ("OMNITRON-MIB", "portFwdCpu"), ("OMNITRON-MIB", "portFwdCpuList"), ("OMNITRON-MIB", "portState"), ("OMNITRON-MIB", "portEgressRate"), ("OMNITRON-MIB", "portpriority"), ("OMNITRON-MIB", "portcanonicalformatIndicator"), ("OMNITRON-MIB", "portvlanidentifier"), ("OMNITRON-MIB", "portmlistcriteria"), ("OMNITRON-MIB", "portingresssecurity"), ("OMNITRON-MIB", "portegresspolicy"), ("OMNITRON-MIB", "portIngressRate"), ("OMNITRON-MIB", "portSpeed"), ("OMNITRON-MIB", "portUnidirectionalAhOamEnable"), ("OMNITRON-MIB", "portIngressRateDropOrPause"), ("OMNITRON-MIB", "portIngressRateCBS"), ("OMNITRON-MIB", "portL2CPmgntProcessing"), ("OMNITRON-MIB", "portEgressQosPolicy"), ("OMNITRON-MIB", "portAccessType"), ("OMNITRON-MIB", "portStatsClear"), ("OMNITRON-MIB", "portLinkState"), ("OMNITRON-MIB", "portDuplex"), ("OMNITRON-MIB", "portMacAddress"), ("OMNITRON-MIB", "txOctets"), ("OMNITRON-MIB", "txDropPkts"), ("OMNITRON-MIB", "txBroadcastPkts"), ("OMNITRON-MIB", "txMulticastPkts"), ("OMNITRON-MIB", "txUnicastPkts"), ("OMNITRON-MIB", "txGoodPkts"), ("OMNITRON-MIB", "txErrorPkts"), ("OMNITRON-MIB", "txPausePkts"), ("OMNITRON-MIB", "txCollisions"), ("OMNITRON-MIB", "txSingleCollision"), ("OMNITRON-MIB", "txMultipleCollision"), ("OMNITRON-MIB", "txDeferedTransmit"), ("OMNITRON-MIB", "txLateCollision"), ("OMNITRON-MIB", "txExcessiveCollision"), ("OMNITRON-MIB", "txDroppedEvents"), ("OMNITRON-MIB", "rxOctets"), ("OMNITRON-MIB", "rxDropPkts"), ("OMNITRON-MIB", "rxBroadcastPkts"), ("OMNITRON-MIB", "rxMulticastPkts"), ("OMNITRON-MIB", "rxUnicastPkts"), ("OMNITRON-MIB", "rxGoodPkts"), ("OMNITRON-MIB", "rxTotalPkts"), ("OMNITRON-MIB", "rxErrorPkts"), ("OMNITRON-MIB", "rxPausePkts"), ("OMNITRON-MIB", "rxUndersizePkts"), ("OMNITRON-MIB", "rxOversizePkts"), ("OMNITRON-MIB", "rxFragments"), ("OMNITRON-MIB", "rxJabbers"), ("OMNITRON-MIB", "rxAlignmentErrors"), ("OMNITRON-MIB", "rxFCSErrors"), ("OMNITRON-MIB", "rxSymbolErrors"), ("OMNITRON-MIB", "rxCRCAlignErrors"), ("OMNITRON-MIB", "rxPackets64"), ("OMNITRON-MIB", "rxPackets65to127"), ("OMNITRON-MIB", "rxPackets128to255"), ("OMNITRON-MIB", "rxPackets256to511"), ("OMNITRON-MIB", "rxPackets512to1023"), ("OMNITRON-MIB", "rxPackets1024to1518"), ("OMNITRON-MIB", "txOctets64"), ("OMNITRON-MIB", "rxOctets64"), ("OMNITRON-MIB", "validityflag"), ("OMNITRON-MIB", "vlanidentifier"), ("OMNITRON-MIB", "port1Membership"), ("OMNITRON-MIB", "port2Membership"), ("OMNITRON-MIB", "port3Membership"), ("OMNITRON-MIB", "port4Membership"), ("OMNITRON-MIB", "port5Membership"), ("OMNITRON-MIB", "port6Membership"), ("OMNITRON-MIB", "ahEnabled"), ("OMNITRON-MIB", "ahLpbkMode"), ("OMNITRON-MIB", "ahLocalMode"), ("OMNITRON-MIB", "ahRemoteMode"), ("OMNITRON-MIB", "ahLocalMuxState"), ("OMNITRON-MIB", "ahRemoteMuxState"), ("OMNITRON-MIB", "ahLocalParserState"), ("OMNITRON-MIB", "ahRemoteParserState"), ("OMNITRON-MIB", "ahLocalSupportVar"), ("OMNITRON-MIB", "ahLocalLinkFlags"), ("OMNITRON-MIB", "ahLocalLpbkTimeout"), ("OMNITRON-MIB", "ahRemoteSupportVar"), ("OMNITRON-MIB", "ahRemoteLinkFlags"), ("OMNITRON-MIB", "ahRemoteLpbkTimeout"), ("OMNITRON-MIB", "ahLocalOUI"), ("OMNITRON-MIB", "ahRemoteOUI"), ("OMNITRON-MIB", "ahErroredSymbolPeriodWindow"), ("OMNITRON-MIB", "ahErroredSymbolPeriodThreshold"), ("OMNITRON-MIB", "ahErroredFrameWindow"), ("OMNITRON-MIB", "ahErroredFrameThreshold"), ("OMNITRON-MIB", "ahErroredFramePeriodWindow"), ("OMNITRON-MIB", "ahErroredFramePeriodThreshold"), ("OMNITRON-MIB", "ahErroredFrameSecondsWindow"), ("OMNITRON-MIB", "ahErroredFrameSecondsThreshold"), ("OMNITRON-MIB", "ahRemoteLinkPort"), ("OMNITRON-MIB", "ahSymbolErrorRunningTotal"), ("OMNITRON-MIB", "ahSymbolErrorEventTotal"), ("OMNITRON-MIB", "ahFrameErrorRunningTotal"), ("OMNITRON-MIB", "ahFrameErrorEventTotal"), ("OMNITRON-MIB", "ahFramePeriodRunningTotal"), ("OMNITRON-MIB", "ahFramePeriodEventTotal"), ("OMNITRON-MIB", "ahFrameSecondsSummaryRunningTotal"), ("OMNITRON-MIB", "ahFrameSecondsSummaryEventTotal"), ("OMNITRON-MIB", "ahClearStatistics"), ("OMNITRON-MIB", "ahTransmissionRate"), ("OMNITRON-MIB", "ahCriticalEventMode"), ("OMNITRON-MIB", "ahCriticalEventTrapList"), ("OMNITRON-MIB", "snmpv3UserName"), ("OMNITRON-MIB", "snmpv3SecurityLevel"), ("OMNITRON-MIB", "snmpv3AuthPassword"), ("OMNITRON-MIB", "snmpv3PrivPassword"), ("OMNITRON-MIB", "snmpv3UserType"), ("OMNITRON-MIB", "ostProtocolStatusType"), ("OMNITRON-MIB", "ostProtocolStatusState"), ("OMNITRON-MIB", "ostProtocoManagementPort"), ("OMNITRON-MIB", "ostProtocolStatusIpAddress"), ("OMNITRON-MIB", "ostProtocolStatusSessionOpenLockTime"), ("OMNITRON-MIB", "ostEnvironmentalPs1Status"), ("OMNITRON-MIB", "ostEnvironmentalPs1VoltageIn"), ("OMNITRON-MIB", "ostEnvironmentalPs1VoltageOut"), ("OMNITRON-MIB", "ostEnvironmentalPs1CurrentOut"), ("OMNITRON-MIB", "ostEnvironmentalPs2Status"), ("OMNITRON-MIB", "ostEnvironmentalPs2VoltageIn"), ("OMNITRON-MIB", "ostEnvironmentalPs2VoltageOut"), ("OMNITRON-MIB", "ostEnvironmentalPs2CurrentOut"), ("OMNITRON-MIB", "ostEnvironmentalTemperature"), ("OMNITRON-MIB", "ostEnvironmentalFan1Status"), ("OMNITRON-MIB", "ostEnvironmentalFan1Speed")], [("OMNITRON-MIB", "ostEnvironmentalFan2Status"), ("OMNITRON-MIB", "ostEnvironmentalFan2Speed"), ("OMNITRON-MIB", "ostEnvironmentalFan3Status"), ("OMNITRON-MIB", "ostEnvironmentalFan3Speed")]]:
    if getattr(mibBuilder, 'version', 0) < (4, 4, 2):
        # WARNING: leading objects get lost here!
        omnitronGroup = omnitronGroup.setObjects(*_omnitronGroup_obj)
    else:
        omnitronGroup = omnitronGroup.setObjects(*_omnitronGroup_obj, **dict(append=True))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    omnitronGroup = omnitronGroup.setStatus('current')
if mibBuilder.loadTexts: omnitronGroup.setDescription('A collection of Omnitron objects.')
omnitronSFPGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 7342, 4, 2, 2)).setObjects(("OMNITRON-MIB", "portSFPstatus"), ("OMNITRON-MIB", "portSFPpageA0"), ("OMNITRON-MIB", "portSFPpageA2"), ("OMNITRON-MIB", "portSfpBitRate"), ("OMNITRON-MIB", "portSfpVendorName"), ("OMNITRON-MIB", "portSfpVendorPartNumber"), ("OMNITRON-MIB", "portSfpVendorSerialNumber"), ("OMNITRON-MIB", "portSfpDateCode"), ("OMNITRON-MIB", "portSfpTemperature"), ("OMNITRON-MIB", "portSfpVcc"), ("OMNITRON-MIB", "portSfpBiasCurrent"), ("OMNITRON-MIB", "portSfpTxPower"), ("OMNITRON-MIB", "portSfpRxPower"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    omnitronSFPGroup = omnitronSFPGroup.setStatus('current')
if mibBuilder.loadTexts: omnitronSFPGroup.setDescription('A collection of Omnitron port SFP objects.')
mibBuilder.exportSymbols("OMNITRON-MIB", modslotnum=modslotnum, modExpSoftwareRev=modExpSoftwareRev, omnitronProducts=omnitronProducts, portSfpRxPower=portSfpRxPower, serialpass=serialpass, traphost8=traphost8, modFpgaRev=modFpgaRev, ostProtocolStatusType=ostProtocolStatusType, portStatsClear=portStatsClear, portmlistcriteria=portmlistcriteria, modHwRev=modHwRev, ahErroredFramePeriodThreshold=ahErroredFramePeriodThreshold, portSfpBiasCurrent=portSfpBiasCurrent, txMulticastPkts=txMulticastPkts, portEgressRate=portEgressRate, chassistype=chassistype, rxOctets=rxOctets, ahRemoteLpbkTimeout=ahRemoteLpbkTimeout, telnetpass=telnetpass, rxOversizePkts=rxOversizePkts, modchassnum=modchassnum, portSfpBitRate=portSfpBitRate, ahRemoteLinkPort=ahRemoteLinkPort, portAHEntry=portAHEntry, modExpLedStatus=modExpLedStatus, cnodeCIR=cnodeCIR, ahCriticalEventTrapList=ahCriticalEventTrapList, enableSNMPFunction=enableSNMPFunction, nmmOAMmgmtMode=nmmOAMmgmtMode, dhcpTagVid=dhcpTagVid, rxBroadcastPkts=rxBroadcastPkts, portLinkState=portLinkState, txCollisions=txCollisions, txLateCollision=txLateCollision, ostProtocolStatusTable=ostProtocolStatusTable, snmpv3UserName=snmpv3UserName, modprodrev=modprodrev, ahFramePeriodRunningTotal=ahFramePeriodRunningTotal, portDuplex=portDuplex, portIngressRateDropOrPause=portIngressRateDropOrPause, prodrev=prodrev, ahLocalMode=ahLocalMode, modprodtype=modprodtype, tftpServerIpAddress=tftpServerIpAddress, userIndex=userIndex, ahErroredFramePeriodWindow=ahErroredFramePeriodWindow, txMultipleCollision=txMultipleCollision, mmname=mmname, ahLocalOUI=ahLocalOUI, modcommitNMMCfgChanges=modcommitNMMCfgChanges, macAddr=macAddr, ostEnvironmentalPs1VoltageOut=ostEnvironmentalPs1VoltageOut, portStatsTable=portStatsTable, selfSlot=selfSlot, ostProtocolStatusSessionOpenLockTime=ostProtocolStatusSessionOpenLockTime, port1Membership=port1Membership, cnodeControl=cnodeControl, managementModule=managementModule, snmpv3AuthPassword=snmpv3AuthPassword, modvlanTableClear=modvlanTableClear, txOctets64=txOctets64, extended5=extended5, portcanonicalformatIndicator=portcanonicalformatIndicator, modnumports=modnumports, port2Membership=port2Membership, portAccessType=portAccessType, rxTotalPkts=rxTotalPkts, port6Membership=port6Membership, extended2=extended2, cpuTemperature=cpuTemperature, rxFCSErrors=rxFCSErrors, ostProtocoManagementPort=ostProtocoManagementPort, ostEnvironmentalPs1Status=ostEnvironmentalPs1Status, muxGroupDefaults=muxGroupDefaults, subnetmask=subnetmask, enabledFunctions=enabledFunctions, ostEnvironmentalFan2Speed=ostEnvironmentalFan2Speed, txGoodPkts=txGoodPkts, switchstat=switchstat, ahLocalLpbkTimeout=ahLocalLpbkTimeout, nmmCfgState=nmmCfgState, ahFrameErrorEventTotal=ahFrameErrorEventTotal, ostEnvironmentalStatusEntry=ostEnvironmentalStatusEntry, ostEnvironmentalFan3Status=ostEnvironmentalFan3Status, vlanIdOst=vlanIdOst, dhcptftpServerIpAddress=dhcptftpServerIpAddress, extended4=extended4, portAHTable=portAHTable, rxPackets1024to1518=rxPackets1024to1518, customertag=customertag, vlanPri=vlanPri, txDeferedTransmit=txDeferedTransmit, txExcessiveCollision=txExcessiveCollision, ahSymbolErrorRunningTotal=ahSymbolErrorRunningTotal, wrswitch=wrswitch, cpuVoltageOut=cpuVoltageOut, portnum=portnum, modsoftrev=modsoftrev, enableSNMPWrites=enableSNMPWrites, txUnicastPkts=txUnicastPkts, portMacAddress=portMacAddress, userTable=userTable, ostProtocolStatusState=ostProtocolStatusState, slaveTrapsForward=slaveTrapsForward, writeCommunity=writeCommunity, rxMulticastPkts=rxMulticastPkts, ostEnvironmentalFan1Speed=ostEnvironmentalFan1Speed, slaveWrite=slaveWrite, rxPackets256to511=rxPackets256to511, ahClearStatistics=ahClearStatistics, traphost6=traphost6, port4Membership=port4Membership, ipAddr=ipAddr, ostEnvironmentalFan1Status=ostEnvironmentalFan1Status, softrev=softrev, enableSNMPv3Function=enableSNMPv3Function, modulePortsTable=modulePortsTable, userEntry=userEntry, extended6=extended6, defaultForwardingMap=defaultForwardingMap, snmpv3PrivPassword=snmpv3PrivPassword, omnitronMIB=omnitronMIB, portpriority=portpriority, nmmCfgSerialBaudrate=nmmCfgSerialBaudrate, modulename=modulename, modchassname=modchassname, traphost7=traphost7, ahErroredFrameWindow=ahErroredFrameWindow, omnitronGroups=omnitronGroups, port5Membership=port5Membership, manufdate=manufdate, portvlanidentifier=portvlanidentifier, ahLocalParserState=ahLocalParserState, port3Membership=port3Membership, subnetmask2=subnetmask2, portState=portState, ostEnvironmentalPs1CurrentOut=ostEnvironmentalPs1CurrentOut, validityflag=validityflag, modLM80currents=modLM80currents, modcommitVLANchanges=modcommitVLANchanges, moduleEntry=moduleEntry, rxAlignmentErrors=rxAlignmentErrors, ostEnvironmentalFan2Status=ostEnvironmentalFan2Status, moduleVLANTable=moduleVLANTable, modportvlan=modportvlan, portIngressRate=portIngressRate, modRestoreFactoryDefaults=modRestoreFactoryDefaults, portSFPpageA2=portSFPpageA2, slotnum=slotnum, chassis=chassis, mychassnum=mychassnum, servicetag=servicetag, portSFPstatus=portSFPstatus, ostEnvironmentalStatusTable=ostEnvironmentalStatusTable, nmmIpDisabled=nmmIpDisabled, ahRemoteLinkFlags=ahRemoteLinkFlags, portSFPTable=portSFPTable, ahLocalSupportVar=ahLocalSupportVar, rxPackets64=rxPackets64, readCommunity=readCommunity, capsMask=capsMask, bootpEnable=bootpEnable, portSfpVcc=portSfpVcc, ahRemoteOUI=ahRemoteOUI, moduleMgtCfgTable=moduleMgtCfgTable, ostEnvironmentalPs2VoltageOut=ostEnvironmentalPs2VoltageOut, ahFrameErrorRunningTotal=ahFrameErrorRunningTotal, moduleTable=moduleTable, rxJabbers=rxJabbers, rxPackets512to1023=rxPackets512to1023, nmmSecureMode=nmmSecureMode, ahLpbkMode=ahLpbkMode, ahRemoteSupportVar=ahRemoteSupportVar, portegresspolicy=portegresspolicy, rxPausePkts=rxPausePkts, modname=modname, rxUndersizePkts=rxUndersizePkts, omnitronGroup=omnitronGroup, PYSNMP_MODULE_ID=omnitronMIB, syscon=syscon, rxPackets128to255=rxPackets128to255, rxErrorPkts=rxErrorPkts, ostEnvironmentalPs2Status=ostEnvironmentalPs2Status, gateway2=gateway2, traphost2=traphost2, portSfpTxPower=portSfpTxPower, ahLocalLinkFlags=ahLocalLinkFlags, ahRemoteParserState=ahRemoteParserState, snmpTrapType=snmpTrapType, txDropPkts=txDropPkts, rxUnicastPkts=rxUnicastPkts, txSingleCollision=txSingleCollision, ipaddrEVCassociation=ipaddrEVCassociation, txPausePkts=txPausePkts, keepAliveInterval=keepAliveInterval, rxCRCAlignErrors=rxCRCAlignErrors, ledstat=ledstat, gateway=gateway, ahErroredFrameThreshold=ahErroredFrameThreshold, modchasstype=modchasstype, sysloc=sysloc, vlanservicetag=vlanservicetag, tftpFileName=tftpFileName, cpuVoltageIn=cpuVoltageIn, rxGoodPkts=rxGoodPkts, chassisname=chassisname, snmpv3SecurityLevel=snmpv3SecurityLevel, rxOctets64=rxOctets64, rxDropPkts=rxDropPkts, vlanidentifier=vlanidentifier, modExpPartNumber=modExpPartNumber, sysDateTime=sysDateTime, ostEnvironmentalPs2CurrentOut=ostEnvironmentalPs2CurrentOut, portSfpVendorSerialNumber=portSfpVendorSerialNumber, ostEnvironmentalTemperature=ostEnvironmentalTemperature, modmanufdate=modmanufdate, extended3=extended3, nmmSecureSlaveSlot=nmmSecureSlaveSlot, omnitronConformance=omnitronConformance, trapSrcIpSelect=trapSrcIpSelect, sysAdminStatus=sysAdminStatus, omnitronCompliance=omnitronCompliance, modextfeaturebits=modextfeaturebits, slaveTraps=slaveTraps, tftpEnable=tftpEnable, portSfpTemperature=portSfpTemperature, dhcpGateway=dhcpGateway, omnitronCompliances=omnitronCompliances, ostEnvironmentalPs2VoltageIn=ostEnvironmentalPs2VoltageIn, portL2CPmgntProcessing=portL2CPmgntProcessing, ahCriticalEventMode=ahCriticalEventMode, txOctets=txOctets, nmmSecureConnState=nmmSecureConnState, coreStatusOnly=coreStatusOnly, traphost5=traphost5, traphost3=traphost3, modeType=modeType, dhcpIpAddr=dhcpIpAddr, portFwdCpuList=portFwdCpuList, ahRemoteMuxState=ahRemoteMuxState, prodtype=prodtype, portSfpDateCode=portSfpDateCode, nmmIpProtocolState=nmmIpProtocolState, ahLocalMuxState=ahLocalMuxState, ahFrameSecondsSummaryRunningTotal=ahFrameSecondsSummaryRunningTotal, ahErroredFrameSecondsThreshold=ahErroredFrameSecondsThreshold, moduleMgtCfgEntry=moduleMgtCfgEntry, extended1=extended1, rxSymbolErrors=rxSymbolErrors, ostProtocolStatusIndex=ostProtocolStatusIndex, traphost4=traphost4, index=index, moduleVLANEntry=moduleVLANEntry, chassisEntry=chassisEntry)
mibBuilder.exportSymbols("OMNITRON-MIB", snmpv3UserType=snmpv3UserType, traphost1=traphost1, ahErroredSymbolPeriodWindow=ahErroredSymbolPeriodWindow, resetmod=resetmod, modLM80volts=modLM80volts, ahFrameSecondsSummaryEventTotal=ahFrameSecondsSummaryEventTotal, modswbuildnum=modswbuildnum, ahFramePeriodEventTotal=ahFramePeriodEventTotal, dhcpPortNumber=dhcpPortNumber, moduleCount=moduleCount, enhancedchassisTable=enhancedchassisTable, ahErroredFrameSecondsWindow=ahErroredFrameSecondsWindow, ftppasswrd=ftppasswrd, txErrorPkts=txErrorPkts, chassisTable=chassisTable, ahRemoteMode=ahRemoteMode, portStatsEntry=portStatsEntry, portSFPEntry=portSFPEntry, modserialnum=modserialnum, ostEnvironmentalPs1VoltageIn=ostEnvironmentalPs1VoltageIn, serialnum=serialnum, modpartnum=modpartnum, ipaddr2EVCassociation=ipaddr2EVCassociation, prodAgent=prodAgent, ostEnvironmentalFan3Speed=ostEnvironmentalFan3Speed, modPcbRev=modPcbRev, rxPackets65to127=rxPackets65to127, modreset=modreset, portSFPpageA0=portSFPpageA0, ahErroredSymbolPeriodThreshold=ahErroredSymbolPeriodThreshold, partnum=partnum, modulePortsEntry=modulePortsEntry, ahSymbolErrorEventTotal=ahSymbolErrorEventTotal, ostProtocolStatusEntry=ostProtocolStatusEntry, portEgressQosPolicy=portEgressQosPolicy, omnitronSFPGroup=omnitronSFPGroup, ingressPolicingType=ingressPolicingType, ahEnabled=ahEnabled, txBroadcastPkts=txBroadcastPkts, portSfpVendorPartNumber=portSfpVendorPartNumber, ahTransmissionRate=ahTransmissionRate, portingresssecurity=portingresssecurity, ipAddr2=ipAddr2, portSpeed=portSpeed, portSfpVendorName=portSfpVendorName, modtagsubstitution=modtagsubstitution, modLM80misc=modLM80misc, portIngressRateCBS=portIngressRateCBS, txDroppedEvents=txDroppedEvents, ostProtocolStatusIpAddress=ostProtocolStatusIpAddress, portUnidirectionalAhOamEnable=portUnidirectionalAhOamEnable, portFwdCpu=portFwdCpu, chassisnum=chassisnum, dhcpSubnetmask=dhcpSubnetmask, modenable802dot1qProcessing=modenable802dot1qProcessing, rxFragments=rxFragments)

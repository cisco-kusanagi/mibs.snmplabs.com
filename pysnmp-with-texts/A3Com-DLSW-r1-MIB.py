#
# PySNMP MIB module A3Com-DLSW-r1-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/A3COM-DLSW-R1-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:03:36 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, iso, NotificationType, Gauge32, Unsigned32, Counter32, ModuleIdentity, ObjectIdentity, enterprises, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Integer32, Counter64, IpAddress, MibIdentifier, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "iso", "NotificationType", "Gauge32", "Unsigned32", "Counter32", "ModuleIdentity", "ObjectIdentity", "enterprises", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Integer32", "Counter64", "IpAddress", "MibIdentifier", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
class NBName(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 16)

class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class TAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

class DlswTimeStamp(TimeTicks):
    pass

class EndStationLocation(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("other", 1), ("internal", 2), ("remote", 3), ("local", 4))

class DlcType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("other", 1), ("na", 2), ("llc", 3), ("sdlc", 4))

class LFSize(Integer32):
    pass

class Truthvalue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("false", 1), ("true", 2))

class RowStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))

class Instancepointer(Integer32):
    pass

a3Com = MibIdentifier((1, 3, 6, 1, 4, 1, 43))
brouterMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2))
dlswMIB_3Com = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 24)).setLabel("dlswMIB-3Com")
dlswNode = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 24, 1))
dlswTConn = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 24, 2))
dlswInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 24, 3))
dlswDirectory = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 24, 4))
dlswCircuit = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 24, 5))
dlswSdlc = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 24, 6))
dlswVersion = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswVersion.setStatus('mandatory')
if mibBuilder.loadTexts: dlswVersion.setDescription('This value identifies the particular version of the DLSw standard supported by this DLSw. The first hexdecimal value represents the DLSw standard Version number of this DLSw, the second hexdecimal value represents the DLSw standard Release number. This information is exchanged in DLSw Capabilities Exchange.')
dlswVendorID = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswVendorID.setStatus('mandatory')
if mibBuilder.loadTexts: dlswVendorID.setDescription('The value identifies the manufacturer-s IEEE assigned organizationally Unique Identifier (OUI) of this DLSw. This information is exchanged in DLSw Capabilities Exchange.')
dlswVersionString = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswVersionString.setStatus('mandatory')
if mibBuilder.loadTexts: dlswVersionString.setDescription('This value identifies the particular version number of this DLSw. The format of the actual version string is vendor-specific. This flows in Capabilities Exchange messages.')
dlswStdPacingSupport = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("adaptiveRcvWindow", 2), ("fixedRcvWindow", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswStdPacingSupport.setStatus('mandatory')
if mibBuilder.loadTexts: dlswStdPacingSupport.setDescription('Adaptive pacing defined in the DLSw Standard allows the receiving end of the DLSw node to control the amount of data that can flow over the DLSw cloud. none (1) means this DLSw node does not support the adaptive pacing scheme as defined in the DLSw Standard, possibly a proprietary pacing scheme is used. adaptiveRcvWindow (2) means this DLSw node supports the DLSw Standard pacing scheme. This DLSw node must be capable to adjust its sending window size as instructed by the partner DLSw and also will adjust its receive window size accordingly to its resource situation. However, implementation may choose not to adjust the receive window size. That is, the only Flow Control Operator will be sent by this node is the Repeat Window Operator. fixedRcvWindow (3) indicates this capability.')
dlswStatus = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dlswStatus.setDescription('The status of DLSw part of the system. Changing the value from active to inactive causes DLSw to take the following actions: (1) disconnect all circuits through all DLSw partners, (2) disconnect all transport connections to all DLSw partners, (3) disconnect all local DLC connections, and (4) stop processing all DLC connection set-up traffic. Since these are destructive actions, the user should query the circuit and transport connection tables in advance to understand the effect this action will have. Changing the value from inactive to active causes DLSw to come up in its initial state, i.e., transport connection established and ready to bring up circuits.')
dlswUpTime = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: dlswUpTime.setDescription('The time (in hundredths of a second) since the DLSw portion of the system was last re-initialized. That is, if dlswState is in the active state, the time the dlswState entered the active state. It will remain zero, if the dlswState is in the inactive state.')
dlswVirtualSegmentLFSize = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswVirtualSegmentLFSize.setStatus('mandatory')
if mibBuilder.loadTexts: dlswVirtualSegmentLFSize.setDescription('The largest size of the INFO field (LLC and above) that virtual segment can send/receive. It does not include any MAC level (framing) octets. This value will affect the LF size of circuits in creation. LF size of an existing circuit can be found in RIF (Routing Information Field).')
dlswResourceNBExclusivity = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 1, 8), Truthvalue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswResourceNBExclusivity.setStatus('mandatory')
if mibBuilder.loadTexts: dlswResourceNBExclusivity.setDescription('The value of true identifies the NETBIOS Names that are configured in the dlswDirNBTable are the only ones accessible via this DLSw. Changes to this object take effect for runtime Capabilities Exchange messages is implementation choice.')
dlswResourceMacExclusivity = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 1, 9), Truthvalue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswResourceMacExclusivity.setStatus('mandatory')
if mibBuilder.loadTexts: dlswResourceMacExclusivity.setDescription('The value of true identifies the MAC addresses that are configured in the dlswDirMacTable are the only ones accessible via this DLSw. Changes to this object take effect for runtime Capabilities Exchange messages is implementation choice.')
dlswTConnStat = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 1))
dlswTConnStatActiveConnections = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnStatActiveConnections.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnStatActiveConnections.setDescription('The number of transport connections are not in -disconnected- state.')
dlswTConnStatCloseIdles = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnStatCloseIdles.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnStatCloseIdles.setDescription('The number of DLSw connections exited connected state with all circuits disconnected gracefully. That is, the transport connection was brought down, by either this DLSw node or its partner DLSw node, with no active circuits.')
dlswTConnStatCloseBusys = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnStatCloseBusys.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnStatCloseBusys.setDescription('The number of DLSw connections exited connected state without all circuits disconnected gracefully. That is, the transport connection was brought down, by either this DLSw node or its partner DLSw node, with some active circuits. For instance, transport connection, e.g, TCP connection, failed.')
dlswTConnConfigTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 2), )
if mibBuilder.loadTexts: dlswTConnConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnConfigTable.setDescription('This table defines the transport connections that will be initiated or accepted by this DLSw. Structure of masks allows wildcard definition for a collection of transport connections by a conceptual row. For a specific transport connection, there may be multiple of conceptual rows match the transport address. The -best- match will the one to determine the characteristics of the transport connection.')
dlswTConnConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 2, 1), ).setIndexNames((0, "A3Com-DLSW-r1-MIB", "dlswTConnConfigIndex"))
if mibBuilder.loadTexts: dlswTConnConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnConfigEntry.setDescription('Each conceptual row defines a collection of transport connections.')
dlswTConnConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnConfigIndex.setDescription('The index to the conceptual row of the table. Non-positive numbers are not allowed. There are objects defined that point to conceptual rows of this table with this index value. Zero is used to denote that no corresponding row exists. Index values are assigned by the managed station, and should not be reused but should continue to increase in value until they wrap.')
dlswTConnConfigTDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswTConnConfigTDomain.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnConfigTDomain.setDescription('The object identifier which indicates the transport domain of this conceptual row.')
dlswTConnConfigLocalTAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 2, 1, 3), TAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswTConnConfigLocalTAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnConfigLocalTAddr.setDescription('The local transport address for this conceptual row of the transport connection definition.')
dlswTConnConfigRemoteTAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 2, 1, 4), TAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswTConnConfigRemoteTAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnConfigRemoteTAddr.setDescription('The remote transport address. Together with the dlswTConnConfigRemoteTAddrMask, the object instance of this conceptual row identifies a collection of the transport connections that will be either initiated by this DLSw or initiated by partner DLSw and accepted by this DLSw.')
dlswTConnConfigLastModifyTime = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 2, 1, 5), DlswTimeStamp()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswTConnConfigLastModifyTime.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnConfigLastModifyTime.setDescription('The value of dlswUpTime when the value of any object in this conceptual row was last changed. This value may be compared to dlswTConnOperConnectTime to determine whether values in this row are completely valid for a tranport connection created using this row definition.')
dlswTConnConfigEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("individual", 1), ("global", 2), ("group", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswTConnConfigEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnConfigEntryType.setDescription("The object instance signifies the type of entry in the associated conceptual row. The value of -individual- means that the entry applies to a specific partner DLSw node as identified by dlswTConnConfigRemoteTAddr and dlswTConnConfigTDomain. The value of -global- means that the entry applies to all partner DLSw nodes of the TDomain. The value of -group' means that the entry applies to a specific set of DLSw nodes in the TDomain. Any group definitions are enterprise-specific and are pointed to by dlswTConnConfigGroupDefinition. In the cases of -global- and `group', the value in dlswTConnConfigRemoteTAddr may not have any significance.")
dlswTConnConfigGroupDefinition = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 2, 1, 7), Instancepointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswTConnConfigGroupDefinition.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnConfigGroupDefinition.setDescription("For conceptual rows of -individual- and `global' as specified in dlswTConnConfigEntryType, the instance of this object is -0.0-. For conceptual rows of -group-, the instance points to the specific group definition.")
dlswTConnConfigSetupType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("activePersistent", 2), ("activeOnDemand", 3), ("passive", 4), ("excluded", 5))).clone('passive')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswTConnConfigSetupType.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnConfigSetupType.setDescription('This value of the instance of a conceptual row identifies the behavior of the collection of transport connections that this conceptual row defines. The value of activePersistent, activeOnDemand and passive means this DLSw will accept any transport connections, initiated by partner DLSw nodes, which are defined by this conceptual row. The value of activePersistent means this DLSw will also initiate the transport connections of this conceptual row and retry periodically if necessary. The value of activeOnDemand means this DLSw will initiate a transport connection of this conceptual row, if there is a directory cache hits. The value of other is implementation specific. The value of exclude means that the specified node is not allowed to be a partner to this DLSw node. To take a certain conceptual row definition out of service, a value of notInService for dlswTConnConfigRowStatus should be used.')
dlswTConnConfigSapList = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswTConnConfigSapList.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnConfigSapList.setDescription('The SAP list indicates which SAPs are advertised to the transport connection defined by this conceptual row. Only SAPs with even numbers are represented, in the form of the most significant bit of the first octet representing the SAP 0, the next most significant bit representing the SAP 2, to the least significant bit of the last octet representing the SAP 254. Data link switching is allowed for those SAPs which have one in its corresponding bit, not allowed otherwise. The whole SAP list has to be changed together. Changing the SAP list affects only new circuit establishments and has no effect on established circuits. This list can be used to restrict specific partners from knowing about all the SAPs used by DLSw on all its interfaces (these are represented in dlswIfSapList for each interface). For instance, one may want to run NetBIOS with some partners but not others. If a node supports sending run-time capabilities exchange messages, changes to this object should cause that action. It is up to the implementation exactly when to start the run-time capabilities exchange.')
dlswTConnConfigAdvertiseMacNB = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 2, 1, 10), Truthvalue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswTConnConfigAdvertiseMacNB.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnConfigAdvertiseMacNB.setDescription('The value of true indicates that defined local MAC addresses and NetBIOS names will be advertised to a partner node via initial and (if supported) run-time capabilities exchange messages.')
dlswTConnConfigInitCirRecvWndw = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswTConnConfigInitCirRecvWndw.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnConfigInitCirRecvWndw.setDescription('The initial circuit receive pacing window size, in the unit of SSP messages, to be used for future transport connections activated using this table row. The managed node sends this value as its initial receive pacing window in its initial capabilities exchange message. Changing this value does not affect the initial circuit receive pacing window size of currently active transport connections. If the standard window pacing scheme is not supported, the value is zero. A larger receive window value may be appropriate for partners that are reachable only via physical paths that have longer network delays.')
dlswTConnConfigOpens = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnConfigOpens.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnConfigOpens.setDescription('Number of times transport connections entered connected state according to the definition of this conceptual row.')
dlswTConnConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 2, 1, 13), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswTConnConfigRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnConfigRowStatus.setDescription('This object is used by a Management Station to create or delete the row entry in the dlswTConnConfigTable following the RowStatus textual convention. The value of notInService will be used to take a conceptual row definition out of use.')
dlswTConnOperTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3), )
if mibBuilder.loadTexts: dlswTConnOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperTable.setDescription('A list of transport connections. It is optional but desirable for an implementation to keep an entry for some period of time after the transport connection is disconnected. This allows a network management station to capture additional useful information about the connection, in particular, statistical information and the cause of the disconnection.')
dlswTConnOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1), ).setIndexNames((0, "A3Com-DLSW-r1-MIB", "dlswTConnOperTDomain"), (0, "A3Com-DLSW-r1-MIB", "dlswTConnOperRemoteTAddr"))
if mibBuilder.loadTexts: dlswTConnOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperEntry.setDescription('')
dlswTConnOperTDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 1), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperTDomain.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperTDomain.setDescription('The object identifier indicates the transport domain of this transport connection.')
dlswTConnOperLocalTAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 2), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperLocalTAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperLocalTAddr.setDescription('The local transport address for this transport connection. This value could be different from dlswTConnConfigLocalAddr, if the value of the latter were changed after this transport connection was established.')
dlswTConnOperRemoteTAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 3), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperRemoteTAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperRemoteTAddr.setDescription('The remote transport address of this transport connection.')
dlswTConnOperEntryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 4), DlswTimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperEntryTime.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperEntryTime.setDescription('The value of dlswUpTime when this transport connection conceptual row was created.')
dlswTConnOperConnectTime = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 5), DlswTimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperConnectTime.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperConnectTime.setDescription('The value of dlswUpTime when this transport connection last entered the -connected- state. A value of zero means this transport connection has never been established.')
dlswTConnOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("connecting", 1), ("initCapExchange", 2), ("connected", 3), ("quiescing", 4), ("disconnecting", 5), ("disconnected", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswTConnOperState.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperState.setDescription('The state of this transport connection. The transport connection enters -connecting- state when DLSw makes a connection request to the transport layer. Once initial Capabilities Exchange is sent, the transport connection enters enters -initCapExchange- state. When partner capabilities have been determined and the transport connection is ready for sending CanUReach (CUR) messages, it moves to the -connected- state. When DLSw is in the process of bringing down the connection, it is in the -disconnecting- state. When the transport layer indicates one of its connections is disconnected, the transport connection moves to the -disconnected- state. Whereas all of the values will be returned in response to a management protocol retrieval operation, only two values may be specified in a management protocol set operation, -quiescing- and -disconnecting-. Changing the value to -quiescing- prevents new circuits from being established, and will cause a transport disconnect when the last circuit on the connection goes away. Changing the value to -disconnecting- will force off all circuits immediately and bring the connection to -disconnected- state.')
dlswTConnOperConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperConfigIndex.setDescription('The value of dlswTConnConfigIndex of the dlswTConnConfigEntry that governs the configuration information used by this dlswTConnOperEntry. A management station can therefore normally examine both configured and operational information for this transport connection. This value is zero if the corresponding dlswTConnConfigEntry was deleted after the creation of this dlswTConnOperEntry. If some fields in the former were changed but the conceptual row was not deleted, some configuration information may not be valid for this operational transport connection. A network management application can compare dlswTConnOperConnectTime and dlswTConnConfigLastModifyTime to determine if this condition exists.')
dlswTConnOperFlowCntlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("undetermined", 1), ("pacing", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperFlowCntlMode.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperFlowCntlMode.setDescription('The flow control mechanism in use on this transport connection. This value is undetermined (1) before the mode of flow control can be established on a new tranport connection (i.e., after CapEx is sent but before Capex or other SSP control messages have been received). Pacing (2) indicates that the standard RFC 1795 pacing mechanism is in use. Other (3) may be either the RFC 1434+ xBusy mechanism operating to a back-level DLSw, or a vendor-specific flow control method. Whether it is xBusy or not can be inferred from dlswTConnOperPartnerVersion.')
dlswTConnOperPartnerVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperPartnerVersion.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperPartnerVersion.setDescription('This value identifies which version (first octet) and release (second octect) of the DLSw standard is supported by this partner DLSw. This information is obtained from a DLSw capabilities exchange message received from the partner DLSw. A string of zero length is returned before a Capabilities Exchange message is received, or if one is never received. A conceptual row with a dlswTConnOperState of -connected- but a zero length partner version indicates that the partner is a non-standard DLSw partner. If an implementation chooses to keep dlswTConnOperEntrys in the -disconnected- state, this value should remain unchanged.')
dlswTConnOperPartnerVendorID = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperPartnerVendorID.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperPartnerVendorID.setDescription('This value identifies the IEEE-assigned organizationally Unique Identifier (OUI) of the maker of this partner DLSw. This information is obtained from a DLSw capabilities exchange message received from the partner DLSw. A string of zero length is returned before a Capabilities Exchange message is received, or if one is never received. If an implementation chooses to keep dlswTConnOperEntrys in the -disconnected- state, this value should remain unchanged.')
dlswTConnOperPartnerVersionStr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 253))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperPartnerVersionStr.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperPartnerVersionStr.setDescription('This value identifies the particular product version (e.g., product name, code level, fix level) of this partner DLSw. The format of the actual version string is vendor-specific. This information is obtained from a DLSw capabilities exchange message received from the partner DLSw. A string of zero length is returned before a Capabilities Exchange message is received, if one is never received, or if one is received but it does not contain a version string. If an implementation chooses to keep dlswTConnOperEntrys in the -disconnected- state, this value should remain unchanged.')
dlswTConnOperPartnerInitPacingWndw = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperPartnerInitPacingWndw.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperPartnerInitPacingWndw.setDescription('The value of the partner initial receive pacing window. This is our initial send pacing window for all new circuits on this transport connection, as modified and granted by the first flow control indication the partner sends on each circuit. This information is obtained from a DLSw capabilities exchange message received from the partner DLSw. A value of zero is returned before a Capabilities Exchange message is received, or if one is never received. If an implementation chooses to keep dlswTConnOperEntrys in the -disconnected- state, this value should remain unchanged.')
dlswTConnOperPartnerSapList = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswTConnOperPartnerSapList.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperPartnerSapList.setDescription('The Supported SAP List received in the capabilities exchange message from the partner DLSw. This list has the same format described for dlswTConnConfigSapList. A string of zero length is returned before a Capabilities Exchange message is received, or if one is never received. If an implementation chooses to keep dlswTConnOperEntrys in the -disconnected- state, this value should remain unchanged.')
dlswTConnOperPartnerNBExcl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 14), Truthvalue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperPartnerNBExcl.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperPartnerNBExcl.setDescription('The value of true signifies that the NetBIOS names received from this partner in the NetBIOS name list in its capabilities exchange message are the only NetBIOS names reachable by that partner. -False- indicates that other NetBIOS names may be reachable. -False- should be returned before a Capabilities Exchange message is received, if one is never received, or if one is received without a NB Name Exclusivity CV. If an implementation chooses to keep dlswTConnOperEntrys in the -disconnected- state, this value should remain unchanged.')
dlswTConnOperPartnerMacExcl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 15), Truthvalue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperPartnerMacExcl.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperPartnerMacExcl.setDescription('The value of true signifies that the MAC addresses received from this partner in the MAC address list in its capabilities exchange message are the only MAC addresses reachable by that partner. -False- indicates that other MAC addresses may be reachable. -False- should be returned before a Capabilities Exchange message is received, if one is never received, or if one is received without a MAC Address Exclusivity CV. If an implementation chooses to keep dlswTConnOperEntrys in the -disconnected- state, this value should remain unchanged.')
dlswTConnOperPartnerNBInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("partial", 2), ("complete", 3), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperPartnerNBInfo.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperPartnerNBInfo.setDescription('It is up to this DSLw whether to keep either none, some, or all of the NetBIOS name list that was received in the capabilities exchange message sent by this partner DLSw. This object identifies how much information was kept by this DLSw. These names are stored as userConfigured remote entries in dlswDirNBTable. A value of (4), notApplicable, should be returned before a Capabilities Exchange message is received, or if one is never received. If an implementation chooses to keep dlswTConnOperEntrys in the -disconnected- state, this value should remain unchanged.')
dlswTConnOperPartnerMacInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("partial", 2), ("complete", 3), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperPartnerMacInfo.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperPartnerMacInfo.setDescription('It is up to this DLSw whether to keep either none, some, or all of the MAC address list that was received in the capabilities exchange message sent by this partner DLSw. This object identifies how much information was kept by this DLSw. These names are stored as userConfigured remote entries in dlswDirMACTable. A value of (4), notApplicable, should be returned before a Capabilities Exchange message is received, or if one is never received. If an implementation chooses to keep dlswTConnOperEntrys in the -disconnected- state, this value should remain unchanged.')
dlswTConnOperDiscTime = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 18), DlswTimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperDiscTime.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperDiscTime.setDescription('The value of dlswUpTime when dlswTConnOperState last entered -disconnected- state.')
dlswTConnOperDiscReason = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("capExFailed", 2), ("transportLayerDisc", 3), ("operatorCommand", 4), ("lastCircuitDiscd", 5), ("protocolError", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperDiscReason.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperDiscReason.setDescription('This object signifies the reason that either prevented the transport connection from entering the connected state, or caused the transport connection to enter the disconnected state.')
dlswTConnOperDiscActiveCir = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperDiscActiveCir.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperDiscActiveCir.setDescription('The number of circuits active (not in DISCONNECTED state) at the time the transport connection was last disconnected. This value is zero if the transport connection has never been connected.')
dlswTConnOperInDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperInDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperInDataPkts.setDescription('The number of Switch-to-Switch Protocol (SSP) messages of type DGRMFRAME, DATAFRAME, or INFOFRAME received on this transport connection.')
dlswTConnOperOutDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperOutDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperOutDataPkts.setDescription('The number of Switch-to-Switch Protocol (SSP) messages of type DGRMFRAME, DATAFRAME, or INFOFRAME transmitted on this transport connection.')
dlswTConnOperInDataOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperInDataOctets.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperInDataOctets.setDescription('The number octets in Switch-to-Switch Protocol (SSP) messages of type DGRMFRAME, DATAFRAME, or INFOFRAME received on this transport connection. Each message is counted starting with the first octet following the SSP message header.')
dlswTConnOperOutDataOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperOutDataOctets.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperOutDataOctets.setDescription('The number octets in Switch-to-Switch Protocol (SSP) messages of type DGRMFRAME, DATAFRAME, or INFOFRAME transmitted on this transport connection. Each message is counted starting with the first octet following the SSP message header.')
dlswTConnOperInCntlPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperInCntlPkts.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperInCntlPkts.setDescription('The number of Switch-to-Switch Protocol (SSP) messages received on this transport connection which were not of type DGRMFRAME, DATAFRAME, or INFOFRAME.')
dlswTConnOperOutCntlPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperOutCntlPkts.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperOutCntlPkts.setDescription('The number of Switch-to-Switch Protocol (SSP) messages of transmitted on this transport connection which were not of type DGRMFRAME, DATAFRAME, or INFOFRAME.')
dlswTConnOperCURexSents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperCURexSents.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperCURexSents.setDescription('The number of CanUReach_ex messages sent on this transport connection.')
dlswTConnOperICRexRcvds = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperICRexRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperICRexRcvds.setDescription('The number of ICanReach_ex messages received on this transport connection.')
dlswTConnOperCURexRcvds = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperCURexRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperCURexRcvds.setDescription('The number of CanUReach_ex messages received on this transport connection.')
dlswTConnOperICRexSents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperICRexSents.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperICRexSents.setDescription('The number of ICanReach_ex messages sent on this transport connection.')
dlswTConnOperNQexSents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperNQexSents.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperNQexSents.setDescription('The number of NetBIOS_NQ_ex (NetBIOS Name Query-explorer) messages sent on this transport connection.')
dlswTConnOperNRexRcvds = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperNRexRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperNRexRcvds.setDescription('The number of NETBIOS_NR_ex (NetBIOS Name Recognized-explorer) messages received on this transport connection.')
dlswTConnOperNQexRcvds = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperNQexRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperNQexRcvds.setDescription('The number of NETBIOS_NQ_ex messages received on this transport connection.')
dlswTConnOperNRexSents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperNRexSents.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperNRexSents.setDescription('The number of NETBIOS_NR_ex messages sent on this transport connection.')
dlswTConnOperCirCreates = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperCirCreates.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperCirCreates.setDescription('The number of times that circuits entered -circuit_established- state (not counting transitions from -circuit_restart-).')
dlswTConnOperCircuits = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 2, 3, 1, 36), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswTConnOperCircuits.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTConnOperCircuits.setDescription('The number of currently active circuits on this transport connection, where -active- means not in -disconnected- state.')
dlswDirStat = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 1))
dlswDirMacEntries = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirMacEntries.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirMacEntries.setDescription('The current total number of entries in the dlswDirMacTable.')
dlswDirNBEntries = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirNBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirNBEntries.setDescription('The current total number of entries in the dlswDirNBTable.')
dlswDirCache = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2))
dlswDirMacTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 1), )
if mibBuilder.loadTexts: dlswDirMacTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirMacTable.setDescription('This table contains locations of MAC addresses. They could be either verified or not verified, local or remote, and configured locally or learned from either Capabilities Exchange messages or directory searches.')
dlswDirMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 1, 1), ).setIndexNames((0, "A3Com-DLSW-r1-MIB", "dlswDirMacIndex"))
if mibBuilder.loadTexts: dlswDirMacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirMacEntry.setDescription('Indexed by dlswDirMacIndex.')
dlswDirMacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirMacIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirMacIndex.setDescription('Uniquely identifies a conceptual row of this table.')
dlswDirMacMac = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirMacMac.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirMacMac.setDescription('The MAC address, together with the dlswDirMacMask, specifies a set of MAC addresses that are defined or discovered through an interface or partner DLSw nodes.')
dlswDirMacMask = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 1, 1, 3), MacAddress().clone(hexValue="FFFFFFFFFFFF")).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirMacMask.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirMacMask.setDescription('The MAC address mask, together with the dlswDirMacMac, specifies a set of MAC addresses that are defined or discovered through an interface or partner DLSw nodes.')
dlswDirMacEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("userConfiguredPublic", 2), ("userConfiguredPrivate", 3), ("partnerCapExMsg", 4), ("dynamic", 5))).clone('userConfiguredPublic')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirMacEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirMacEntryType.setDescription('The cause of the creation of this conceptual row. It could be one of the three methods: (1) user configured, including via management protocol set operations, configuration file, command line or equivalent methods; (2) learned from the partner DLSw Capabilities Exchange messages; and (3) dynamic, e.g., learned from ICanReach messages, or LAN explorer frames. Since only individual MAC addresses can be dynamically learned, dynamic entries will all have a mask of all FFs. The public versus private distinction for user- configured resources applies only to local resources (UC remote resources are private), and indicates whether that resource should be advertised in capabilities exchange messages sent by this node.')
dlswDirMacLocationType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("remote", 3))).clone('local')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirMacLocationType.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirMacLocationType.setDescription('The location of the resource (or a collection of resources using a mask) of this conceptual row is either (1) local - the resource is reachable via an interface, or (2) remote - the resource is reachable via a partner DLSw node (or a set of partner DLSw nodes).')
dlswDirMacLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 1, 1, 6), Instancepointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirMacLocation.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirMacLocation.setDescription('Points to either the ifEntry, dlswTConnConfigEntry, dlswTConnOperEntry, 0.0, or something that is implementation specific. It identifies the location of the MAC address (or the collection of MAC addresses.)')
dlswDirMacStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("reachable", 2), ("notReachable", 3))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirMacStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirMacStatus.setDescription("This object specifies whether DLSw currently believes the MAC address to be accessible at the specified location. The value `notReachable' allows a configured resource definition to be taken out of service when a search to that resource fails (avoiding a repeat of the search).")
dlswDirMacLFSize = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 1, 1, 8), LFSize()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirMacLFSize.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirMacLFSize.setDescription('The largest size of the MAC INFO field (LLC header and data) that a circuit to the MAC address can carry through this path.')
dlswDirMacRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 1, 1, 9), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirMacRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirMacRowStatus.setDescription('This object is used by a Management Station to create or delete the row entry in the dlswDirMacTable following the RowStatus textual convention.')
dlswDirNBTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 2), )
if mibBuilder.loadTexts: dlswDirNBTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirNBTable.setDescription('This table contains locations of NetBIOS names. They could be either verified or not verified, local or remote, and configured locally or learned from either Capabilities Exchange messages or directory searches.')
dlswDirNBEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 2, 1), ).setIndexNames((0, "A3Com-DLSW-r1-MIB", "dlswDirNBIndex"))
if mibBuilder.loadTexts: dlswDirNBEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirNBEntry.setDescription('Indexed by dlswDirNBIndex.')
dlswDirNBIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirNBIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirNBIndex.setDescription('Uniquely identifies a conceptual row of this table.')
dlswDirNBName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 2, 1, 2), NBName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirNBName.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirNBName.setDescription("The NetBIOS name (including `any char' and `wildcard' characters) specifies a set of NetBIOS names that are defined or discovered through an interface or partner DLSw nodes.")
dlswDirNBNameType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("individual", 2), ("group", 3))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirNBNameType.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirNBNameType.setDescription('Whether dlswDirNBName represents an (or a set of) individual or group NetBIOS name(s).')
dlswDirNBEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("userConfiguredPublic", 2), ("userConfiguredPrivate", 3), ("partnerCapExMsg", 4), ("dynamic", 5))).clone('userConfiguredPublic')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirNBEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirNBEntryType.setDescription('The cause of the creation of this conceptual row. It could be one of the three methods: (1) user configured, including via management protocol set operations, configuration file, command line, or equivalent methods; (2) learned from the partner DLSw Capabilities Exchange messages; and (3) dynamic, e.g., learned from ICanReach messages, or test frames. Since only actual NetBIOS names can be dynamically learned, dynamic entries will not contain any char or wildcard characters. The public versus private distinction for user- configured resources applies only to local resources (UC remote resources are private), and indicates whether that resource should be advertised in capabilities exchange messages sent by this node.')
dlswDirNBLocationType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("remote", 3))).clone('local')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirNBLocationType.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirNBLocationType.setDescription('The location of the resource (or a collection of resources using any char/wildcard characters) of this conceptual row is either (1) local - the resource is reachable via an interface, or (2) remote - the resource is reachable via a a partner DLSw node (or a set of partner DLSw nodes).')
dlswDirNBLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 2, 1, 6), Instancepointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirNBLocation.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirNBLocation.setDescription('Points to either the ifEntry, dlswTConnConfigEntry, dlswTConnOperEntry, 0.0, or something that is implementation specific. It identifies the location of the NetBIOS name or the set of NetBIOS names.')
dlswDirNBStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("reachable", 2), ("notReachable", 3))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirNBStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirNBStatus.setDescription("This object specifies whether DLSw currently believes the NetBIOS name to be accessible at the specified location. The value `notReachable' allows a configured resource definition to be taken out of service when a search to that resource fails (avoiding a repeat of the search).")
dlswDirNBLFSize = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 2, 1, 8), LFSize()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirNBLFSize.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirNBLFSize.setDescription('The largest size of the MAC INFO field (LLC header and data) that a circuit to the NB name can carry through this path.')
dlswDirNBRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 4, 2, 2, 1, 9), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswDirNBRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dlswDirNBRowStatus.setDescription('This object is used by a Management Station to create or delete the row entry in the dlswDirNBTable following the RowStatus textual convention.')
dlswCircuitStat = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 1))
dlswActiveCircuits = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswActiveCircuits.setStatus('mandatory')
if mibBuilder.loadTexts: dlswActiveCircuits.setDescription('The number of entries in dlswCircuitTable which are not in the disconnected state.')
dlswCircuitCreates = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitCreates.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitCreates.setDescription('The total number of entries ever added to dlswCircuitTable, or reactivated upon exiting -disconnected- state.')
dlswCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2), )
if mibBuilder.loadTexts: dlswCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitTable.setDescription('This table is the circuit representation in the DLSw entity. Virtual data links are used to represent any internal end stations. There is a conceptual row associated with each data link. Thus, for circuits without an intervening transport connection, there are two conceptual rows for each circuit. The table consists of the circuits being established, established, and as an implementation option, circuits that have been disconnected. For circuits carried over transport connections, an entry is created after the CUR_cs was sent or received. For circuits between two locally attached devices, or internal virtual MAC addresses, an entry is created when the equivalent of CUR_cs sent/received status is reached. End station 1 (S1) and End station 2 (S2) are used to represent the two end stations of the circuit. S1 is always an end station which is locally attached. S2 may be locally attached or remote. If it is locally attached, the circuit will be represented by two rows indexed by (A, B) and (B, A) where A & B are the relevant MACs/SAPs. The table may be used to store the causes of disconnection of circuits. It is recommended that the oldest disconnected circuit entry be removed from this table when the memory space of disconnected circuits is needed.')
dlswCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1), ).setIndexNames((0, "A3Com-DLSW-r1-MIB", "dlswCircuitS1Mac"), (0, "A3Com-DLSW-r1-MIB", "dlswCircuitS1Sap"), (0, "A3Com-DLSW-r1-MIB", "dlswCircuitS2Mac"), (0, "A3Com-DLSW-r1-MIB", "dlswCircuitS2Sap"))
if mibBuilder.loadTexts: dlswCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitEntry.setDescription('')
dlswCircuitS1Mac = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitS1Mac.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitS1Mac.setDescription('The MAC Address of End Station 1 (S1) used for this circuit.')
dlswCircuitS1Sap = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitS1Sap.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitS1Sap.setDescription('The SAP at End Station 1 (S1) used for this circuit.')
dlswCircuitS1IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitS1IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitS1IfIndex.setDescription('The IfEntry index of the local interface through which S1 can be reached.')
dlswCircuitS1DlcType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 4), DlcType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitS1DlcType.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitS1DlcType.setDescription('The DLC protocol in use between the DLSw node and S1.')
dlswCircuitS1RouteInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitS1RouteInfo.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitS1RouteInfo.setDescription('If source-route bridging is in use between the DLSw node and S1, this is the routing information field describing the path between the two devices. Otherwise the value will be an OCTET STRING of zero length.')
dlswCircuitS1CircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitS1CircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitS1CircuitId.setDescription('The Circuit ID assigned by this DLSw node to this circuit. The first four octets are the DLC port Id, and the second four octets are the Data Link Correlator. If the DLSw SSP was not used to establish this circuit, the value will be a string of zero length.')
dlswCircuitS1Dlc = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 7), Instancepointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitS1Dlc.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitS1Dlc.setDescription('Points to a conceptual row of the underlying DLC MIB, which could either be the standard SDLC or LLC MIBs, or an enterprise-specific DLC MIB.')
dlswCircuitS2Mac = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 8), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitS2Mac.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitS2Mac.setDescription('The MAC Address of End Station 2 (S2) used for this circuit.')
dlswCircuitS2Sap = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitS2Sap.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitS2Sap.setDescription('The SAP at End Station 2 (S2) used for this circuit.')
dlswCircuitS2Location = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 10), EndStationLocation()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitS2Location.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitS2Location.setDescription('The location of End Station 2 (S2). If the location of End Station 2 is local, the interface information will be available in the conceptual row whose S1 and S2 are the S2 and the S1 of this conceptual row, respectively.')
dlswCircuitS2TDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 11), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitS2TDomain.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitS2TDomain.setDescription('If the location of End Station 2 is remote, this value is the transport domain of the transport protocol the circuit is running over. Otherwise, the value is 0.0.')
dlswCircuitS2TAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 12), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitS2TAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitS2TAddress.setDescription('If the location of End Station 2 is remote, this object contains the address of the partner DLSw, else it will be an OCTET STRING of zero length.')
dlswCircuitS2CircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitS2CircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitS2CircuitId.setDescription('The Circuit ID assigned to this circuit by the partner DLSw node. The first four octets are the DLC port Id, and the second four octets are the Data Link Correlator. If the DLSw SSP was not used to establish this circuit, the value will be a string of zero length.')
dlswCircuitOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("s1", 1), ("s2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitOrigin.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitOrigin.setDescription('This object specifies which of the two end stations initiated the establishment of this circuit.')
dlswCircuitEntryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 15), DlswTimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitEntryTime.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitEntryTime.setDescription('The value of dlswUpTime when this circuit table conceptual row was created.')
dlswCircuitStateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 16), DlswTimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitStateTime.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitStateTime.setDescription('The value of dlswUpTime when this circuit entered the current state.')
dlswCircuitState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("disconnected", 1), ("circuitStart", 2), ("resolvePending", 3), ("circuitPending", 4), ("circuitEstablished", 5), ("connectPending", 6), ("contactPending", 7), ("connected", 8), ("disconnectPending", 9), ("haltPending", 10), ("haltPendingNoack", 11), ("circuitRestart", 12), ("restartPending", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswCircuitState.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitState.setDescription('The current state of this circuit. The implementation may choose to keep entries for some period of time after circuit disconnect, so the network management station can gather the time and cause of disconnection. While all of the specified values may be returned from a GET operation, the only SETable value is -disconnectPending-. When this value is set, DLSw should perform the appropriate action given its previous state (e.g., send HALT_DL if the state was -connected-) to bring the circuit down to the -disconnected- state. Both the partner DLSw and local end station(s) should be notified as appropriate. This MIB provides no facility to re-establish a disconnected circuit, because in DLSw this should be an end station-driven function.')
dlswCircuitPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unsupported", 0), ("low", 1), ("medium", 2), ("high", 3), ("highest", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitPriority.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitPriority.setDescription('The transmission priority of this circuit as understood by this DLSw node. This value is determined by the two DLSw nodes at circuit startup time. If this DLSw node does not support DLSw circuit priority, the value -unsupported- should be returned.')
dlswCircuitFCSendGrantedUnits = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitFCSendGrantedUnits.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitFCSendGrantedUnits.setDescription('The number of paced SSP messages that this DLSw is currently authorized to send on this circuit before it must stop and wait for an additional flow control indication from the partner DLSw. The value zero should be returned if this circuit is not running the DLSw pacing protocol.')
dlswCircuitFCSendCurrentWndw = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitFCSendCurrentWndw.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitFCSendCurrentWndw.setDescription('The current window size that this DLSw is using in its role as a data sender. This is the value by which this DLSw would increase the number of messages it is authorized to send, if it were to receive a flow control indication with the bits specifying -repeat window-. The value zero should be returned if this circuit is not running the DLSw pacing protocol.')
dlswCircuitFCRecvGrantedUnits = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitFCRecvGrantedUnits.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitFCRecvGrantedUnits.setDescription('The current number of paced SSP messages that this DLSw has authorized the partner DLSw to send on this circuit before the partner DLSw must stop and wait for an additional flow control indication from this DLSw. The value zero should be returned if this circuit is not running the DLSw pacing protocol.')
dlswCircuitFCRecvCurrentWndw = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitFCRecvCurrentWndw.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitFCRecvCurrentWndw.setDescription('The current window size that this DLSw is using in its role as a data receiver. This is the number of additional paced SSP messages that this DLSw would be authorizing its DLSw partner to send, if this DLSw were to send a flow control indication with the bits specifying -repeat window-. The value zero should be returned if this circuit is not running the DLSw pacing protocol.')
dlswCircuitFCLargestRecvGranted = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitFCLargestRecvGranted.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitFCLargestRecvGranted.setDescription('The largest receive window size granted by this DLSw during the current activation of this circuit. This is not the largest number of messages granted at any time, but the largest window size as represented by FCIND operator bits. The value zero should be returned if this circuit is not running the DLSw pacing protocol.')
dlswCircuitFCLargestSendGranted = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitFCLargestSendGranted.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitFCLargestSendGranted.setDescription('The largest send (with respect to this DLSw) window size granted by the partner DLSw during the current activation of this circuit. The value zero should be returned if this circuit is not running the DLSw pacing protocol.')
dlswCircuitFCHalveWndwSents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitFCHalveWndwSents.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitFCHalveWndwSents.setDescription('The number of Halve Window operations this DLSw has sent on this circuit, in its role as a data receiver. The value zero should be returned if this circuit is not running the DLSw pacing protocol.')
dlswCircuitFCResetOpSents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitFCResetOpSents.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitFCResetOpSents.setDescription('The number of Reset Window operations this DLSw has sent on this circuit, in its role as a data receiver. The value zero should be returned if this circuit is not running the DLSw pacing protocol.')
dlswCircuitFCHalveWndwRcvds = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitFCHalveWndwRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitFCHalveWndwRcvds.setDescription('The number of Halve Window operations this DLSw has received on this circuit, in its role as a data sender. The value zero should be returned if this circuit is not running the DLSw pacing protocol.')
dlswCircuitFCResetOpRcvds = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitFCResetOpRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitFCResetOpRcvds.setDescription('The number of Reset Window operations this DLSw has received on this circuit, in its role as a data sender. The value zero should be returned if this circuit is not running the DLSw pacing protocol.')
dlswCircuitDiscReasonLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("endStationDiscRcvd", 1), ("endStationDlcError", 2), ("protocolError", 3), ("operatorCommand", 4), ("haltDlRcvd", 5), ("haltDlNoAckRcvd", 6), ("transportConnClosed", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitDiscReasonLocal.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitDiscReasonLocal.setDescription('The reason why this circuit was last disconnected, as seen by this DLSw node. This object is present only if the implementation keeps circuit table entries around for some period after circuit disconnect.')
dlswCircuitDiscReasonRemote = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("endStationDiscRcvd", 1), ("endStationDlcError", 2), ("protocolError", 3), ("operatorCommand", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitDiscReasonRemote.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitDiscReasonRemote.setDescription('The generic reason code why this circuit was last disconnected, as reported by the DLSw partner in a HALT_DL or HALT_DL_NOACK. If the partner does not send a reason code in these messages, or the DLSw implementation does not report receiving one, the value -unknown- is returned. This object is present only if the implementation keeps circuit table entries around for some period after circuit disconnect.')
dlswCircuitDiscReasonRemoteData = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 24, 5, 2, 1, 31), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlswCircuitDiscReasonRemoteData.setStatus('mandatory')
if mibBuilder.loadTexts: dlswCircuitDiscReasonRemoteData.setDescription('Implementation-specific data reported by the DLSw partner in a HALT_DL or HALT_DL_NOACK, to help specify how and why this circuit was last disconnected. If the partner does not send this data in these messages, or the DLSw implementation does not report receiving it, a string of zero length is returned. This object is present only if the implementation keeps circuit table entries around for some period after circuit disconnect.')
dlswTrapControl = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 24, 1, 10))
dlswTrapCntlTConn = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 1, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswTrapCntlTConn.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTrapCntlTConn.setDescription("Indicates whether the DLSw is permitted to emit transport connection up and down traps. With the value of `enabled' the DLSw will emit traps when connections enter `connected' and `disconnected' states. With the value of `disabled' the DLSw will not emit traps when connections enter of `connected' and `disconnected' states. With the value of `partial' the DLSw will only emits transport connection down traps when the connection is closed with busy. The changes take effect immediately.")
dlswTrapCntlCircuit = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 24, 1, 10, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlswTrapCntlCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: dlswTrapCntlCircuit.setDescription("Indicates whether the DLSw is permitted to generate circuit up and down traps. With the value of `enabled' the DLSw will emit traps when circuits enter `connected' and `disconnected' states. With the value of `disabled' the DLSw will not emit traps when circuits enter of `connected' and `disconnected' states. With the value of `partial' the DLSw will emit traps only for those circuits that are initiated by this DLSw, e.g., originating the CUR_CS message. The changes take effect immediately.")
dlswTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 24, 7))
dlswTrapTConnUp = NotificationType((1, 3, 6, 1, 4, 1, 43, 2, 24) + (0,1)).setObjects(("A3Com-DLSW-r1-MIB", "dlswTConnOperTDomain"), ("A3Com-DLSW-r1-MIB", "dlswTConnOperRemoteTAddr"))
if mibBuilder.loadTexts: dlswTrapTConnUp.setDescription("This trap is sent each time a transport connection enters `connected' state.")
dlswTrapTConnDown = NotificationType((1, 3, 6, 1, 4, 1, 43, 2, 24) + (0,2)).setObjects(("A3Com-DLSW-r1-MIB", "dlswTConnOperTDomain"), ("A3Com-DLSW-r1-MIB", "dlswTConnOperRemoteTAddr"))
if mibBuilder.loadTexts: dlswTrapTConnDown.setDescription("This trap is sent each time a transport connection enters `disconnected' state.")
dlswTrapCircuitUp = NotificationType((1, 3, 6, 1, 4, 1, 43, 2, 24) + (0,3)).setObjects(("A3Com-DLSW-r1-MIB", "dlswCircuitS1Mac"), ("A3Com-DLSW-r1-MIB", "dlswCircuitS1Sap"), ("A3Com-DLSW-r1-MIB", "dlswCircuitS2Mac"), ("A3Com-DLSW-r1-MIB", "dlswCircuitS2Sap"))
if mibBuilder.loadTexts: dlswTrapCircuitUp.setDescription("This trap is sent each time a circuit enters `connected' state.")
dlswTrapCircuitDown = NotificationType((1, 3, 6, 1, 4, 1, 43, 2, 24) + (0,4)).setObjects(("A3Com-DLSW-r1-MIB", "dlswCircuitS1Mac"), ("A3Com-DLSW-r1-MIB", "dlswCircuitS1Sap"), ("A3Com-DLSW-r1-MIB", "dlswCircuitS2Mac"), ("A3Com-DLSW-r1-MIB", "dlswCircuitS2Sap"))
if mibBuilder.loadTexts: dlswTrapCircuitDown.setDescription("This trap is sent each time a circuit enters `disconnected' state.")
mibBuilder.exportSymbols("A3Com-DLSW-r1-MIB", dlswCircuitStateTime=dlswCircuitStateTime, dlswUpTime=dlswUpTime, dlswTConnOperNQexRcvds=dlswTConnOperNQexRcvds, dlswTrapCntlCircuit=dlswTrapCntlCircuit, dlswTConnConfigRowStatus=dlswTConnConfigRowStatus, dlswTConnOperNRexRcvds=dlswTConnOperNRexRcvds, dlswStdPacingSupport=dlswStdPacingSupport, dlswStatus=dlswStatus, dlswTConnConfigSetupType=dlswTConnConfigSetupType, dlswCircuitEntryTime=dlswCircuitEntryTime, dlswTConnConfigEntry=dlswTConnConfigEntry, dlswCircuitS2Location=dlswCircuitS2Location, dlswDirMacEntry=dlswDirMacEntry, dlswMIB_3Com=dlswMIB_3Com, dlswTConnConfigOpens=dlswTConnConfigOpens, dlswTConnConfigEntryType=dlswTConnConfigEntryType, dlswDirNBEntryType=dlswDirNBEntryType, dlswCircuitS2TAddress=dlswCircuitS2TAddress, dlswCircuitFCRecvGrantedUnits=dlswCircuitFCRecvGrantedUnits, dlswTConn=dlswTConn, dlswVersion=dlswVersion, dlswCircuitS1DlcType=dlswCircuitS1DlcType, dlswTrapTConnUp=dlswTrapTConnUp, dlswDirNBRowStatus=dlswDirNBRowStatus, RowStatus=RowStatus, dlswTConnOperPartnerVersion=dlswTConnOperPartnerVersion, MacAddress=MacAddress, dlswCircuitState=dlswCircuitState, dlswTConnStat=dlswTConnStat, dlswDirStat=dlswDirStat, dlswTConnOperEntryTime=dlswTConnOperEntryTime, dlswCircuitS1Sap=dlswCircuitS1Sap, dlswDirNBEntry=dlswDirNBEntry, dlswTConnOperPartnerMacInfo=dlswTConnOperPartnerMacInfo, dlswDirMacMac=dlswDirMacMac, dlswTConnOperCirCreates=dlswTConnOperCirCreates, dlswTConnStatCloseIdles=dlswTConnStatCloseIdles, dlswCircuitTable=dlswCircuitTable, dlswTConnOperFlowCntlMode=dlswTConnOperFlowCntlMode, Instancepointer=Instancepointer, dlswTConnOperConnectTime=dlswTConnOperConnectTime, dlswCircuitFCResetOpSents=dlswCircuitFCResetOpSents, dlswCircuitS2CircuitId=dlswCircuitS2CircuitId, Truthvalue=Truthvalue, dlswCircuitFCRecvCurrentWndw=dlswCircuitFCRecvCurrentWndw, dlswTConnConfigTDomain=dlswTConnConfigTDomain, dlswDirNBNameType=dlswDirNBNameType, dlswDirNBTable=dlswDirNBTable, dlswDirMacMask=dlswDirMacMask, dlswDirCache=dlswDirCache, dlswTConnOperInDataOctets=dlswTConnOperInDataOctets, dlswResourceMacExclusivity=dlswResourceMacExclusivity, dlswCircuit=dlswCircuit, dlswDirMacLocationType=dlswDirMacLocationType, dlswTConnStatCloseBusys=dlswTConnStatCloseBusys, dlswCircuitFCHalveWndwSents=dlswCircuitFCHalveWndwSents, dlswDirNBIndex=dlswDirNBIndex, dlswResourceNBExclusivity=dlswResourceNBExclusivity, dlswDirectory=dlswDirectory, LFSize=LFSize, a3Com=a3Com, dlswTConnOperLocalTAddr=dlswTConnOperLocalTAddr, dlswCircuitPriority=dlswCircuitPriority, dlswCircuitFCResetOpRcvds=dlswCircuitFCResetOpRcvds, dlswTrapTConnDown=dlswTrapTConnDown, dlswSdlc=dlswSdlc, dlswVersionString=dlswVersionString, dlswTConnOperPartnerSapList=dlswTConnOperPartnerSapList, dlswTrapCircuitUp=dlswTrapCircuitUp, dlswTConnOperICRexRcvds=dlswTConnOperICRexRcvds, dlswCircuitOrigin=dlswCircuitOrigin, dlswTConnOperPartnerInitPacingWndw=dlswTConnOperPartnerInitPacingWndw, dlswTConnOperCURexRcvds=dlswTConnOperCURexRcvds, brouterMIB=brouterMIB, dlswTConnOperRemoteTAddr=dlswTConnOperRemoteTAddr, dlswTConnConfigLocalTAddr=dlswTConnConfigLocalTAddr, dlswCircuitFCSendCurrentWndw=dlswCircuitFCSendCurrentWndw, dlswTrapCircuitDown=dlswTrapCircuitDown, DlcType=DlcType, dlswDirMacIndex=dlswDirMacIndex, dlswTConnOperOutDataPkts=dlswTConnOperOutDataPkts, dlswCircuitFCLargestRecvGranted=dlswCircuitFCLargestRecvGranted, dlswTConnOperOutCntlPkts=dlswTConnOperOutCntlPkts, dlswTConnOperTDomain=dlswTConnOperTDomain, dlswTConnOperICRexSents=dlswTConnOperICRexSents, dlswDirNBLFSize=dlswDirNBLFSize, dlswDirMacStatus=dlswDirMacStatus, dlswDirNBLocationType=dlswDirNBLocationType, dlswTConnOperPartnerNBInfo=dlswTConnOperPartnerNBInfo, dlswDirMacTable=dlswDirMacTable, dlswVirtualSegmentLFSize=dlswVirtualSegmentLFSize, dlswTConnConfigTable=dlswTConnConfigTable, dlswTConnOperPartnerMacExcl=dlswTConnOperPartnerMacExcl, dlswTConnOperState=dlswTConnOperState, dlswInterface=dlswInterface, dlswDirNBStatus=dlswDirNBStatus, dlswTConnOperDiscActiveCir=dlswTConnOperDiscActiveCir, dlswCircuitS2Sap=dlswCircuitS2Sap, dlswCircuitS2TDomain=dlswCircuitS2TDomain, dlswTConnOperInDataPkts=dlswTConnOperInDataPkts, dlswTConnOperDiscTime=dlswTConnOperDiscTime, dlswCircuitS1RouteInfo=dlswCircuitS1RouteInfo, dlswCircuitDiscReasonRemoteData=dlswCircuitDiscReasonRemoteData, dlswTConnConfigInitCirRecvWndw=dlswTConnConfigInitCirRecvWndw, dlswVendorID=dlswVendorID, dlswCircuitStat=dlswCircuitStat, dlswTConnConfigAdvertiseMacNB=dlswTConnConfigAdvertiseMacNB, dlswNode=dlswNode, dlswCircuitS1IfIndex=dlswCircuitS1IfIndex, dlswCircuitFCLargestSendGranted=dlswCircuitFCLargestSendGranted, dlswCircuitFCHalveWndwRcvds=dlswCircuitFCHalveWndwRcvds, dlswTConnOperPartnerNBExcl=dlswTConnOperPartnerNBExcl, dlswCircuitS2Mac=dlswCircuitS2Mac, dlswActiveCircuits=dlswActiveCircuits, dlswTConnStatActiveConnections=dlswTConnStatActiveConnections, dlswTrapControl=dlswTrapControl, dlswTConnConfigGroupDefinition=dlswTConnConfigGroupDefinition, dlswDirNBName=dlswDirNBName, dlswTrapCntlTConn=dlswTrapCntlTConn, dlswTConnOperPartnerVendorID=dlswTConnOperPartnerVendorID, dlswDirMacLFSize=dlswDirMacLFSize, TAddress=TAddress, dlswCircuitCreates=dlswCircuitCreates, dlswTConnOperTable=dlswTConnOperTable, dlswDirNBEntries=dlswDirNBEntries, dlswCircuitFCSendGrantedUnits=dlswCircuitFCSendGrantedUnits, dlswTConnConfigSapList=dlswTConnConfigSapList, dlswTraps=dlswTraps, dlswDirMacRowStatus=dlswDirMacRowStatus, EndStationLocation=EndStationLocation, dlswTConnOperEntry=dlswTConnOperEntry, dlswTConnOperNQexSents=dlswTConnOperNQexSents, dlswDirMacEntries=dlswDirMacEntries, dlswTConnConfigLastModifyTime=dlswTConnConfigLastModifyTime, dlswTConnOperConfigIndex=dlswTConnOperConfigIndex, dlswDirMacEntryType=dlswDirMacEntryType, dlswTConnOperCURexSents=dlswTConnOperCURexSents, dlswTConnConfigIndex=dlswTConnConfigIndex, dlswTConnOperNRexSents=dlswTConnOperNRexSents, dlswTConnOperOutDataOctets=dlswTConnOperOutDataOctets, dlswCircuitDiscReasonLocal=dlswCircuitDiscReasonLocal, dlswDirNBLocation=dlswDirNBLocation, NBName=NBName, dlswCircuitS1CircuitId=dlswCircuitS1CircuitId, DlswTimeStamp=DlswTimeStamp, dlswTConnOperInCntlPkts=dlswTConnOperInCntlPkts, dlswCircuitEntry=dlswCircuitEntry, dlswTConnOperCircuits=dlswTConnOperCircuits, dlswCircuitS1Dlc=dlswCircuitS1Dlc, dlswTConnOperDiscReason=dlswTConnOperDiscReason, dlswDirMacLocation=dlswDirMacLocation, dlswTConnOperPartnerVersionStr=dlswTConnOperPartnerVersionStr, dlswCircuitS1Mac=dlswCircuitS1Mac, dlswCircuitDiscReasonRemote=dlswCircuitDiscReasonRemote, dlswTConnConfigRemoteTAddr=dlswTConnConfigRemoteTAddr)

#
# PySNMP MIB module A3Com-Bridge-r3-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/A3COM-BRIDGE-R3-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:03:34 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint")
MacAddress, = mibBuilder.importSymbols("RFC1286-MIB", "MacAddress")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibIdentifier, Integer32, IpAddress, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Gauge32, NotificationType, Unsigned32, enterprises, Bits, ObjectIdentity, Counter64, ModuleIdentity, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Integer32", "IpAddress", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Gauge32", "NotificationType", "Unsigned32", "enterprises", "Bits", "ObjectIdentity", "Counter64", "ModuleIdentity", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
a3Com = MibIdentifier((1, 3, 6, 1, 4, 1, 43))
brouterMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2))
a3ComBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 9))
class SMDSAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class RowStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))

a3ComBrgGen = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 9, 1))
a3ComBrgStp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 9, 2))
a3ComBrgSr = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 9, 3))
class X121Address(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 17)

a3ComBrgCtl = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bridging", 1), ("noBridging", 2))).clone('noBridging')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgCtl.setReference('NETBuilder Ref. Guide, Bridge Service parameter: Control')
if mibBuilder.loadTexts: a3ComBrgCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgCtl.setDescription('This object determines whether bridging is performed by this system. If this is set to noBridging (2), all functions associated with bridging are disabled, including Spanning Tree, Learning, and Source Routing.')
a3ComBrgAgeCtl = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aging", 1), ("noAging", 2))).clone('aging')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgAgeCtl.setReference('NETBuilder Ref. Guide, Bridge Service parameter: CONTrol')
if mibBuilder.loadTexts: a3ComBrgAgeCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgAgeCtl.setDescription('This object determines whether nodes that have not transmitted packets for a specified amount of time are deleted from the forwarding table. If this object is set to aging (1), entries in the forwarding table are removed after dot1dTpAgingTime seconds. This is useful in environments where nodes may be moved from one network to another. Setting this object to noAging (2), however, improves performance.')
a3ComBrgFwallCtl = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("firewall", 1), ("noFirewall", 2))).clone('firewall')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgFwallCtl.setReference('NETBuilder Ref. Guide, Bridge Service parameter: Control')
if mibBuilder.loadTexts: a3ComBrgFwallCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgFwallCtl.setDescription('This object is important when the system is performing both bridging and routing. When this is set to firewall (1), the bridge discards unicast packets of a protocol that is being routed (other than the unicast packets addressed to the bridge itself). If this is set to noFirewall, the bridge forwards those packets.')
a3ComBrgLearnCtl = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("learn", 1), ("noLearn", 2))).clone('learn')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgLearnCtl.setReference('NETBuilder Ref. Guide, Bridge Service parameter: Control')
if mibBuilder.loadTexts: a3ComBrgLearnCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgLearnCtl.setDescription('This object determines whether the bridge creates and updates entries in its forwarding tables.')
a3ComBrgForwardCtl = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("noForward", 2))).clone('forward')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgForwardCtl.setReference('NETBuilder Ref. Guide, Bridge Service parameter: Control')
if mibBuilder.loadTexts: a3ComBrgForwardCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgForwardCtl.setDescription('This object determines whether the bridge forwards packets. This has no effect on other bridging related functions, such as Spanning Tree, Learning, and Source Routing. Setting this object to noForward (2), allows isolation of the attached networks for diagnostic purposes.')
a3ComBrgAppleCtl = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgAppleCtl.setReference('NETBuilder Ref. Guide, Bridge Service parameter: AppleTalk')
if mibBuilder.loadTexts: a3ComBrgAppleCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgAppleCtl.setDescription('This object enables the bridge to forward AppleTalk packets between Ethernet, FDDI, and token ring networks. The AppleTalk packets require encapsulation over FDDI networks. If AppleTalk packets are to be translated the same way as other Ethernet packets are translated, this parameter must be disabled (2). If this object is enabled, the original format of both AT-1 (Ethernet) and AT-2 (SNAP) packets are preserved when bridging between Ethernets over an FDDI backbone. If this is disabled, AT-2 packets are converted to Ethernet format before going across the FDDI backbone.')
a3ComBrgFwTblCtl = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("dynToStatic", 2), ("delStatic", 3), ("delDyn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgFwTblCtl.setReference('NETBuilder Ref. Guide, ADD -BRidge ROUte All, DEL -Bridge ROUte All, FLush -BRidge AllRoutes.')
if mibBuilder.loadTexts: a3ComBrgFwTblCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgFwTblCtl.setDescription('This object is used to trigger actions taken on the static forwarding table. When this object is set to dynToStatic (2), all dynamically learned entries in the forwarding table are marked static. When this object is set to delStatic (3), all statically learned entries are deleted. When this object is set to delDyn (4), all dynamically learned entries are deleted. When a GET request is received for this object, the value other (1) is returned.')
a3ComBrgFwTblSize = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgFwTblSize.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgFwTblSize.setDescription('This object returns the size of the bridge forwarding table in units of 2^(9+n) where n is the value of this object. Thus, if this object has the value 2, then the bridge forwarding table has 2048 entries. If this value is changed, via a set, the new value will take affect only after the bridging service is disabled and re-enabled.')
a3ComBrgBLimitTimer = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("timer400ms", 2), ("timer600ms", 3), ("timer800ms", 4), ("timer1000ms", 5))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgBLimitTimer.setReference('NETBuilder Reference Guide, Bridge Service Parameter: BLimitTimer')
if mibBuilder.loadTexts: a3ComBrgBLimitTimer.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgBLimitTimer.setDescription('This object is used to select the broadcast limit feature sample interval. That is, this object contains the value of the time interval over which the number of broadcast packets per second are calculated. If that number exceeds the value of a3ComBrgBroadCastLimit for a particular port, the bridge will stop forwarding all broadcast packets on that port for the rest of the time interval.')
a3ComBrgStExtTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 10), )
if mibBuilder.loadTexts: a3ComBrgStExtTable.setReference('Bridge MIB, RFC1286, page 33')
if mibBuilder.loadTexts: a3ComBrgStExtTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgStExtTable.setDescription('This table is an extension of the dot1dStaticTable from the Bridge MIB, rfc1286. One additional column has been defined to identify the proper wide area address when bridging over a wide area port.')
a3ComBrgStExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 10, 1), ).setIndexNames((0, "A3Com-Bridge-r3-MIB", "a3ComBrgStExtAdd"), (0, "A3Com-Bridge-r3-MIB", "a3ComBrgStExtRcvPort"))
if mibBuilder.loadTexts: a3ComBrgStExtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgStExtEntry.setDescription('An extension to the dot1dStaticTable from rfc1286.')
a3ComBrgStExtAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 10, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgStExtAdd.setReference('dot1dStaticAddress, Bridge MIB, RFC1286, page 33')
if mibBuilder.loadTexts: a3ComBrgStExtAdd.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgStExtAdd.setDescription('A unicast MAC address for which the bridge has forwarding and/or filtering information.')
a3ComBrgStExtRcvPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgStExtRcvPort.setReference('dot1dStaticReceivePort, Bridge MIB, RFC1286, page 34')
if mibBuilder.loadTexts: a3ComBrgStExtRcvPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgStExtRcvPort.setDescription("Either the value '0' or the port number of the port from which a frame must be received in order for this entry's filtering information to apply. A value of zero indicates that this entry applies on all ports of the bridge for which there is no other applicable entry.")
a3ComBrgStExtWaAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 10, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgStExtWaAddress.setReference('NETBuilder Ref. Guide, ADD -BRidge ROUte DLCI WanID')
if mibBuilder.loadTexts: a3ComBrgStExtWaAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgStExtWaAddress.setDescription("When the destination port to which this table entry applies is a wide area port, this object is used to identify the wide area address to use when forwarding packets to this destination. The type of address can be determined by the ifType value corresponding to the port identified by dot1dStaticAllowedToGoTo or dot1dTpFdbPort. If the port is not a wide area port, this object will contain a zero length string. The representation of the addresses will follow the convention used in standard MIBs. For example, Frame Relay DLCI's will be encoded as binary numbers and placed in the OCTET STRING. X.25 addresses, on the other hand will be encoded as ASCII characters [0..9], with each octet of the OCTET STRING containing the ASCII representation of one digit.")
a3ComBrgFdbExtTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 11), )
if mibBuilder.loadTexts: a3ComBrgFdbExtTable.setReference('Bridge MIB, RFC1286, page 29')
if mibBuilder.loadTexts: a3ComBrgFdbExtTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgFdbExtTable.setDescription('This table is an extension of the dot1dTpFdbTable from the Bridge MIB, rfc1286. One additional column has been defined to identify the proper wide area address when bridging over a wide area port.')
a3ComBrgFdbExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 11, 1), ).setIndexNames((0, "A3Com-Bridge-r3-MIB", "a3ComBrgFdbExtAdd"))
if mibBuilder.loadTexts: a3ComBrgFdbExtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgFdbExtEntry.setDescription('An extension to the dot1dTpFdbTable from rfc1286.')
a3ComBrgFdbExtAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 11, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgFdbExtAdd.setReference('dot1dTpFdbAddress, Bridge MIB, RFC1286, page 30')
if mibBuilder.loadTexts: a3ComBrgFdbExtAdd.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgFdbExtAdd.setDescription('A unicast MAC address for which the bridge has forwarding and/or filtering information.')
a3ComBrgFdbExtWaAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 11, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgFdbExtWaAddress.setReference('NETBuilder Ref. Guide, ADD -BRidge ROUte DLCI WanID')
if mibBuilder.loadTexts: a3ComBrgFdbExtWaAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgFdbExtWaAddress.setDescription('When the port to which this table entry applies is a wide area port, this object is used to identify the wide area address to use when forwarding packets to this destination. The type of address can be determined by the ifType value corresponding to the port identified by dot1dTpFdbPort. If the port is not a wide area port, this object will contain a zero length string.')
a3ComBrgPortTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 12), )
if mibBuilder.loadTexts: a3ComBrgPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgPortTable.setDescription('This table is an extension of the dot1dBasePortTable from the Bridge MIB defined in RFC1286. This table contains generic information and control facilities for every port that is associated with the bridge. Transparent, source-route, and srt ports are included.')
a3ComBrgPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 12, 1), ).setIndexNames((0, "A3Com-Bridge-r3-MIB", "a3ComBrgPortIndex"))
if mibBuilder.loadTexts: a3ComBrgPortEntry.setReference('dot1dBasePortTable, Bridge MIB, RFC1286, page 11')
if mibBuilder.loadTexts: a3ComBrgPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgPortEntry.setDescription('Each entry in this table contains information and controls for a specific bridge port.')
a3ComBrgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgPortIndex.setReference('dot1dBasePortTable, Bridge MIB, RFC1286, page 11')
if mibBuilder.loadTexts: a3ComBrgPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgPortIndex.setDescription('The port number of the port for which this entry contains bridge management information.')
a3ComBrgPortCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("transparent", 1), ("sourceRoute", 2), ("srtEnabled", 3), ("noBridging", 4))).clone('noBridging')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgPortCtl.setReference('NETBuilder Ref. Guide, SETDefault !port -BRidge BRidgeFunction = Enable, SETDefault !port -SRT CONTrol = (SrcRouting|NoSrcRouting, Transparent| NoTransparent)')
if mibBuilder.loadTexts: a3ComBrgPortCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgPortCtl.setDescription('This object controls which type(s) of packets are bridged. This has no affect on whether the bridge participates in either the Spanning Tree or Source Route Protocols.')
a3ComBrgDstSecCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("forward", 2), ("block", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgDstSecCtl.setReference('NETBuilder Ref. Guide, Bridge Service parameter: DStSecurity')
if mibBuilder.loadTexts: a3ComBrgDstSecCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgDstSecCtl.setDescription('This object is a security feature that allows the control of packets sent to specific destinations. If this object is set to forward (2), only those packets for destination addresses listed in the static forwarding table can be forwarded by this port. If this object is set to block (3), any packet destined for an address listed in the static forwarding table is blocked by this port. Note, these actions are taken by this port after it receives a packet from the network. This does not apply to packets it forwards to the network.')
a3ComBrgSrcSecCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("forward", 2), ("block", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrcSecCtl.setReference('NETBuilder Ref. Guide, Bridge Service parameter: SRcSecurity')
if mibBuilder.loadTexts: a3ComBrgSrcSecCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrcSecCtl.setDescription('This object is a security feature that allows the control of packets sent from specific source addresses. If this object is set to forward (2), this port will forward only those packets sent from addresses listed in the static forwarding table for this port. If this object is set to block, this port will block every packet sent by a station whose address is listed in the static forwarding table for this port. Note, these actions are taken by this port after it receives a packet from the network. This does not apply to packets it forwards to the network.')
a3ComBrgX25Pid = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 12, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(221)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgX25Pid.setReference('NETBuilder Ref. Guide, Bridge Service parameter: X25ProtID')
if mibBuilder.loadTexts: a3ComBrgX25Pid.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgX25Pid.setDescription('This object applies to transparent bridging over an X25 network. It specifies the protocol ID to be used in an outgoing X25 call.')
a3ComBrgX25Qsize = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 12, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgX25Qsize.setReference('NETBuilder Ref. Guide, Bridge Service parameter: X25QueueSize')
if mibBuilder.loadTexts: a3ComBrgX25Qsize.setStatus('deprecated')
if mibBuilder.loadTexts: a3ComBrgX25Qsize.setDescription('This object applies to transparent bridging over an X25 network. It allows the specification of the maximum number of packets that can be queued on any single virtual circuit to a specific DTE neighbor when the virtual circuit on the X25 port is congested. NOTE: this object is no longer supported by NETBuilders running sw version 8.0 and greater.')
a3ComBrgX25VcLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 12, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgX25VcLimit.setReference('NETBuilder Ref. Guide, Bridge Service parameter: X25VCLimit')
if mibBuilder.loadTexts: a3ComBrgX25VcLimit.setStatus('deprecated')
if mibBuilder.loadTexts: a3ComBrgX25VcLimit.setDescription('This object allows the specification of the maximum number of virtual circuits to a specific DTE that can be established concurrently for transparent bridging over an x25 network. NOTE: this object is no longer supported by NETBuilders running sw version 8.0 and greater.')
a3ComBrgX25VcTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 12, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgX25VcTimer.setReference('NETBuilder Ref. Guide, Bridge Service parameter: X25VCTimer')
if mibBuilder.loadTexts: a3ComBrgX25VcTimer.setStatus('deprecated')
if mibBuilder.loadTexts: a3ComBrgX25VcTimer.setDescription('This object specifies the maximum amount of time, in minutes, that can elapse when there is no activity on the x25 virtual circuit to a DTE before it is cleared. NOTE: this object is no longer supported by NETBuilders running sw version 8.0 and greater.')
a3ComBrgBroadCastLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 12, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgBroadCastLimit.setReference('NETBuilder Reference Guide, Bridge Service Parameter: BroadCastLimit')
if mibBuilder.loadTexts: a3ComBrgBroadCastLimit.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgBroadCastLimit.setDescription('This object specifies the maximum rate, in packets per second, at which broadcast and multicast packets are forwarded through this port. If the number of these packets during a single time interval (specified by a3ComBrgBLimitTimer) exceeds the number allowed during that interval, as calculated from the value of this object, all further broadcast and multicast packets will be discarded for the rest of the time interval. If this object is set to zero, this feature is disabled for this port. Note, any changes to this object will only take affect after the system is rebooted.')
a3ComBrgSmdsGroupAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 12, 1, 10), SMDSAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSmdsGroupAddr.setReference('NETBuilder Reference Guide, Bridge Service Parameter: SMDSGroupAddress')
if mibBuilder.loadTexts: a3ComBrgSmdsGroupAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSmdsGroupAddr.setDescription("This identifies the SMDS Group Address that is used by the bridge to transmit packets to all the other bridges identified by this SMDS Group Address. This address is used as the SMDS destination address when transmitting spanning tree BPDU packets, all bridged broadcast and multicast packets, and bridged packets containing a destination address that has not yet been learned. If the address is less than 8 Octets, the remaining octets are padded with 0xFF's. If there is no SMDS Group Address assigned, this object will return all zeroes. Note, bridging must be enabled for any sets made to this object to be affected.")
a3ComBrgX25ProfId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 12, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgX25ProfId.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgX25ProfId.setDescription('This object specifies the X25 User ProfileID to be used for selecting a Virtual Circuit to send Bridged Packets. Range is 0..255. If the value specified is 0 then use the DTE Profile ID')
a3ComBrgX25NbrTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 13), )
if mibBuilder.loadTexts: a3ComBrgX25NbrTable.setReference('NETBuilder Ref. Guilde, Bridge Service parameter: X25Neighbor')
if mibBuilder.loadTexts: a3ComBrgX25NbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgX25NbrTable.setDescription('This table specifies the DTE address of each X25 neighbor that supports transparent bridging. The bridge will forward to the neighbors defined in this table all broadcast packets and unknown unicast packets.')
a3ComBrgX25NbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 13, 1), ).setIndexNames((0, "A3Com-Bridge-r3-MIB", "a3ComBrgX25NbrPort"), (0, "A3Com-Bridge-r3-MIB", "a3ComBrgX25NbrDTE"))
if mibBuilder.loadTexts: a3ComBrgX25NbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgX25NbrEntry.setDescription('Each entry contains the DTE address of an X25 neighbor.')
a3ComBrgX25NbrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgX25NbrPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgX25NbrPort.setDescription('The bridge port to which this entry applies.')
a3ComBrgX25NbrDTE = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 13, 1, 2), X121Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgX25NbrDTE.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgX25NbrDTE.setDescription('The X121 address of the neighbor DTE.')
a3ComBrgX25NbrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 1, 13, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgX25NbrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgX25NbrStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB.')
a3ComBrgStpMultAdd = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 2, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgStpMultAdd.setReference('NETBuilder Ref. Guide, STP Service parameter: ADDRess')
if mibBuilder.loadTexts: a3ComBrgStpMultAdd.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgStpMultAdd.setDescription('This is the multicast MAC address used by bridges running the Spanning Tree Protocol.')
a3ComBrgStpCtl = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgStpCtl.setReference('NETBuilder Ref. Guide, STP Service parameter: CONTrol')
if mibBuilder.loadTexts: a3ComBrgStpCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgStpCtl.setDescription('This object is used to enable/disable the Spanning Tree Protocol for the bridge as a whole.')
a3ComBrgStpHopCtl = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hopReduce", 1), ("noHopReduce", 2))).clone('noHopReduce')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgStpHopCtl.setReference('NETBuilder Ref. Guide, STP Service parameter: CONTrol')
if mibBuilder.loadTexts: a3ComBrgStpHopCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgStpHopCtl.setDescription('This object determines whether the bridge considers the number of hops needed to forward a packet to the root bridge when it selects a root port. If hopReduce is selected, the bridge increases its root path cost by 1. If noHopReduce is selected and two ports have the same root path cost, the port that offers the least number of hops might not be chosen as the root port.')
a3ComBrgSrMode = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ieee", 1), ("passiveBridging", 2))).clone('ieee')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrMode.setReference('NETBuilder Ref. Guide, SRT Service parameter: Mode')
if mibBuilder.loadTexts: a3ComBrgSrMode.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrMode.setDescription('This object defines the mode of source routing in use on the bridge. If ieee (1) is selected, explorer frames are modified and the forwarding path of the specifically routed frames is determined from the routing information (RI) field. If passiveBridging (2) is selected, the source routed frames are bridged across the spanning tree as if they were transparent frames without examining or updating the RI field. When in passiveBridging mode, the same ring number should be assinged to all active ports of the bridge.')
a3ComBrgSrPortTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 2), )
if mibBuilder.loadTexts: a3ComBrgSrPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrPortTable.setDescription('This table contains port specific source routing information.')
a3ComBrgSrPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 2, 1), ).setIndexNames((0, "A3Com-Bridge-r3-MIB", "a3ComBrgSrPort"))
if mibBuilder.loadTexts: a3ComBrgSrPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrPortEntry.setDescription('Each entry contains a set of information applied to a specific bridge port.')
a3ComBrgSrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgSrPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrPort.setDescription('This identifies the bridge port to which the other objects in this entry apply.')
a3ComBrgSrPortSTEHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrPortSTEHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrPortSTEHopCount.setDescription('This object contains the maximum number of routing descriptors (ie, hop count) for Spanning Tree Explorer frames.')
a3ComBrgSrPortAREHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrPortAREHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrPortAREHopCount.setDescription('This object contains the maximum number of routing descriptors (ie, hop count) for All Routes Explorer frames.')
a3ComBrgSrPortHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1440)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrPortHoldTime.setReference('NETBuilder Ref. Guide, SR Service parameter: HoldTime')
if mibBuilder.loadTexts: a3ComBrgSrPortHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrPortHoldTime.setDescription('This parameter specifies the time interval, in minutes, that an inactive route entry can reside in the source routing table.')
a3ComBrgSrPortMinAccessPrior = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrPortMinAccessPrior.setReference('NETBuilder Ref. Guide, SR Service parameter: MinAccessPrior')
if mibBuilder.loadTexts: a3ComBrgSrPortMinAccessPrior.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrPortMinAccessPrior.setDescription('This parameter determines the minimum access priority used for outoing frames on this port. End systems usually have a low access priority while bridges have a medium priority. This allows bridge, which typically handle larger volumes of data, to get the token faster than end systems. If the user priority of the frame is greateer than the minumum access priority, the user priority is used as the access priority. The user priority of the frame is determined by the access priority of the incoming frame.')
a3ComBrgSrWanAddrTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 3), )
if mibBuilder.loadTexts: a3ComBrgSrWanAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrWanAddrTable.setDescription('A table containing mappings between Ring Number, Bridge Number, and Wide Area Addresses. This information is learned from Explorer Frames sent by end stations.')
a3ComBrgSrWanAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 3, 1), ).setIndexNames((0, "A3Com-Bridge-r3-MIB", "a3ComBrgSrWAportIndex"), (0, "A3Com-Bridge-r3-MIB", "a3ComBrgSrWAringNum"), (0, "A3Com-Bridge-r3-MIB", "a3ComBrgSrWAbrgNum"))
if mibBuilder.loadTexts: a3ComBrgSrWanAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrWanAddrEntry.setDescription('Each entry contains a single Ring Number, Bridge Number, Wide Area Address mapping.')
a3ComBrgSrWAportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgSrWAportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrWAportIndex.setDescription('This identifies the bridge port that is connected to the ring identified by a3ComBrgSrWAringNum.')
a3ComBrgSrWAringNum = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgSrWAringNum.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrWAringNum.setDescription('This identifies a specific wide area network. When a source route frame is bridged to this ring number, and to the bridge identified by a3ComBrgSrWAbrgNum, the Wide Area Address identified by the corresponding instance of a3ComBrgSrWAddress is used to forward the frame to the proper bridge.')
a3ComBrgSrWAbrgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgSrWAbrgNum.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrWAbrgNum.setDescription('This identifies the bridge associated with the Wide Area Address identified by a3ComBrgSrWAddress.')
a3ComBrgSrWAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 3, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgSrWAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrWAddress.setDescription('This identifies the Wide Area Address associated with a specific ring number and bridge number. These are identified by the corresponding instances of a3ComBrgSrWAringNum and a3ComBrgSrWAbrgNum.')
a3ComBrgSrGwVirRing = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrGwVirRing.setReference('NETBuilder Ref. Guide, SR Service parameter: GatewayVRing')
if mibBuilder.loadTexts: a3ComBrgSrGwVirRing.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrGwVirRing.setDescription("This parameter is used whenever SRTG is bridging packets between TB and SR domains. Before forwarding packets from a TB domain, SRTG specifically adds this 'virtual' ring number and its own bridge number to the source route information of the destination station retrieved from the SRDB. Thus from a source routing station's point of view, the entire transparent bridge LAN appears as a single source routed ring. If this parameter has the value 0, no virtual ring number is added.")
a3ComBrgSrGwContTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 5), )
if mibBuilder.loadTexts: a3ComBrgSrGwContTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrGwContTable.setDescription('')
a3ComBrgSrGwContEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 5, 1), ).setIndexNames((0, "A3Com-Bridge-r3-MIB", "a3ComBrgSrGwContPort"))
if mibBuilder.loadTexts: a3ComBrgSrGwContEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrGwContEntry.setDescription('Each entry in this table control the behavior of the SRT Gateway feature for a specific port.')
a3ComBrgSrGwContPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgSrGwContPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrGwContPort.setDescription('This identifies the bridge port to which the other objects in this entry apply.')
a3ComBrgSrGwCont = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrGwCont.setReference('NETBuilder Ref. Guide, SR Service parameter: GatewayControl')
if mibBuilder.loadTexts: a3ComBrgSrGwCont.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrGwCont.setDescription('This parameter is used to enable or disable the SRT Gateway feature for this port.')
a3ComBrgSrGwContEncapMode = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ieeeMode", 1), ("etherMode", 2))).clone('ieeeMode')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrGwContEncapMode.setReference('NETBuilder Ref. Guide, SR Service parameter: GatewayControl')
if mibBuilder.loadTexts: a3ComBrgSrGwContEncapMode.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrGwContEncapMode.setDescription("This parameter is used to control how packets using Token Ring LLC-based protocols are converted when bridged to Ethernet LANs. If this object has the value 'ieeeMode', those packets will be translated into IEEE 802.2 frames. Otherwise, they will be converted into Ethernet Version II format. Note, if the type of frame used by the destination is known (ie, if autoMode is selected and the station is known), this parameter is ignored and the previously seen frame type is used.")
a3ComBrgSrGwContAutoMode = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("autoMode", 1), ("noAutoMode", 2))).clone('autoMode')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrGwContAutoMode.setReference('NETBuilder Ref. Guide, SR Service parameter: GatewayControl')
if mibBuilder.loadTexts: a3ComBrgSrGwContAutoMode.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrGwContAutoMode.setDescription('This parameter specifies whether or not the encapsulation format of each end stations is stored.')
a3ComBrgSrRDTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 6), )
if mibBuilder.loadTexts: a3ComBrgSrRDTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrRDTable.setDescription('This table specifies whether end system source routing is enabled on for each port on the system. There are separate controls for each protocol that may use source routing.')
a3ComBrgSrRDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 6, 1), ).setIndexNames((0, "A3Com-Bridge-r3-MIB", "a3ComBrgSrRDPort"))
if mibBuilder.loadTexts: a3ComBrgSrRDEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrRDEntry.setDescription('Each entry applies to a specific port.')
a3ComBrgSrRDPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgSrRDPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrRDPort.setDescription('This identifies the bridge port to which the other objects in this entry apply.')
a3ComBrgSrRDAppleTalk = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("appleTalk", 1), ("noAppleTalk", 2))).clone('noAppleTalk')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrRDAppleTalk.setReference('NETBuilder Ref. Guide, SR Service parameter: RouteDiscovery')
if mibBuilder.loadTexts: a3ComBrgSrRDAppleTalk.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrRDAppleTalk.setDescription('This specifies whether route discovery is initiated for AppleTalke end system packets. This discovery process occurs when a route to the end system does not exist in the local source routing table. If this is set to noAppleTalk, all AppleTalk end system packets are sent as transparent frames.')
a3ComBrgSrRDClnp = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clnp", 1), ("noClnp", 2))).clone('noClnp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrRDClnp.setReference('NETBuilder Ref. Guide, SR Service parameter: RouteDiscovery')
if mibBuilder.loadTexts: a3ComBrgSrRDClnp.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrRDClnp.setDescription('This specifies whether route discovery is initiated for CLNP end system packets. This discovery process occurs when a route to the end system does not exist in the local source routing table. If this is set to noClnp, all CLNP end system packets are sent as transparent frames.')
a3ComBrgSrRDDecNet = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("decNet", 1), ("noDecNet", 2))).clone('noDecNet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrRDDecNet.setReference('NETBuilder Ref. Guide, SR Service parameter: RouteDiscovery')
if mibBuilder.loadTexts: a3ComBrgSrRDDecNet.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrRDDecNet.setDescription('This specifies whether route discovery is initiated for DECNET end system packets. This discovery process occurs when a route to the end system does not exist in the local source routing table. If this is set to noDecNet, all DECNET end system packets are sent as transparent frames.')
a3ComBrgSrRDDlTest = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dlTest", 1), ("noDlTest", 2))).clone('noDlTest')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrRDDlTest.setReference('NETBuilder Ref. Guide, SR Service parameter: RouteDiscovery')
if mibBuilder.loadTexts: a3ComBrgSrRDDlTest.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrRDDlTest.setDescription('This specifies whether route discovery is initiated for DlTest end system packets. This discovery process occurs when a route to the end system does not exist in the local source routing table. If this is set to noDlTest, all DlTest end system packets are sent as transparent frames.')
a3ComBrgSrRDIp = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ip", 1), ("noIp", 2))).clone('noIp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrRDIp.setReference('NETBuilder Ref. Guide, SR Service parameter: RouteDiscovery')
if mibBuilder.loadTexts: a3ComBrgSrRDIp.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrRDIp.setDescription('This specifies whether route discovery is initiated for IP end system packets. This discovery process occurs when a route to the end system does not exist in the local source routing table. If this is set to noIp, all IP end system packets are sent as transparent frames.')
a3ComBrgSrRDIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipx", 1), ("noIpx", 2))).clone('noIpx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrRDIpx.setReference('NETBuilder Ref. Guide, SR Service parameter: RouteDiscovery')
if mibBuilder.loadTexts: a3ComBrgSrRDIpx.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrRDIpx.setDescription('This specifies whether route discovery is initiated for IPX end system packets. This discovery process occurs when a route to the end system does not exist in the local source routing table. If this is set to noIpx, all IPX end system packets are sent as transparent frames.')
a3ComBrgSrRDLlc2 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("llc2", 1), ("noLlc2", 2))).clone('noLlc2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrRDLlc2.setReference('NETBuilder Ref. Guide, SR Service parameter: RouteDiscovery')
if mibBuilder.loadTexts: a3ComBrgSrRDLlc2.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrRDLlc2.setDescription('This specifies whether route discovery is initiated for LLC2 end system packets. This discovery process occurs when a route to the end system does not exist in the local source routing table. If this is set to noLlc2, all LLC2 end system packets are sent as transparent frames.')
a3ComBrgSrRDVines = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vines", 1), ("noVines", 2))).clone('noVines')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3ComBrgSrRDVines.setReference('NETBuilder Ref. Guide, SR Service parameter: RouteDiscovery')
if mibBuilder.loadTexts: a3ComBrgSrRDVines.setStatus('mandatory')
if mibBuilder.loadTexts: a3ComBrgSrRDVines.setDescription('This specifies whether route discovery is initiated for Vines end system packets. This discovery process occurs when a route to the end system does not exist in the local source routing table. If this is set to noVines, all Vines end system packets are sent as transparent frames.')
a3ComBrgSrTunVRing = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgSrTunVRing.setStatus('deprecated')
if mibBuilder.loadTexts: a3ComBrgSrTunVRing.setDescription('This object is used only by the Smart Filtering feature.')
a3ComBrgSrCNodeAddr = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 9, 3, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3ComBrgSrCNodeAddr.setStatus('deprecated')
if mibBuilder.loadTexts: a3ComBrgSrCNodeAddr.setDescription('This object is used only by the Smart Filtering feature.')
mibBuilder.exportSymbols("A3Com-Bridge-r3-MIB", a3ComBrgStExtWaAddress=a3ComBrgStExtWaAddress, a3ComBrgStpCtl=a3ComBrgStpCtl, brouterMIB=brouterMIB, a3ComBrgSrRDDlTest=a3ComBrgSrRDDlTest, a3ComBrgSrRDEntry=a3ComBrgSrRDEntry, a3ComBrgSrRDPort=a3ComBrgSrRDPort, a3ComBrgSrGwVirRing=a3ComBrgSrGwVirRing, a3ComBrgSrCNodeAddr=a3ComBrgSrCNodeAddr, a3ComBrgSrRDIpx=a3ComBrgSrRDIpx, a3ComBrgLearnCtl=a3ComBrgLearnCtl, a3ComBrgStpHopCtl=a3ComBrgStpHopCtl, a3ComBrgSrPortAREHopCount=a3ComBrgSrPortAREHopCount, a3ComBrgSrWAringNum=a3ComBrgSrWAringNum, a3ComBrgSrPortTable=a3ComBrgSrPortTable, a3ComBridge=a3ComBridge, a3ComBrgBroadCastLimit=a3ComBrgBroadCastLimit, a3ComBrgSmdsGroupAddr=a3ComBrgSmdsGroupAddr, a3ComBrgSrWAbrgNum=a3ComBrgSrWAbrgNum, a3ComBrgSrWanAddrTable=a3ComBrgSrWanAddrTable, a3ComBrgSrGwContTable=a3ComBrgSrGwContTable, a3ComBrgFwTblSize=a3ComBrgFwTblSize, a3ComBrgSrRDVines=a3ComBrgSrRDVines, a3ComBrgGen=a3ComBrgGen, a3ComBrgStExtTable=a3ComBrgStExtTable, a3ComBrgSrGwContPort=a3ComBrgSrGwContPort, a3ComBrgSrPort=a3ComBrgSrPort, a3ComBrgSrPortEntry=a3ComBrgSrPortEntry, a3ComBrgX25NbrStatus=a3ComBrgX25NbrStatus, a3ComBrgSr=a3ComBrgSr, a3ComBrgFwTblCtl=a3ComBrgFwTblCtl, a3ComBrgX25NbrPort=a3ComBrgX25NbrPort, a3ComBrgX25NbrEntry=a3ComBrgX25NbrEntry, a3ComBrgFwallCtl=a3ComBrgFwallCtl, a3ComBrgSrRDLlc2=a3ComBrgSrRDLlc2, a3ComBrgX25ProfId=a3ComBrgX25ProfId, a3ComBrgStExtEntry=a3ComBrgStExtEntry, a3ComBrgX25Pid=a3ComBrgX25Pid, a3ComBrgSrRDAppleTalk=a3ComBrgSrRDAppleTalk, a3ComBrgSrGwContAutoMode=a3ComBrgSrGwContAutoMode, a3ComBrgX25NbrDTE=a3ComBrgX25NbrDTE, a3ComBrgSrRDTable=a3ComBrgSrRDTable, a3ComBrgSrcSecCtl=a3ComBrgSrcSecCtl, a3ComBrgFdbExtAdd=a3ComBrgFdbExtAdd, a3ComBrgStp=a3ComBrgStp, a3ComBrgX25VcTimer=a3ComBrgX25VcTimer, a3ComBrgPortEntry=a3ComBrgPortEntry, a3ComBrgAppleCtl=a3ComBrgAppleCtl, a3ComBrgSrGwContEntry=a3ComBrgSrGwContEntry, SMDSAddress=SMDSAddress, a3ComBrgAgeCtl=a3ComBrgAgeCtl, a3ComBrgFdbExtEntry=a3ComBrgFdbExtEntry, a3ComBrgSrWAportIndex=a3ComBrgSrWAportIndex, a3ComBrgSrPortHoldTime=a3ComBrgSrPortHoldTime, a3ComBrgStExtRcvPort=a3ComBrgStExtRcvPort, a3ComBrgSrWAddress=a3ComBrgSrWAddress, a3ComBrgBLimitTimer=a3ComBrgBLimitTimer, a3ComBrgSrRDDecNet=a3ComBrgSrRDDecNet, a3ComBrgX25NbrTable=a3ComBrgX25NbrTable, a3ComBrgSrMode=a3ComBrgSrMode, a3Com=a3Com, a3ComBrgSrTunVRing=a3ComBrgSrTunVRing, a3ComBrgSrRDIp=a3ComBrgSrRDIp, a3ComBrgSrGwContEncapMode=a3ComBrgSrGwContEncapMode, a3ComBrgPortCtl=a3ComBrgPortCtl, a3ComBrgSrPortMinAccessPrior=a3ComBrgSrPortMinAccessPrior, a3ComBrgDstSecCtl=a3ComBrgDstSecCtl, a3ComBrgX25Qsize=a3ComBrgX25Qsize, a3ComBrgFdbExtTable=a3ComBrgFdbExtTable, X121Address=X121Address, a3ComBrgStpMultAdd=a3ComBrgStpMultAdd, a3ComBrgSrWanAddrEntry=a3ComBrgSrWanAddrEntry, a3ComBrgFdbExtWaAddress=a3ComBrgFdbExtWaAddress, a3ComBrgPortIndex=a3ComBrgPortIndex, a3ComBrgCtl=a3ComBrgCtl, a3ComBrgForwardCtl=a3ComBrgForwardCtl, a3ComBrgX25VcLimit=a3ComBrgX25VcLimit, a3ComBrgSrRDClnp=a3ComBrgSrRDClnp, a3ComBrgStExtAdd=a3ComBrgStExtAdd, a3ComBrgPortTable=a3ComBrgPortTable, RowStatus=RowStatus, a3ComBrgSrGwCont=a3ComBrgSrGwCont, a3ComBrgSrPortSTEHopCount=a3ComBrgSrPortSTEHopCount)

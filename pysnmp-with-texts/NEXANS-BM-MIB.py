#
# PySNMP MIB module NEXANS-BM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NEXANS-BM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:21:05 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
nexansANS, = mibBuilder.importSymbols("NEXANS-MIB", "nexansANS")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, NotificationType, IpAddress, Bits, Counter64, Counter32, MibIdentifier, iso, Gauge32, Unsigned32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "NotificationType", "IpAddress", "Bits", "Counter64", "Counter32", "MibIdentifier", "iso", "Gauge32", "Unsigned32", "ModuleIdentity")
TextualConvention, DisplayString, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "MacAddress")
bmSwitchMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 266, 20))
bmSwitchMIB.setRevisions(('2014-01-29 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: bmSwitchMIB.setRevisionsDescriptions(('Revision 4.01',))
if mibBuilder.loadTexts: bmSwitchMIB.setLastUpdated('201401290000Z')
if mibBuilder.loadTexts: bmSwitchMIB.setOrganization('Nexans Advanced Networking Solutions')
if mibBuilder.loadTexts: bmSwitchMIB.setContactInfo('h.theissen@nexans.com')
if mibBuilder.loadTexts: bmSwitchMIB.setDescription('MIB for Nexans switches')
bmTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 266, 20, 0))
bmSwitchInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 266, 20, 1))
bmSwitchAdmin = MibIdentifier((1, 3, 6, 1, 4, 1, 266, 20, 2))
bmSwitchPort = MibIdentifier((1, 3, 6, 1, 4, 1, 266, 20, 3))
bmSwitchVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 266, 20, 4))
bmSwitchSfp = MibIdentifier((1, 3, 6, 1, 4, 1, 266, 20, 5))
infoDescr = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoDescr.setStatus('current')
if mibBuilder.loadTexts: infoDescr.setDescription('The ordering description of the switch')
infoType = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoType.setStatus('current')
if mibBuilder.loadTexts: infoType.setDescription('The infoType indentifies the product familie of this switch. Refer to NEXANS-MIB for the currently defined families')
infoProductNo = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoProductNo.setStatus('current')
if mibBuilder.loadTexts: infoProductNo.setDescription('The product number of the switch (8830xxxx)')
infoSerie = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoSerie.setStatus('current')
if mibBuilder.loadTexts: infoSerie.setDescription('The production series of the switch')
infoSeriesNo = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoSeriesNo.setStatus('current')
if mibBuilder.loadTexts: infoSeriesNo.setDescription('The production number of the switch')
infoManufactureDate = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoManufactureDate.setStatus('current')
if mibBuilder.loadTexts: infoManufactureDate.setDescription('The manufacturing date of the switch. The display format is dd.mm.jjjj')
infoSwitchHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoSwitchHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: infoSwitchHardwareVersion.setDescription('The hardware version of the base switch.')
infoMgmtHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoMgmtHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: infoMgmtHardwareVersion.setDescription('The hardware version of the plug-in management module.')
infoMgmtFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoMgmtFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: infoMgmtFirmwareVersion.setDescription('The firmware version of the management module.')
infoNoOfPorts = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoNoOfPorts.setStatus('current')
if mibBuilder.loadTexts: infoNoOfPorts.setDescription('The number of switching ports within the system. This includes all user and uplink ports.')
infoNoOfReboots = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoNoOfReboots.setStatus('current')
if mibBuilder.loadTexts: infoNoOfReboots.setDescription("The number of reboots since the manufacturing date. This counter can't be cleared by any admin command.")
infoTemperature = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoTemperature.setStatus('current')
if mibBuilder.loadTexts: infoTemperature.setDescription('The case temperature in degree Celsius of the switch.')
infoTemperatureMaxAllowed = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoTemperatureMaxAllowed.setStatus('current')
if mibBuilder.loadTexts: infoTemperatureMaxAllowed.setDescription('The upper limit of the allowed temperature range in degree Celsius. If the current temperature indicated by infoTemperature exceeds infoTemperatureMaxAllowed, the switch sends an switchOverTemperature alarm trap.')
infoPowerVoltage2500 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoPowerVoltage2500.setStatus('current')
if mibBuilder.loadTexts: infoPowerVoltage2500.setDescription('The 2.5 volt supply voltage in millivolts. The allowed range is 2300...2700 millivolts.')
infoPowerVoltage3300 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoPowerVoltage3300.setStatus('current')
if mibBuilder.loadTexts: infoPowerVoltage3300.setDescription('The 3.3 volt supply voltage in millivolts. The allowed range is 3100...3500 millivolts.')
infoUnauthIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 16), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoUnauthIpAddr.setStatus('current')
if mibBuilder.loadTexts: infoUnauthIpAddr.setDescription('The source IP address of the station which generated the last authentication failure. The infoUnauthAddr is also reported in the switchMgmtAuthFailure alarm trap.')
infoSecurityFailMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoSecurityFailMacAddr.setStatus('current')
if mibBuilder.loadTexts: infoSecurityFailMacAddr.setDescription('The source MAC address of the station which has generated a the last port security failure. The infoSecurityFailMacAddr is also reported in the portSecurityFailure alarm trap.')
infoNewMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoNewMacAddr.setStatus('current')
if mibBuilder.loadTexts: infoNewMacAddr.setDescription('The last new source MAC address seen on a port witch has portsecurity enabled. The infoNewMacAddr is also reported in the newMacAddress trap.')
infoPoeInputVoltage = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoPoeInputVoltage.setStatus('current')
if mibBuilder.loadTexts: infoPoeInputVoltage.setDescription('The current PoE input voltage delivered from the power supply.')
infoPoeInputPower = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoPoeInputPower.setStatus('current')
if mibBuilder.loadTexts: infoPoeInputPower.setDescription('The current PoE input power delivered from the power supply.')
infoAlarmStateM1 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notSupported", 1), ("alarmOff", 2), ("alarmOn", 3), ("alarmOnLinkDown", 4), ("alarmOnForced", 5), ("alarmOffForced", 6), ("alarmOnPowerSupplyS1", 7), ("alarmOnPowerSupplyS2", 8), ("alarmOnPowerSupplyS1orS2", 9), ("alarmOnFunctionInputShorted", 10), ("alarmOnFunctionInputOpen", 11), ("alarmOnRemoteFunctionInput", 12), ("alarmOnRemoteAlarmDestTable", 13), ("alarmOnLocalAlarmDestTable", 14), ("alarmContactForcedShorted", 15), ("alarmContactForcedOpen", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoAlarmStateM1.setStatus('current')
if mibBuilder.loadTexts: infoAlarmStateM1.setDescription('The current state of the industrial alarm output M1.')
infoAlarmStateM2 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notSupported", 1), ("alarmOff", 2), ("alarmOn", 3), ("alarmOnLinkDown", 4), ("alarmOnForced", 5), ("alarmOffForced", 6), ("alarmOnPowerSupplyS1", 7), ("alarmOnPowerSupplyS2", 8), ("alarmOnPowerSupplyS1orS2", 9), ("alarmOnFunctionInputShorted", 10), ("alarmOnFunctionInputOpen", 11), ("alarmOnRemoteFunctionInput", 12), ("alarmOnRemoteAlarmDestTable", 13), ("alarmOnLocalAlarmDestTable", 14), ("alarmContactForcedShorted", 15), ("alarmContactForcedOpen", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoAlarmStateM2.setStatus('current')
if mibBuilder.loadTexts: infoAlarmStateM2.setDescription('The current state of the industrial alarm output M2.')
infoLastTftpMessage = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: infoLastTftpMessage.setStatus('current')
if mibBuilder.loadTexts: infoLastTftpMessage.setDescription('The message of the last successful or failed TFTP transfer. This does not include TFTP transfers executed from Device Manager.')
infoLastSfpEventMessage = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: infoLastSfpEventMessage.setStatus('current')
if mibBuilder.loadTexts: infoLastSfpEventMessage.setDescription('The last event message from one of the available SFP modules.')
infoLastInternalMgmtWarning = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: infoLastInternalMgmtWarning.setStatus('current')
if mibBuilder.loadTexts: infoLastInternalMgmtWarning.setDescription('The last internal management warning message.')
infoFunctionInputStateF1 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("functionInputShorted", 2), ("functionInputOpen", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoFunctionInputStateF1.setStatus('current')
if mibBuilder.loadTexts: infoFunctionInputStateF1.setDescription('The current state of the function input F1.')
infoTotalConfigChanges = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoTotalConfigChanges.setStatus('current')
if mibBuilder.loadTexts: infoTotalConfigChanges.setDescription('The number of total configurations changes.')
adminReset = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("resetIdle", 1), ("resetCounters", 2), ("rebootSwitch", 3), ("rebootToFactoryDefaults", 4), ("renewIpAndVlanParameter", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminReset.setStatus('current')
if mibBuilder.loadTexts: adminReset.setDescription('Writing this object causes the switch to perform a reset operation. The following reset types are supported. Set Values: resetCounters(2) This action resets all error and statistic counters to zero. This actions will NOT reboot the switch. rebootSwitch(3) This action resets switch and management. All counters, timers and other volatile data are reset to there power-up values stored in flash. This actions will reboot the switch. rebootToFactoryDefaults(4) This action resets switch and management. All volatile and nonvolatile data are reset to there power-up or factory default values. This actions will reboot the switch. renewIpAndVlanParameter(5) This action reinitializes the IP and VLAN module of the switch so that the actually set IP and VLAN parameters will take affect. This actions will NOT reboot the switch. Get values: resetIdle(1) Reading this object will allways return resetIdle(1).')
adminAgentDhcp = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAgentDhcp.setStatus('current')
if mibBuilder.loadTexts: adminAgentDhcp.setDescription('If set to enable(1), the switch tries to get his IP parameter via DHCP. If set to disable(2), the switch uses the IP parameters defined with adminIpAddress, adminDefRouterIpAddress and adminNetmask. Changes of this value will take affect after the next switch reboot or after setting adminReset to renewIpAndVlanParameter(5).')
adminAgentIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAgentIpAddress.setStatus('current')
if mibBuilder.loadTexts: adminAgentIpAddress.setDescription("The IP address of the switch agent's ethernet interface. If the value of adminDHCP is enable(1) this value is read-only. Changes of this value will take affect after the next switch reboot or after setting adminReset to renewIpAndVlanParameter(5).")
adminAgentPhysAddress = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adminAgentPhysAddress.setStatus('current')
if mibBuilder.loadTexts: adminAgentPhysAddress.setDescription('The Ethernet MAC address of the switch agent.')
adminAgentDefRouterIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAgentDefRouterIpAddress.setStatus('current')
if mibBuilder.loadTexts: adminAgentDefRouterIpAddress.setDescription('The IP address of the default Router. If the value of adminDHCP is enable(1) this value is read-only. Changes of this value will take affect after the next switch reboot or after setting adminReset to renewIpAndVlanParameter(5).')
adminAgentNetmask = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAgentNetmask.setStatus('current')
if mibBuilder.loadTexts: adminAgentNetmask.setDescription('The IP Netmask of the connected network. If the value of adminDHCP is enable(1) this value is read-only. Changes of this value will take affect after the next switch reboot or after setting adminReset to renewIpAndVlanParameter(5).')
adminAgentDhcpServerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adminAgentDhcpServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: adminAgentDhcpServerIpAddress.setDescription('The IP address of the last used DHCP server.')
adminAgentVlanId = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAgentVlanId.setStatus('current')
if mibBuilder.loadTexts: adminAgentVlanId.setDescription('The VLAN-ID assigned to the agent. Changes of this value will take affect after the next switch reboot or after setting adminReset to renewIpAndVlanParameter(5).')
adminAgentPrioValue = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAgentPrioValue.setStatus('current')
if mibBuilder.loadTexts: adminAgentPrioValue.setDescription('The IEEE802.1Q priority value and queue assigned to all frames transmitted by the agent. The definition between value, service class and queue are as follows: 0=Best Effort (queue=0), 1=Background (queue=0), 2=Reserved (queue=1), 3=Excellent Effort (queue=1), 4=Controlled Load (queue=2), 5=Video (queue=2), 6=Voice (queue=3), 7=Network Control (queue=3)')
adminAddrAgingTimeMinutes = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 68)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAddrAgingTimeMinutes.setStatus('current')
if mibBuilder.loadTexts: adminAddrAgingTimeMinutes.setDescription('The timeout period in minutes for aging out dynamically learned MAC addresses . The allowed range is 1 minute to 68 minutes.')
adminSwitchPortMirror = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminSwitchPortMirror.setStatus('current')
if mibBuilder.loadTexts: adminSwitchPortMirror.setDescription("If set to enable(1), the switch doesn't use address learning. This affects that any received packet will be forwarded to all ports of the particular VLAN. The switch acts like a hub within each VLAN.")
adminMgmtAccessList = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disable", 1), ("enableForNexManAccess", 2), ("enableForAllAccess", 3), ("enableForSnmpAccess", 4))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminMgmtAccessList.setStatus('current')
if mibBuilder.loadTexts: adminMgmtAccessList.setDescription('If set to enableForNexManAccess(2) or enableForAllAccess(3), the switch only accepts read or write requests from IP addresses which are listed in the management accesslist.')
adminSwitchPoEPowerLimit = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminSwitchPoEPowerLimit.setStatus('current')
if mibBuilder.loadTexts: adminSwitchPoEPowerLimit.setDescription('The limit for the POE input power from the power supply in VA. If the current power exceeds this value a overload conditions occurs and the inline power for the highest port number will be switched off.')
adminSwitchVlanTableMode = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("staticMode", 1), ("dynamicMode", 2), ("staticModeVlans64", 3), ("staticModePortBased", 4))).clone('staticMode')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminSwitchVlanTableMode.setStatus('current')
if mibBuilder.loadTexts: adminSwitchVlanTableMode.setDescription("If set to staticMode(1) or staticModeVlans64(3) any existing VLAN table entry must be removed manually by management. With staticMode(1) total 16 VLAN-ID's and with staticModeVlans64(3) total 64 VLAN-ID's are supported. If set to dynamicMode(2) all unused VLAN-ID's are removed automatically by the switch. This means, that all VLAN-ID's not assigned to a port Default-VLAND or to the Unsecure-VLAN will be removed.")
adminUnsecureVlanId = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminUnsecureVlanId.setStatus('current')
if mibBuilder.loadTexts: adminUnsecureVlanId.setDescription('The VLAN-ID of the unsecure VLAN')
adminDot1xAuthFailureVlanId = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminDot1xAuthFailureVlanId.setStatus('current')
if mibBuilder.loadTexts: adminDot1xAuthFailureVlanId.setDescription('The VLAN-ID in the case of an IEEE802.1X authentication failure. Setting the VLAN-ID to 0 disables the authentication failure VLAN.')
adminTftpAccess = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tftpAccessDisable", 1), ("tftpAccessReadOnly", 2), ("tftpAccessReadWrite", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminTftpAccess.setStatus('current')
if mibBuilder.loadTexts: adminTftpAccess.setDescription("If 'TFTP authentication via SNMP' is disabled, this value is allways tftpAccessDisable(1). If 'TFTP authentication via SNMP' is read/only or read/write, an this object is read, the value is tftpAccessReadOnly(2) and the agent allowes a single TFTP read access of the switch configuration. If 'TFTP authentication via SNMP' is read/write, this value can be set to tftpAccessReadWrite(3) and the agent allowes a single TFTP read or write access to the configuration or a single firmware upgrade. After finishing the TFTP transfer, this value will return to ftpAccessDisable(1) automatically. Note: If the 'NexMan authentication mode' is set to 'none', TFTP read and write access is allways allowed.")
adminSnmpMacTableMode = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("listAllPorts", 1), ("listUserPortsOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminSnmpMacTableMode.setStatus('current')
if mibBuilder.loadTexts: adminSnmpMacTableMode.setDescription('If set to listAllPorts(1) the BRIDGE-MIBs dot1dTpFdbTable lits MAC address of all ports. If set to listUserPortsOnly(2) the BRIDGE-MIBs dot1dTpFdbTable lits only MAC addresses of user ports. MAC addresses of uplink/downlink ports are ignored.')
adminAlarmM1 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("notSupported", 1), ("alarmLinkDown", 2), ("alarmOnForced", 3), ("alarmOffForced", 4), ("alarmPowerSupply1Failure", 5), ("alarmPowerSupply2Failure", 6), ("alarmPowerSupply1or2Failure", 7), ("alarmLocalFunctionInputShorted", 8), ("alarmLocalFunctionInputOpen", 9), ("alarmRemoteFunctionInput", 10), ("alarmRemoteAlarmDestination", 11), ("alarmLocalAlarmDestination", 12), ("alarmForceContactShorted", 13), ("alarmForceContactOpen", 14), ("alarmForceContactOpenShorted", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAlarmM1.setStatus('current')
if mibBuilder.loadTexts: adminAlarmM1.setDescription('The current setup of the industrial alarm output M1.')
adminAlarmM2 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("notSupported", 1), ("alarmLinkDown", 2), ("alarmOnForced", 3), ("alarmOffForced", 4), ("alarmPowerSupply1Failure", 5), ("alarmPowerSupply2Failure", 6), ("alarmPowerSupply1or2Failure", 7), ("alarmLocalFunctionInputShorted", 8), ("alarmLocalFunctionInputOpen", 9), ("alarmRemoteFunctionInput", 10), ("alarmRemoteAlarmDestination", 11), ("alarmLocalAlarmDestination", 12), ("alarmForceContactShorted", 13), ("alarmForceContactOpen", 14), ("alarmForceContactOpenShorted", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAlarmM2.setStatus('current')
if mibBuilder.loadTexts: adminAlarmM2.setDescription('The current setup of the industrial alarm output M2.')
adminMemoryCardMode = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("mcEnabled", 2), ("mcDisabled", 3), ("mcPermanentDisabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminMemoryCardMode.setStatus('current')
if mibBuilder.loadTexts: adminMemoryCardMode.setDescription("If set to mcDisabled(2), the memory card is disabled but may be re-enabled later by writing mcEnabled(1). If set to mcPermanentDisabled(3), the memory card is disabled permanently and can't be re-enabled by management or any kind of hardware reset.")
adminAlarmNameM1 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('not defined')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAlarmNameM1.setStatus('current')
if mibBuilder.loadTexts: adminAlarmNameM1.setDescription('An administratively assigned name for alarm output M1. The configured name will be send as part of alarm message switchIndustrialAlarmM1.')
adminAlarmNameM2 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('not defined')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAlarmNameM2.setStatus('current')
if mibBuilder.loadTexts: adminAlarmNameM2.setDescription('An administratively assigned name for alarm output M1. The configured name will be send as part of alarm message switchIndustrialAlarmM2.')
adminFunctionInputNameF1 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('not defined')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminFunctionInputNameF1.setStatus('current')
if mibBuilder.loadTexts: adminFunctionInputNameF1.setDescription('An administratively assigned name for function input F1. The configured name will be send as part of alarm message switchFunctionInputAlarm.')
adminLedGlobalMode = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ledGlobalModeNotSupported", 1), ("ledGlobalModeStandard", 2), ("ledGlobalModeAllOff", 3), ("ledGlobalModeAllOn", 4), ("ledGlobalModeMgmtOnly", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminLedGlobalMode.setStatus('current')
if mibBuilder.loadTexts: adminLedGlobalMode.setDescription('Set the global mode for all front side LEDs.')
bmSwitchPortTable = MibTable((1, 3, 6, 1, 4, 1, 266, 20, 3, 1), )
if mibBuilder.loadTexts: bmSwitchPortTable.setStatus('current')
if mibBuilder.loadTexts: bmSwitchPortTable.setDescription('A list of port entries for the switch. The number of entries is defined by ifNumber.')
bmSwitchPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1), ).setIndexNames((0, "NEXANS-BM-MIB", "portIndex"))
if mibBuilder.loadTexts: bmSwitchPortEntry.setStatus('current')
if mibBuilder.loadTexts: bmSwitchPortEntry.setDescription('A port entry in the table containing information about a port in the switch.')
portIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIndex.setStatus('current')
if mibBuilder.loadTexts: portIndex.setDescription('A unique value for each port. Its value ranges between 1 and the value of ifNumber. The port identified by a particular value of this index is the same port as identified by the same value of ifIndex.')
portDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDescr.setStatus('current')
if mibBuilder.loadTexts: portDescr.setDescription('A textual string containing information about the interface. Same as ifDescr.')
portName = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portName.setStatus('current')
if mibBuilder.loadTexts: portName.setDescription('An administratively assigned name for this port.')
portAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("allwaysEnable", 1), ("enable", 2), ("adminDisable", 3), ("securityDisable", 4), ("loopDisable", 5), ("bpduDisable", 6), ("udldDisable", 7), ("linkFlapDisable", 8), ("errorCountDisable", 9), ("sfpErrorDisable", 10), ("redundanyLoopDisable", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAdminState.setStatus('current')
if mibBuilder.loadTexts: portAdminState.setDescription('A value indicating the current state of the port. A SET to this object enables (2) or disables (3) the port. The possible values returned by GET are: allwaysEnable(1) The port is always enabled (usually the uplink port). enable(2) The port is active to transmit or receive data. disable(3) The port is inactive and unable to transmit or receive data. securityDisable(4) The port has been automatically disabled because of security violation. loopDisable(5) The port has been automatically disabled because of the active loop protection. bpduDisable(6) The port has been automatically disabled because a BPDU has been received on a Spanning Tree disabled port. udldDisable(7) The port has been automatically disabled because of the UDLD function. linkFlapDisable(8) The port has been automatically disabled because of the link flap protection. errorCountDisable(9) The port has been automatically disabled because of the error counter incrementation detection. sfpErrorDisable(10) The port has been automatically disabled because of wromg SFP inserted or SFP malfunction. redundanyLoopDisable(11) The port has been automatically disabled because of loop detection while spannung tree was enabled')
portSpeedDuplexSetup = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("autoneg", 1), ("fix10Hdx", 2), ("fix10Fdx", 3), ("fix100Hdx", 4), ("fix100Fdx", 5), ("fix1000Hdx", 7), ("fix1000Fdx", 8), ("eco", 9), ("ecoOverTemp", 10), ("ecoPowerSave", 11), ("fix1000fdxNoAutoneg", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSpeedDuplexSetup.setStatus('current')
if mibBuilder.loadTexts: portSpeedDuplexSetup.setDescription('A value indicating the current speed and duplex link setup. Independent of portSpeedDuplexSetup the port may be disabled by portAdminState.')
portLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("down", 1), ("up10Hdx", 2), ("up10Fdx", 3), ("up100Hdx", 4), ("up100Fdx", 5), ("up1000Hdx", 6), ("up1000Fdx", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLinkState.setStatus('current')
if mibBuilder.loadTexts: portLinkState.setDescription('A value indicating the current link state.')
portErrorCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portErrorCounter.setStatus('current')
if mibBuilder.loadTexts: portErrorCounter.setDescription('Errors are usually caused by a FDX/HDX mismatch between the switch port and the connected port. If the switch detects a incrementation of this counter, he will send a portErrorCountFailure trap. The counted errors are depending on the switch type. For BM-A, BM+ and Access Switches: - Received packets with bad CRC, - Received packets with bad alignment, - Late collisions (only valid if Link State is 10HDX or 100HDX). For old BM Switches: - Received packets with bad CRC')
portRemoteFault = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("enable", 2), ("disable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portRemoteFault.setStatus('current')
if mibBuilder.loadTexts: portRemoteFault.setDescription('If portRemoteFault is enabled for this port, the port transmitter will be only enabled if the port receiver has a valid link (portLinkState must not be down).')
portDefaultVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDefaultVlanId.setStatus('current')
if mibBuilder.loadTexts: portDefaultVlanId.setDescription('The Default-VLAN-ID assigned to this port. This Default-VLAN-ID has differnt affects depending on received or transmited frames: a) All received frames, which have no VLAN-tag, will be assigned to the Default-VLAN-ID. b) All transmited frames, which belong to the Default-VLAN, are send without a VLAN-tag. If portTrunkingMode is set to dot1qTagging, all frames are transmited with a VLAN-tag, except frames which belong to the Default-VLAN-ID. Changes of this value will take affect after the next switch reboot or after setting adminReset to renewIpAndVlanParameter(5). Setting this value to 0 for a port with dot1qTagging will disable the Default-VLAN. This means, that all frames are send tagged.')
portTrunkingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dot1qTagging", 1), ("disable", 2), ("enableWithoutTagging", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portTrunkingMode.setStatus('current')
if mibBuilder.loadTexts: portTrunkingMode.setDescription('If portTrunkingMode is set to dot1qTagging, all frames are transmited with a VLAN-tag, except frames which belong to portNativeVlanId. If portTrunkingMode is set to enableWithoutTagging, all frames are transmited without a VLAN-tag. Changes of this value will take affect after the next switch reboot or after setting adminReset to renewIpAndVlanParameter(5).')
portDot1qDefaultPrioValue = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDot1qDefaultPrioValue.setStatus('current')
if mibBuilder.loadTexts: portDot1qDefaultPrioValue.setDescription('The default IEEE802.1Q priority and queue assigned all frames received on this port, for which no other priorisation applies (IEEE801.1q Tag or IPv4/IPv6). The definition between value, service class and queue are as follows: 0=Best Effort (queue=0), 1=Background (queue=0), 2=Reserved (queue=1), 3=Excellent Effort (queue=1), 4=Controlled Load (queue=2), 5=Video (queue=2), 6=Voice (queue=3), 7=Network Control (queue=3)')
portDefaultPrioQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDefaultPrioQueue.setStatus('current')
if mibBuilder.loadTexts: portDefaultPrioQueue.setDescription('The default priority queue assigned all frames received on this port, for which no other priorisation applies (IEEE801.1q Tag or IPv4/IPv6). A value of 0 means the lowest priority level. A value of 3 means the highest priority level. To change this default queue use object portDot1qDefaultPrioValue.')
portLEDGreen = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 1), ("showLinkState", 2), ("blink", 3), ("allwaysOff", 4), ("allwaysOn", 5), ("showLinkSpeedDuplex", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLEDGreen.setStatus('current')
if mibBuilder.loadTexts: portLEDGreen.setDescription('The function of the green port LED. Only supported for user ports')
portLEDYellow = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notSupported", 1), ("showDuplexState", 2), ("blink", 3), ("allwaysOff", 4), ("allwaysOn", 5), ("showPoeEnabled", 6), ("showSpeed", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLEDYellow.setStatus('current')
if mibBuilder.loadTexts: portLEDYellow.setDescription('The function of the yellow port LED. Only supported for user ports')
portBandwidthLimitRxd = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("notSupported", 1), ("disable", 2), ("limit128k", 3), ("limit256k", 4), ("limit512k", 5), ("limit1M", 6), ("limit2M", 7), ("limit4M", 8), ("limit8M", 9), ("limit16M", 10), ("limit32M", 11), ("limit64M", 12), ("limit128M", 13), ("limit256M", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBandwidthLimitRxd.setStatus('current')
if mibBuilder.loadTexts: portBandwidthLimitRxd.setDescription('The bandwidth limiter for received packets. If set to disable(2) the limiter will be disabled.')
portBandwidthLimitTxd = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("notSupported", 1), ("disable", 2), ("limit128k", 3), ("limit256k", 4), ("limit512k", 5), ("limit1M", 6), ("limit2M", 7), ("limit4M", 8), ("limit8M", 9), ("limit16M", 10), ("limit32M", 11), ("limit64M", 12), ("limit128M", 13), ("limit256M", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBandwidthLimitTxd.setStatus('current')
if mibBuilder.loadTexts: portBandwidthLimitTxd.setDescription('The bandwidth limiter for transmitted packets. If set to disable(2) the limiter will be disabled.')
portSecurityAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("notSupported", 1), ("disable", 2), ("manualSettingMacAddr", 3), ("autoAllowOneMacAddr", 4), ("autoAllowTwoMacAddr", 5), ("autoAllowThreeMacAddr", 6), ("radiusAllowOneMacAddr", 7), ("radiusAllowTwoMacAddr", 8), ("radiusAllowThreeMacAddr", 9), ("renew", 10), ("ieee802AllowOneMacAddr", 11), ("vendorSettingMacAddr", 12), ("ieee802AllowMultiMacAddr", 13), ("ieee802OrRadiusOneMac", 14), ("ieee802AndRadiusTwoMac", 15), ("learnOneMacAddr", 16), ("learnTwoMacAddr", 17)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityAdminState.setStatus('current')
if mibBuilder.loadTexts: portSecurityAdminState.setDescription('Enables the port security feature for that port. A value of notSupported(1) means, that port security ist not supported or disabled for that port (i.e. uplink port). The command renew(10) clears all learned MAC addresses and enables the port if it is disabled. See documentation for more details.')
portSecurityMacAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 18), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityMacAddr1.setStatus('current')
if mibBuilder.loadTexts: portSecurityMacAddr1.setDescription('The first MAC address used for port security. If portSecurityAdminState has the value disable(2), portSecurityManualSettingMacAddr(3) or vendorSettingMacAddr(12) then this object will be read-write. In any other mode this object will be read-only and shows the first automatically learned MAC addresses for that port.')
portSecurityMacAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 19), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityMacAddr2.setStatus('current')
if mibBuilder.loadTexts: portSecurityMacAddr2.setDescription('The second MAC address used for port security. If portSecurityAdminState has the value disable(2), portSecurityManualSettingMacAddr(3) or vendorSettingMacAddr(12) then this object will be read-write. In any other mode this object will be read-only and shows the second automatically learned MAC addresses for that port.')
portSecurityMacAddr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 20), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityMacAddr3.setStatus('current')
if mibBuilder.loadTexts: portSecurityMacAddr3.setDescription('The third MAC address used for port security. If portSecurityAdminState has the value disable(2), portSecurityManualSettingMacAddr(3) or vendorSettingMacAddr(12) then this object will be read-write. In any other mode this object will be read-only and shows the third automatically learned MAC addresses for that port.')
portPoeAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notSupported", 1), ("off", 2), ("forcedOn", 3), ("autoOn", 4), ("overloadFail", 5), ("reset", 6), ("afHighPower", 7), ("atHighPower", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPoeAdminState.setStatus('current')
if mibBuilder.loadTexts: portPoeAdminState.setDescription('If no POE adapter is installed this object is read-only and will always report notSupported(1). The possible values are: notSupported(1): No adapter installed or not supported for that port (i.e. uplink port). off(2): Adapter installed but inline power for that port is switched off. forcedOn(3): Adapter installed and inline power is asserted permanently. In the case of an IEEE802.3af adapter this setting will disable the IEEE802.3af automatic detection. autoOn(4): This setting is only supported if a IEEE802.3af adapter is installed. The adapter automatically detects if the connected device is IEEE802.3af compliant and will assert the power if possible. overloadFail(5): Adapter installed but inline power for that port is automatically switched off because of a overload condition at that port.')
portPoeVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPoeVoltage.setStatus('current')
if mibBuilder.loadTexts: portPoeVoltage.setDescription('The current PoE output voltage at this port in volts.')
portPoeCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPoeCurrent.setStatus('current')
if mibBuilder.loadTexts: portPoeCurrent.setDescription('The current PoE output current at this port in milliampere.')
portPoePower = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPoePower.setStatus('current')
if mibBuilder.loadTexts: portPoePower.setDescription('The current PoE output power at this port in milliwatt. The output power is the product of portPoeVoltage and portPoeCurrent.')
portSecurityForwardingState = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("notSupported", 1), ("portAdminDisabled", 2), ("waitingForLink", 3), ("unsecureVLAN", 4), ("portAuthenticated", 5), ("portSecurityDisabled", 6), ("portLoopDisabled", 7), ("authFailureVLAN", 8), ("securityWarning", 9), ("authenticatingClients", 10), ("waitingForMacAddress", 11), ("allRadiusServersDown", 12), ("portBpduDisabled", 13), ("portUdldDisabled", 14), ("portLinkFlapDisabled", 15), ("portErrorCountDisabled", 16), ("portSfpErrorDisabled", 17), ("portRedundanyLoopDisable", 18)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSecurityForwardingState.setStatus('current')
if mibBuilder.loadTexts: portSecurityForwardingState.setDescription('The port security forwarding state of that port. See documentation for details.')
portPoePowerLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPoePowerLimit.setStatus('current')
if mibBuilder.loadTexts: portPoePowerLimit.setDescription('The limit for the POE output power at this port in VA. If the current power exceeds this value a overload conditions occurs and the inline power for that port will be switched off.')
portLimiterPacketType = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("limitAllPackets", 2), ("limitLoopBcastPackets", 3), ("limitAllPacketsBurstsAllowed", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLimiterPacketType.setStatus('current')
if mibBuilder.loadTexts: portLimiterPacketType.setDescription('The packet type for bandwidth limiter. If set to limitAllPacktes(2) then all packets are limited. If set to limitLoppBcastPackets(3) only flooted loop- and broadcast-pakets are limited.')
portAcApSetup = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("allwaysEnable", 2), ("enable", 3), ("disable", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAcApSetup.setStatus('current')
if mibBuilder.loadTexts: portAcApSetup.setDescription('If portAcApSetup is enabled, the switch will perform Autocrossover and Autopolarity for this port. This function should only be enabled if portSpeedDuplexSetup ist set to autoneg.')
portLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("user", 1), ("userWithLoopProtection", 2), ("upDownlink", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLinkType.setStatus('current')
if mibBuilder.loadTexts: portLinkType.setDescription('The link type of that port. If set to upDownlink(3) the portAdminState will be forced to enable.')
portVoiceVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceVlanId.setStatus('current')
if mibBuilder.loadTexts: portVoiceVlanId.setDescription('The Voide-VLAN-ID assigned to this port. Packets of this Voice-VLAN are allway send with a VLAN-Tag, because IP-Phones normaly need a tagged VLAN. If portTrunkingMode is set to dot1qTagging, ALL frames are transmited with a VLAN-tag, except frames which belong to the Default-VLAN-ID. In this case the Voice-VLAN-ID has no effect. Changes of this value will take affect after the next switch reboot or after setting adminReset to renewIpAndVlanParameter(5). Setting this value to 0 will disable the Voice-VLAN.')
portPrioDot1p = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("prioDot1pDisabled", 1), ("prioDot1pEnabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPrioDot1p.setStatus('current')
if mibBuilder.loadTexts: portPrioDot1p.setDescription('Defines whether port prioritisation for IEEE802.1p packets is enabled.')
portPrioIp = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("prioIpDisabled", 1), ("prioIpEnabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPrioIp.setStatus('current')
if mibBuilder.loadTexts: portPrioIp.setDescription('Defines whether port prioritisation for IPv4/IPv6 packets is enabled.')
bmSwitchVlanTable = MibTable((1, 3, 6, 1, 4, 1, 266, 20, 4, 1), )
if mibBuilder.loadTexts: bmSwitchVlanTable.setStatus('current')
if mibBuilder.loadTexts: bmSwitchVlanTable.setDescription('A list of Virtual LAN instances.')
bmSwitchVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 266, 20, 4, 1, 1), ).setIndexNames((0, "NEXANS-BM-MIB", "vlanIndex"))
if mibBuilder.loadTexts: bmSwitchVlanEntry.setStatus('current')
if mibBuilder.loadTexts: bmSwitchVlanEntry.setDescription('VLAN entry.')
vlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanIndex.setStatus('current')
if mibBuilder.loadTexts: vlanIndex.setDescription('A unique value for each VLAN entry. Its value ranges between 1 and 16.')
vlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanId.setStatus('current')
if mibBuilder.loadTexts: vlanId.setDescription("The VLAN-ID assigned to this entry. Only entries with a VLAN-ID greater then 0 are valid entries. Setting a valid VLAN-ID to 0 will disable that entry and also delete the vlanDescr To add a new VLAN-ID first set an valid or non valid entry to the desired VLAN-ID. In a second step you may set the vlanDescr. Only VLAN-ID's listed in the vlanTable are forwarded by the switch.")
vlanDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 4, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanDescr.setStatus('current')
if mibBuilder.loadTexts: vlanDescr.setDescription('A textual string containing information about the VLAN.')
bmSwitchSfpTable = MibTable((1, 3, 6, 1, 4, 1, 266, 20, 5, 1), )
if mibBuilder.loadTexts: bmSwitchSfpTable.setStatus('current')
if mibBuilder.loadTexts: bmSwitchSfpTable.setDescription('A list of SFP entries for the switch. The number of entries is defined by ifNumber.')
bmSwitchSfpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1), ).setIndexNames((0, "NEXANS-BM-MIB", "sfpPortIndex"))
if mibBuilder.loadTexts: bmSwitchSfpEntry.setStatus('current')
if mibBuilder.loadTexts: bmSwitchSfpEntry.setDescription('A SFP entry in the table containing information about a SFP in the switch.')
sfpPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpPortIndex.setStatus('current')
if mibBuilder.loadTexts: sfpPortIndex.setDescription('A unique value for each port. Its value ranges between 1 and the value of ifNumber. The port identified by a particular value of this index is the same port as identified by the same value of ifIndex.')
sfpState = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("noSfpInserted", 2), ("validSfpNoDiagnostic", 3), ("validSfpWithDiagnostic", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpState.setStatus('current')
if mibBuilder.loadTexts: sfpState.setDescription("A value indicating the current state of the SFP module. The possible values returned are: notSupported(1) The port has no SFP slot. noSfpInserted(2) The port has a SFP slot but there is no valid SFP module inserted. validSfpNoDiagnostic(3) A valid SFP module is inserted but the module doesn't supports diagnostic values. validSfpWithDiagnostic(4) A valid SFP module which supports diagnostic is inserted.")
sfpInfoVendorName = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoVendorName.setStatus('current')
if mibBuilder.loadTexts: sfpInfoVendorName.setDescription('A textual string containing the vendor name of the SFP module.')
sfpInfoPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoPartNumber.setStatus('current')
if mibBuilder.loadTexts: sfpInfoPartNumber.setDescription('A textual string containing the part number of the SFP module.')
sfpInfoRevisionNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoRevisionNumber.setStatus('current')
if mibBuilder.loadTexts: sfpInfoRevisionNumber.setDescription('A textual string containing the revision number of the SFP module.')
sfpInfoSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoSerialNumber.setStatus('current')
if mibBuilder.loadTexts: sfpInfoSerialNumber.setDescription('A textual string containing the serial number of the SFP module.')
sfpInfoDateCode = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoDateCode.setStatus('current')
if mibBuilder.loadTexts: sfpInfoDateCode.setDescription('A textual string containing the date code of the SFP module.')
sfpInfoBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoBitRate.setStatus('current')
if mibBuilder.loadTexts: sfpInfoBitRate.setDescription('A textual string containing the bit rate of the SFP module. The unit is Mbit/s')
sfpInfoWavelength = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoWavelength.setStatus('current')
if mibBuilder.loadTexts: sfpInfoWavelength.setDescription('A textual string containing the wavelength of the SFP module. The unit is nm.')
sfpInfoLength9um = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoLength9um.setStatus('current')
if mibBuilder.loadTexts: sfpInfoLength9um.setDescription('A textual string containing the typically supported fiber length for 9um fiber cable. The unit is meters.')
sfpInfoLength50um = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoLength50um.setStatus('current')
if mibBuilder.loadTexts: sfpInfoLength50um.setDescription('A textual string containing the typically supported fiber length for 50um fiber cable. The unit is meters.')
sfpInfoLength62um = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoLength62um.setStatus('current')
if mibBuilder.loadTexts: sfpInfoLength62um.setDescription('A textual string containing the typically supported fiber length for 62.5um fiber cable. The unit is meters.')
sfpInfoConnectorDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoConnectorDescr.setStatus('current')
if mibBuilder.loadTexts: sfpInfoConnectorDescr.setDescription('A textual string containing the connector description of the SFP module.')
sfpDiagTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpDiagTemperature.setStatus('current')
if mibBuilder.loadTexts: sfpDiagTemperature.setDescription('The current temperature of the SFP module in degree celsius.')
sfpDiagSupplyVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpDiagSupplyVoltage.setStatus('current')
if mibBuilder.loadTexts: sfpDiagSupplyVoltage.setDescription('The current supply voltage of the SFP module in millivolt.')
sfpDiagTxBiasCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpDiagTxBiasCurrent.setStatus('current')
if mibBuilder.loadTexts: sfpDiagTxBiasCurrent.setDescription('The current transmitter bias current of the SFP module in milliampere.')
sfpDiagTxOutputPower = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpDiagTxOutputPower.setStatus('current')
if mibBuilder.loadTexts: sfpDiagTxOutputPower.setDescription('The current transmitter output power of the SFP module in microwatt.')
sfpDiagTxOutputPowerDbm = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpDiagTxOutputPowerDbm.setStatus('current')
if mibBuilder.loadTexts: sfpDiagTxOutputPowerDbm.setDescription('The current transmitter output power of the SFP module in dbm.')
sfpDiagRxIntputPower = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpDiagRxIntputPower.setStatus('current')
if mibBuilder.loadTexts: sfpDiagRxIntputPower.setDescription('The current receiver input power of the SFP module in microwatt.')
sfpDiagRxInputPowerDbm = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpDiagRxInputPowerDbm.setStatus('current')
if mibBuilder.loadTexts: sfpDiagRxInputPowerDbm.setDescription('The current receiver input power of the SFP module in dbm.')
sfpAlarmTxBiasCurrentUpperLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfpAlarmTxBiasCurrentUpperLimit.setStatus('current')
if mibBuilder.loadTexts: sfpAlarmTxBiasCurrentUpperLimit.setDescription('The maximum allowed transmitter bias current in milliampere. If the current value indicated by sfpDiagTxBiasCurrent exceeds sfpAlarmTxBiasCurrentUpperLimit, the switch sends an sfpEvent alarm trap. If the value of this limit is 0 no alarm will be send.')
sfpAlarmTxOutputPowerLowerLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfpAlarmTxOutputPowerLowerLimit.setStatus('current')
if mibBuilder.loadTexts: sfpAlarmTxOutputPowerLowerLimit.setDescription('The minimum required transmitter output power in microwatt. If the power value indicated by sfpDiagTxOutputPower falls below sfpAlarmTxOutputPowerLowerLimit, the switch sends an sfpEvent alarm trap. If the value of this limit is 0 no alarm will be send.')
sfpAlarmRxInputPowerLowerLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfpAlarmRxInputPowerLowerLimit.setStatus('current')
if mibBuilder.loadTexts: sfpAlarmRxInputPowerLowerLimit.setDescription('The minimum required received input power in microwatt. If the power value indicated by sfpDiagRxInputPower falls below sfpAlarmRxInputPowerLowerLimit, the switch sends an sfpEvent alarm trap. If the value of this limit is 0 no alarm will be send.')
switchTemperatureFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 1)).setObjects(("NEXANS-BM-MIB", "infoTemperature"))
if mibBuilder.loadTexts: switchTemperatureFailure.setStatus('current')
if mibBuilder.loadTexts: switchTemperatureFailure.setDescription('A TemperatureFailure signifies that the switch hardware has detected under- or overtemperature condition.')
portLinkChange = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 2)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "portLinkState"))
if mibBuilder.loadTexts: portLinkChange.setStatus('current')
if mibBuilder.loadTexts: portLinkChange.setDescription('The trap is sent whenever the link state of a port changes from link-up to link-down or from link-down to link-up')
portNewMacAddress = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 3)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "infoNewMacAddr"))
if mibBuilder.loadTexts: portNewMacAddress.setStatus('current')
if mibBuilder.loadTexts: portNewMacAddress.setDescription('A new source MAC address has been detected on a switch port. This trap is only send for ports which have port-security enabled with the setting autoAllowOneMacAddr, autoAllowTwoMacAddr or autoAllowThreeMacAddr.')
portSecurityFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 4)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "infoSecurityFailMacAddr"))
if mibBuilder.loadTexts: portSecurityFailure.setStatus('current')
if mibBuilder.loadTexts: portSecurityFailure.setDescription('An unauthorized source MAC address has accessed a port which has port-security enabled.')
portErrorCountFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 5)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "portErrorCounter"))
if mibBuilder.loadTexts: portErrorCountFailure.setStatus('current')
if mibBuilder.loadTexts: portErrorCountFailure.setDescription('The port error counter has incremented by 2 or more within a timewindow of two seconds. An counter increment by 1 ist not reported because single increments often may result because of link-changes.')
switchMgmtAuthFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 6)).setObjects(("NEXANS-BM-MIB", "infoUnauthIpAddr"))
if mibBuilder.loadTexts: switchMgmtAuthFailure.setStatus('current')
if mibBuilder.loadTexts: switchMgmtAuthFailure.setDescription('A station has tried to access the switch management with a wrong authentication. This includes wrong user/password for telnet, wrong community for SNMP read/write and wrong accessrights in the accesslist.')
radiusMgmtAuthReject = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 7)).setObjects(("NEXANS-BM-MIB", "infoUnauthIpAddr"))
if mibBuilder.loadTexts: radiusMgmtAuthReject.setStatus('current')
if mibBuilder.loadTexts: radiusMgmtAuthReject.setDescription('A station has tried to access the switch management with radius authentication enabled and the radius server has rejected the request.')
radiusPortSecurityReject = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 8)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "infoSecurityFailMacAddr"))
if mibBuilder.loadTexts: radiusPortSecurityReject.setStatus('current')
if mibBuilder.loadTexts: radiusPortSecurityReject.setDescription('A station has tried to access the switch with radius port security authentication enabled and the radius server has rejected the request.')
portLoopBcastFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 9)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"))
if mibBuilder.loadTexts: portLoopBcastFailure.setStatus('current')
if mibBuilder.loadTexts: portLoopBcastFailure.setDescription('The port broadcast/multicast counter has incremented by 25 packets/second for more then 10 successive seconds. Excessive multicast or broadcast packets may result in case of a loop between two port of the switch.')
switchPoeVoltageFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 10)).setObjects(("NEXANS-BM-MIB", "infoPoeInputVoltage"))
if mibBuilder.loadTexts: switchPoeVoltageFailure.setStatus('current')
if mibBuilder.loadTexts: switchPoeVoltageFailure.setDescription('The switch has detected a PoE over- or undervoltage conditions.')
switchPoeOverloadFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 11)).setObjects(("NEXANS-BM-MIB", "infoPoeInputPower"))
if mibBuilder.loadTexts: switchPoeOverloadFailure.setStatus('current')
if mibBuilder.loadTexts: switchPoeOverloadFailure.setDescription('The switch has detected a overload for the PoE power supply.')
portPoeOverloadFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 12)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "portPoePower"))
if mibBuilder.loadTexts: portPoeOverloadFailure.setStatus('current')
if mibBuilder.loadTexts: portPoeOverloadFailure.setDescription('The switch has detected a PoE overload condition at the port.')
portActiveLoopDetectionFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 13)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"))
if mibBuilder.loadTexts: portActiveLoopDetectionFailure.setStatus('current')
if mibBuilder.loadTexts: portActiveLoopDetectionFailure.setDescription('The active loop protection has disabled the port.')
switchIndustrialAlarmM1 = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 14)).setObjects(("NEXANS-BM-MIB", "infoAlarmStateM1"), ("NEXANS-BM-MIB", "adminAlarmNameM1"))
if mibBuilder.loadTexts: switchIndustrialAlarmM1.setStatus('current')
if mibBuilder.loadTexts: switchIndustrialAlarmM1.setDescription('The alarm state of the industrial alarm output M1 has changed.')
switchIndustrialAlarmM2 = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 15)).setObjects(("NEXANS-BM-MIB", "infoAlarmStateM2"), ("NEXANS-BM-MIB", "adminAlarmNameM2"))
if mibBuilder.loadTexts: switchIndustrialAlarmM2.setStatus('current')
if mibBuilder.loadTexts: switchIndustrialAlarmM2.setDescription('The alarm state of the industrial alarm output M2 has changed.')
switchInternalVoltageFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 16)).setObjects(("NEXANS-BM-MIB", "infoPowerVoltage2500"), ("NEXANS-BM-MIB", "infoPowerVoltage3300"))
if mibBuilder.loadTexts: switchInternalVoltageFailure.setStatus('current')
if mibBuilder.loadTexts: switchInternalVoltageFailure.setDescription('The switch has detected a internal over- or undervoltage conditions.')
tftpMessage = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 17)).setObjects(("NEXANS-BM-MIB", "infoLastTftpMessage"))
if mibBuilder.loadTexts: tftpMessage.setStatus('current')
if mibBuilder.loadTexts: tftpMessage.setDescription('An successful or failed TFTP transfer has been occured. This does not include TFTP transfers executed from Nexan Manager.')
sfpEvent = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 18)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "infoLastSfpEventMessage"))
if mibBuilder.loadTexts: sfpEvent.setStatus('current')
if mibBuilder.loadTexts: sfpEvent.setDescription('The switch has detected one of the following SFP events: - a SFP module has been inserted - a SFP module has been removed - the optical receive power has fallen below the configured threshold - the optical transmit power has fallen below the configured threshold - the laser bias current has exceeded the configured threshold In the case of a threshold event, the trap will only send out every five minutes.')
clientRemoved = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 19)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"))
if mibBuilder.loadTexts: clientRemoved.setStatus('current')
if mibBuilder.loadTexts: clientRemoved.setDescription("The client on this port has been removed because the link down time has exceeded the configured 'Link Down Timeout'.")
internalMgmtWarning = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 20)).setObjects(("NEXANS-BM-MIB", "infoLastInternalMgmtWarning"))
if mibBuilder.loadTexts: internalMgmtWarning.setStatus('current')
if mibBuilder.loadTexts: internalMgmtWarning.setDescription('An internal management warning has been detected. Please consult Nexans for further informations regarding the reported warning code.')
switchFunctionInputAlarm = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 21)).setObjects(("NEXANS-BM-MIB", "infoFunctionInputStateF1"), ("NEXANS-BM-MIB", "adminFunctionInputNameF1"))
if mibBuilder.loadTexts: switchFunctionInputAlarm.setStatus('current')
if mibBuilder.loadTexts: switchFunctionInputAlarm.setDescription('The state of the function input has changed.')
switchConfigurationChanged = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 22)).setObjects(("NEXANS-BM-MIB", "infoTotalConfigChanges"))
if mibBuilder.loadTexts: switchConfigurationChanged.setStatus('current')
if mibBuilder.loadTexts: switchConfigurationChanged.setDescription('The configuration of the switch has been changed.')
portErrorDisabled = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 23)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "portAdminState"))
if mibBuilder.loadTexts: portErrorDisabled.setStatus('current')
if mibBuilder.loadTexts: portErrorDisabled.setDescription('The port has been error disabled.')
mibBuilder.exportSymbols("NEXANS-BM-MIB", adminAgentIpAddress=adminAgentIpAddress, portDescr=portDescr, sfpDiagTxBiasCurrent=sfpDiagTxBiasCurrent, portPoePowerLimit=portPoePowerLimit, infoManufactureDate=infoManufactureDate, infoDescr=infoDescr, adminLedGlobalMode=adminLedGlobalMode, sfpAlarmTxBiasCurrentUpperLimit=sfpAlarmTxBiasCurrentUpperLimit, portSecurityFailure=portSecurityFailure, radiusPortSecurityReject=radiusPortSecurityReject, adminFunctionInputNameF1=adminFunctionInputNameF1, infoNewMacAddr=infoNewMacAddr, internalMgmtWarning=internalMgmtWarning, adminAlarmNameM1=adminAlarmNameM1, portActiveLoopDetectionFailure=portActiveLoopDetectionFailure, switchConfigurationChanged=switchConfigurationChanged, adminAlarmM1=adminAlarmM1, sfpDiagRxIntputPower=sfpDiagRxIntputPower, portPrioDot1p=portPrioDot1p, infoFunctionInputStateF1=infoFunctionInputStateF1, sfpInfoVendorName=sfpInfoVendorName, infoTemperature=infoTemperature, portSecurityAdminState=portSecurityAdminState, portAdminState=portAdminState, infoLastInternalMgmtWarning=infoLastInternalMgmtWarning, adminSwitchVlanTableMode=adminSwitchVlanTableMode, infoMgmtFirmwareVersion=infoMgmtFirmwareVersion, sfpEvent=sfpEvent, sfpInfoSerialNumber=sfpInfoSerialNumber, infoTemperatureMaxAllowed=infoTemperatureMaxAllowed, portLEDGreen=portLEDGreen, portErrorCounter=portErrorCounter, sfpInfoBitRate=sfpInfoBitRate, bmSwitchSfpEntry=bmSwitchSfpEntry, portBandwidthLimitRxd=portBandwidthLimitRxd, sfpAlarmRxInputPowerLowerLimit=sfpAlarmRxInputPowerLowerLimit, portBandwidthLimitTxd=portBandwidthLimitTxd, portSecurityMacAddr3=portSecurityMacAddr3, portSecurityForwardingState=portSecurityForwardingState, portSpeedDuplexSetup=portSpeedDuplexSetup, switchIndustrialAlarmM1=switchIndustrialAlarmM1, infoProductNo=infoProductNo, bmSwitchPortEntry=bmSwitchPortEntry, portDefaultVlanId=portDefaultVlanId, sfpInfoLength50um=sfpInfoLength50um, adminAgentPhysAddress=adminAgentPhysAddress, portLoopBcastFailure=portLoopBcastFailure, adminSwitchPoEPowerLimit=adminSwitchPoEPowerLimit, portSecurityMacAddr1=portSecurityMacAddr1, adminAgentDhcpServerIpAddress=adminAgentDhcpServerIpAddress, portName=portName, portPoeVoltage=portPoeVoltage, portLinkType=portLinkType, vlanIndex=vlanIndex, infoPoeInputPower=infoPoeInputPower, portSecurityMacAddr2=portSecurityMacAddr2, bmTraps=bmTraps, infoNoOfPorts=infoNoOfPorts, clientRemoved=clientRemoved, infoMgmtHardwareVersion=infoMgmtHardwareVersion, sfpInfoDateCode=sfpInfoDateCode, infoPowerVoltage2500=infoPowerVoltage2500, bmSwitchSfpTable=bmSwitchSfpTable, adminAlarmNameM2=adminAlarmNameM2, portTrunkingMode=portTrunkingMode, infoUnauthIpAddr=infoUnauthIpAddr, switchFunctionInputAlarm=switchFunctionInputAlarm, bmSwitchPortTable=bmSwitchPortTable, sfpDiagTxOutputPower=sfpDiagTxOutputPower, infoSerie=infoSerie, PYSNMP_MODULE_ID=bmSwitchMIB, portDot1qDefaultPrioValue=portDot1qDefaultPrioValue, sfpInfoPartNumber=sfpInfoPartNumber, bmSwitchInfo=bmSwitchInfo, infoLastTftpMessage=infoLastTftpMessage, infoSwitchHardwareVersion=infoSwitchHardwareVersion, adminUnsecureVlanId=adminUnsecureVlanId, vlanDescr=vlanDescr, bmSwitchSfp=bmSwitchSfp, infoType=infoType, adminAgentDefRouterIpAddress=adminAgentDefRouterIpAddress, adminSnmpMacTableMode=adminSnmpMacTableMode, portPoeOverloadFailure=portPoeOverloadFailure, vlanId=vlanId, adminAgentVlanId=adminAgentVlanId, infoAlarmStateM2=infoAlarmStateM2, switchInternalVoltageFailure=switchInternalVoltageFailure, adminReset=adminReset, sfpInfoRevisionNumber=sfpInfoRevisionNumber, portAcApSetup=portAcApSetup, sfpDiagSupplyVoltage=sfpDiagSupplyVoltage, adminAlarmM2=adminAlarmM2, infoAlarmStateM1=infoAlarmStateM1, infoPoeInputVoltage=infoPoeInputVoltage, bmSwitchVlanEntry=bmSwitchVlanEntry, portDefaultPrioQueue=portDefaultPrioQueue, bmSwitchPort=bmSwitchPort, switchIndustrialAlarmM2=switchIndustrialAlarmM2, infoTotalConfigChanges=infoTotalConfigChanges, infoLastSfpEventMessage=infoLastSfpEventMessage, portPoeAdminState=portPoeAdminState, adminAgentDhcp=adminAgentDhcp, portLEDYellow=portLEDYellow, sfpInfoConnectorDescr=sfpInfoConnectorDescr, adminSwitchPortMirror=adminSwitchPortMirror, bmSwitchVlanTable=bmSwitchVlanTable, adminAgentNetmask=adminAgentNetmask, portLimiterPacketType=portLimiterPacketType, portErrorDisabled=portErrorDisabled, infoPowerVoltage3300=infoPowerVoltage3300, adminAgentPrioValue=adminAgentPrioValue, adminMgmtAccessList=adminMgmtAccessList, infoSeriesNo=infoSeriesNo, portRemoteFault=portRemoteFault, portPoeCurrent=portPoeCurrent, adminAddrAgingTimeMinutes=adminAddrAgingTimeMinutes, portErrorCountFailure=portErrorCountFailure, tftpMessage=tftpMessage, portLinkChange=portLinkChange, sfpInfoWavelength=sfpInfoWavelength, bmSwitchVlan=bmSwitchVlan, portPoePower=portPoePower, sfpInfoLength9um=sfpInfoLength9um, bmSwitchAdmin=bmSwitchAdmin, sfpPortIndex=sfpPortIndex, portNewMacAddress=portNewMacAddress, portLinkState=portLinkState, switchTemperatureFailure=switchTemperatureFailure, sfpInfoLength62um=sfpInfoLength62um, adminDot1xAuthFailureVlanId=adminDot1xAuthFailureVlanId, adminTftpAccess=adminTftpAccess, portPrioIp=portPrioIp, infoNoOfReboots=infoNoOfReboots, switchPoeOverloadFailure=switchPoeOverloadFailure, switchMgmtAuthFailure=switchMgmtAuthFailure, radiusMgmtAuthReject=radiusMgmtAuthReject, bmSwitchMIB=bmSwitchMIB, portVoiceVlanId=portVoiceVlanId, sfpAlarmTxOutputPowerLowerLimit=sfpAlarmTxOutputPowerLowerLimit, portIndex=portIndex, infoSecurityFailMacAddr=infoSecurityFailMacAddr, sfpState=sfpState, sfpDiagTemperature=sfpDiagTemperature, switchPoeVoltageFailure=switchPoeVoltageFailure, sfpDiagTxOutputPowerDbm=sfpDiagTxOutputPowerDbm, sfpDiagRxInputPowerDbm=sfpDiagRxInputPowerDbm, adminMemoryCardMode=adminMemoryCardMode)

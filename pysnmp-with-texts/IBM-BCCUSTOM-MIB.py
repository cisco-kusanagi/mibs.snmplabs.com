#
# PySNMP MIB module IBM-BCCUSTOM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IBM-BCCUSTOM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:50:46 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
InetAddress, = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Counter64, Gauge32, Unsigned32, enterprises, ObjectIdentity, IpAddress, iso, NotificationType, MibIdentifier, ModuleIdentity, Counter32, TimeTicks, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Counter64", "Gauge32", "Unsigned32", "enterprises", "ObjectIdentity", "IpAddress", "iso", "NotificationType", "MibIdentifier", "ModuleIdentity", "Counter32", "TimeTicks", "Bits")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ibm = MibIdentifier((1, 3, 6, 1, 4, 1, 2))
ibmProd = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6))
bcCustom = ModuleIdentity((1, 3, 6, 1, 4, 1, 2, 6, 215))
bcCustom.setRevisions(('2013-10-15 17:30',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: bcCustom.setRevisionsDescriptions(('Initial version of this module.',))
if mibBuilder.loadTexts: bcCustom.setLastUpdated('201310151730Z')
if mibBuilder.loadTexts: bcCustom.setOrganization('Brocade Communications Systems, Inc.,')
if mibBuilder.loadTexts: bcCustom.setContactInfo('Customer Support Group Brocade Communications Systems, 1745 Technology Drive, San Jose, CA 95110 U.S.A Tel: +1-408-392-6061 Fax: +1-408-392-6656 Email: support@Brocade.COM WEB: www.brocade.com')
if mibBuilder.loadTexts: bcCustom.setDescription('The MIB module is to get the details of Pharos Embedded switch. copyright (c) 1996-2003 Brocade Communications Systems, Inc. All rights reserved.')
bcCustomMibVersion = ObjectIdentity((1, 3, 6, 1, 4, 1, 2, 6, 215, 1))
if mibBuilder.loadTexts: bcCustomMibVersion.setStatus('current')
if mibBuilder.loadTexts: bcCustomMibVersion.setDescription('The OID subtree for version information')
ports = ObjectIdentity((1, 3, 6, 1, 4, 1, 2, 6, 215, 2))
if mibBuilder.loadTexts: ports.setStatus('current')
if mibBuilder.loadTexts: ports.setDescription('The OID subtree for Portmodule details')
firmware = ObjectIdentity((1, 3, 6, 1, 4, 1, 2, 6, 215, 3))
if mibBuilder.loadTexts: firmware.setStatus('current')
if mibBuilder.loadTexts: firmware.setDescription('The OID subtree for Firmware operations')
files = ObjectIdentity((1, 3, 6, 1, 4, 1, 2, 6, 215, 4))
if mibBuilder.loadTexts: files.setStatus('current')
if mibBuilder.loadTexts: files.setDescription('The OID subtree for various file operations')
protocols = ObjectIdentity((1, 3, 6, 1, 4, 1, 2, 6, 215, 5))
if mibBuilder.loadTexts: protocols.setStatus('current')
if mibBuilder.loadTexts: protocols.setDescription('The OID subtree for various protocol configuration operations')
snmpuser = ObjectIdentity((1, 3, 6, 1, 4, 1, 2, 6, 215, 6))
if mibBuilder.loadTexts: snmpuser.setStatus('current')
if mibBuilder.loadTexts: snmpuser.setDescription('The OID subtree for SNMPV3 user configuration operations')
license = ObjectIdentity((1, 3, 6, 1, 4, 1, 2, 6, 215, 7))
if mibBuilder.loadTexts: license.setStatus('current')
if mibBuilder.loadTexts: license.setDescription('The OID subtree for feature license key configuration operations')
mibCustomVersion = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 215, 1, 1))
mibMajorMinor = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mibMajorMinor.setStatus('current')
if mibBuilder.loadTexts: mibMajorMinor.setDescription('The MIB major and minor version number is a 4 byte value of the form xx:xx:yy:yy. The higher 2 byte (xx:xx) is for the major version number. The lower 2 byte (yy:yy) is for the minor version number. Rule of MIB Version: Major: Incremented by one every time a new object is added. When the Major number is incremented the Minor number should be reset and start at the value 1. Minor: Increment by one only when an object is modified and no new object(s) are added.')
iomGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 215, 1, 2))
iomCapability = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iomCapability.setStatus('current')
if mibBuilder.loadTexts: iomCapability.setDescription('The AMM will use this object read the IOM capabilities. The IOM must set its capabilities prior to its POST transition. The unsigned INTEGER value will be treated as the 32 bits in network byte order. That is the bit 0 will be the left most bit and bit 31 will be the right most bit. The bit pattern definition is defined as below. Bit(31): IOM Mode Changeable: Set to 1, IOM supports to change its operation mode. Bit(30): Reserved for Port Based VLAN: Set to 1, IOM supports port based VLAN. Bit(29): Reserved for Port Statistics: Set to 1, IOM supports port statistics. Bit(28): Firmware group: Set to 1, IOM supports firmware group MIB objects. Bit(27): Files group: : Set to 1, IOM supports files group MIB objects. Bit(26): Reserved for VLAN group: Set to 1, IOM supports system vlan group MIB objects. Bit(25): Protocols: Set to 1, IOM supports protocols group MIB objects. Bit(24): Port Information: Set to 1, IOM supports port information group MIB objects. Bit(23): Feature License Information:Set to 1, IOM supports license key status reporting group MIB objects. Bit(22): PCI Adapter Inventory Information: Set 626 to 1, IOM supports reporting of PCI Adapter Inventory group MIB objects. Note: applicable for a PCIe IOM only. Bit(0-21): Reserved: must be set to zeroes.')
iomMode = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("managedSwitchMode", 1), ("passthruNativeMode", 2), ("passthruEnhanceMode", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iomMode.setStatus('current')
if mibBuilder.loadTexts: iomMode.setDescription('This MIB object provides the ability to read and write the current operation mode of operation of the IOM')
portInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1))
portInformationTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1), )
if mibBuilder.loadTexts: portInformationTable.setStatus('current')
if mibBuilder.loadTexts: portInformationTable.setDescription('Table that contains port information for the I/O Module.')
portInformationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1), ).setIndexNames((0, "IBM-BCCUSTOM-MIB", "portModuleIndex"), (0, "IBM-BCCUSTOM-MIB", "portModuleType"))
if mibBuilder.loadTexts: portInformationEntry.setStatus('current')
if mibBuilder.loadTexts: portInformationEntry.setDescription('I/O Module port entry')
portModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleIndex.setStatus('current')
if mibBuilder.loadTexts: portModuleIndex.setDescription('I/O Module port sequence index.')
portModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("unUsed", 0), ("externalPort", 1), ("externalManagementPort", 2), ("externalDualPort", 3), ("bladePort", 4), ("mmManagementPort", 5), ("uplinkPort", 6), ("interModulePort", 7), ("interModuleManagementPort", 8), ("interModuleDualPort", 9), ("interModuleExternalBridgePort", 10), ("interModuleInternalBridgePort", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleType.setStatus('current')
if mibBuilder.loadTexts: portModuleType.setDescription('Indicates the given port type of the I/O Module. The definitions of port types are: unUsed: the value of zero indicates the request is for a real port index of the IOM in the OID. In the port type GET operation, the return value of zero means the port is not used for anything. externalPort: This port is connected to an external device and is for data traffic. externalManagementPort: This port is solely for an external management connection. This port is not used for data traffic from an external device externalDualPort: This port is used for both data traffic as well as for management traffic. bladePort : This port is connected to a blade. mmManagementPort: This port is connected to the Management Module. uplinkPort: This port is configured for up link functionality. interModulePort(: This port is connected to another I/O Module for data. interModuleManagementPort: This port is connected to another I/O Module for management purpose. interModuleDualPort: The port is connected to another I/O Module and can be used for both data and management purpose. interModuleExternalBridgePort: This port is an external bridge port that connects to another bridge. interModuleInternalBridgePort: This port is an internal bridge port that connects to chassis bridge module. To get the port type of a given port, the port type in OID must be zero and the port command in the OID is 2. For an example: To get a port type of the real port index 7, the OID would be: 1.3.6.1.4.1.2.6.215.2.1.1.1.2.7.0 and the result should be 4 (bladePort).')
portModuleLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("down", 0), ("up", 1), ("initialized", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portModuleLinkState.setStatus('current')
if mibBuilder.loadTexts: portModuleLinkState.setDescription('The current port link state of the I/O Module. down: the physical port is down or off. up: the physical port 817 is up and active initialized: the physical port has completed initializion but is not active yet.')
portModuleLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portModuleLabel.setStatus('current')
if mibBuilder.loadTexts: portModuleLabel.setDescription('The port string label of the I/O module. The IOM may allow for the port label to be configured from the I/O Modules user interface but the default port label must reflect.port type description as defined below: Unused port External port External Management port External Dual port Blade port MM Management port Up-Link port Interconnect Modular port Interconnect Modular Management port Interconnect Modular Dual port The write ACCESS will allow AMM to change the port label as needed.')
portModuleSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 10, 20, 40, 60, 80, 100, 140, 160, 200, 400, 560, 600, 800, 1000, 1120, 1680))).clone(namedValues=NamedValues(("autoduplex", 0), ("hundred-Mbpsfullduplex", 1), ("one-Gbpsfullduplex", 10), ("two-Gbpsfullduplex", 20), ("four-Gbpsfullduplex", 40), ("six-Gbpsfullduplex", 60), ("eight-Gbpsfullduplex", 80), ("ten-Gbpsfullduplex", 100), ("fourteen-Gbpsfullduplex", 140), ("sixteen-Gbpsfullduplex", 160), ("twenty-Gbpsfullduplex", 200), ("fourty-Gbpsfullduplex", 400), ("fivtysix-Gbpsfullduplex", 560), ("sixty-Gbpsfullduplex", 600), ("eighty-Gbpsfullduplex", 800), ("hundred-Gbpsfullduplex", 1000), ("hundredandtwelve-Gbpsfullduplex", 1120), ("hundredandsixtyeight-Gbpsfullduplex", 1680)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portModuleSpeed.setStatus('current')
if mibBuilder.loadTexts: portModuleSpeed.setDescription('The INTEGER value will indicate the current speed of the port. The INTEGER values are defined as follows: A signed value is Half duplex, A unsigned value is FULL Duplex. The value is the speed in multiple of 100 Mbps. The value of 0 is special for AUTO Speed, Auto Duplex. For example: 0: (SET) Auto Speed, Auto Duplex, GET (Not available due to link down) -1: 100 Mbps Half Duplex 1: 100 Mbps FULL Duplex 10: 1 Gbps FULL Duplex 20: 2 Gbps FULL Duplex 40: 4 Gbps FULL Duplex. 60: 6 Gbps FULL Duplex. 80: 8 Gbps FULL Duplex 100: 10 Gbps FULL Duplex 140: 14 Gbps FULL Duplex 160: 16 Gbps FULL Duplex 200: 20 Gbps FULL Duplex 400: 40 Gbps FULL Duplex 560: 56 Gbps FULL Duplex 600: 60 Gbps FULL Duplex 800: 80 Gbps FULL Duplex 1000: 100 Gbps FULL Duplex 1120: 112 Gbps FULL Duplex 1680: 168 Gbps FULL Duplex The value of zero is invalid in the get operation but it is valid in the set operation (Zero is the value used for a set operation for Auto Speed, Auto Duplex ).')
portModuleMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 32, 40, 48, 255))).clone(namedValues=NamedValues(("copper", 0), ("serdes", 1), ("opticalShortHaul", 32), ("opticalInterHaul", 40), ("opticalLongHaul", 48), ("other", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleMedia.setStatus('current')
if mibBuilder.loadTexts: portModuleMedia.setDescription('The port media type of the I/O Module.')
portModuleProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16, 32, 48, 64, 80, 112, 120))).clone(namedValues=NamedValues(("ethernet", 16), ("fibreChannel", 32), ("scalability", 48), ("infiniband", 64), ("pciExpress", 80), ("myrinet", 112), ("serial", 120)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleProtocol.setStatus('current')
if mibBuilder.loadTexts: portModuleProtocol.setDescription('The port protocol of the I/O Module.')
portModuleTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleTotal.setStatus('current')
if mibBuilder.loadTexts: portModuleTotal.setDescription("This value must return the the total number of ports supported on the IOM. This value must be customized Note: When an IOM supports the ability to activate additional ports supported by the IOM hardware by installing a license key then this OID can be set in two different ways, such that the CMM firmware will handle displaying the port information correctly. (1) The IOM firmware will account for both activated and un-activated ports due to the current installed license key and set the 'Total port available' equal to the activated ports only. (2) The IOM firmware does not differentiate and account for both activated and un-activated ports due to the current installed license key and set the 'Total port available' equal to the maximum supported ports by the IOM hardware. In addition the OID 'portModuleLabel' for a non-activated port must be set to 'Unused' and the 'portModuleLicensedState' must be set to 'notLicensed'. Although the CMM will handle either (1) or (2) above the IOM should implement (1) to assist the CMM user interface response time when displaying port information for the IOM. When an IOM implements (2) this will increase the CMM response time since this will require the CMM to issue more SNMP get operations for the various port information OID's and then discard the information for the user interface.")
portModuleSpeedList = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleSpeedList.setStatus('current')
if mibBuilder.loadTexts: portModuleSpeedList.setDescription('The string contains all the available speed settings that is applicable to the port. It is a special format so the application can parse the string to obtain all the possible speed settings. The speeds supported are define by 927 a token inside the pair of <> brackets. Inside the bracket there are two parts: the speed number which is the multiple of 100 Mbps and a word either HALF or FULL. For examples: <1 HALF> indicates 100 Mbps Half Duplex. <1 FULL> is 100 Mbps Full Duplex. <10 FULL> is 1 Gbps FULL Duplex. <20 FULL> is 2 Gbps FULL Duplex. <40 FULL> is 4 Gbps FULL Duplex <60 FULL> is 6 Gbps FULL Duplex <80 FULL> is 8 Gbps FULL Duplex <100 FULL> is 10 Gbps FULL Duplex. <140 FULL> is 14 Gbps FULL Duplex. <160 FULL> is 16 Gbps FULL Duplex. <200 FULL> is 20 Gbps FULL Duplex <400 FULL> is 40 Gbps FULL Duplex <560 FULL> is 56 Gbps FULL Duplex <600 FULL> is 60 Gbps FULL Duplex. <800 FULL> is 80 Gbps FULL Duplex. <1000 FULL> is 100 Gbps FULL Duplex. <1120 FULL> is 112 Gbps FULL Duplex. <1680 FULL> is 168 Gbps FULL Duplex. <AUTO> is a special token to indicate Auto Speed, Auto Duplex. <END> is a special token to mark the end of the list. The format of the string is <token><token><token> <END> The first token is always the current setting of the port. examples: <AUTO><1 HALF><1 FULL><10 FULL><40 FULL><100 FULL><END> The example shows the port is currently set as AUTO. The port can be set to any value of Auto, 100 Mbps Half Duplex, 100 Mbps Full Duplex, 1 Gbps Full Duplex, 4 Gbps Full Duplex, and 10 Gbps Full Duplex.')
portModuleReal = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleReal.setStatus('current')
if mibBuilder.loadTexts: portModuleReal.setDescription('To map from relative port index based on port type to the real port index of the server.')
portModuleRelative = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleRelative.setStatus('current')
if mibBuilder.loadTexts: portModuleRelative.setDescription('To map from real port index to the relative port index of the server.')
portModuleLaneCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 12, 16))).clone(namedValues=NamedValues(("onex", 1), ("twox", 2), ("fourx", 4), ("eightx", 8), ("twelvex", 12), ("sixteenx", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleLaneCount.setStatus('current')
if mibBuilder.loadTexts: portModuleLaneCount.setDescription('The value represents the number of lanes supported by the port.')
portModuleCableLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleCableLength.setStatus('current')
if mibBuilder.loadTexts: portModuleCableLength.setDescription('The length (in meters) of the cable supported by this port.')
portModuleCableManufacturer = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleCableManufacturer.setStatus('current')
if mibBuilder.loadTexts: portModuleCableManufacturer.setDescription('A string that contains the cable manufacturer. The name cannot exceed 64 1028 octets.')
portModuleCableCompatiblity = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("incompatible", 0), ("compatible", 1), ("compatibleButNotRecommnded", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleCableCompatiblity.setStatus('current')
if mibBuilder.loadTexts: portModuleCableCompatiblity.setDescription('Indicates the compatibility of the external cable which is currently plugged into this port.')
portModuleCableType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleCableType.setStatus('current')
if mibBuilder.loadTexts: portModuleCableType.setDescription('A string that designates the external cable type for this port. The name cannot exceed 64 octets. For example, Active Copper, Passive Copper, Active Fibre, Passive Fibre.')
portModuleDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("sdr", 0), ("ddr", 1), ("qdr", 2), ("edr", 3), ("fdr", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleDataRate.setStatus('current')
if mibBuilder.loadTexts: portModuleDataRate.setDescription('The value represents the data rate supported for this port. SDR (single data rate), DDR (double data rate), QDR (quad data rate), EDR (enhanced data rate), FDR (fourteen data rate).')
portModuleLicensedState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 2, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("notLicensed", 1), ("licensed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portModuleLicensedState.setStatus('current')
if mibBuilder.loadTexts: portModuleLicensedState.setDescription('The value represents the port license state. If this port is a base port that does not require a license key then the state will always indicate notApplicable. If the port needs to be enabled by a license key then the state may be licensed or not licensed depending on if the license key is installed.')
firmwareOps = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1))
fwInformationTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 1), )
if mibBuilder.loadTexts: fwInformationTable.setStatus('current')
if mibBuilder.loadTexts: fwInformationTable.setDescription('Table of Firmware Image information.')
fwInformationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 1, 1), ).setIndexNames((0, "IBM-BCCUSTOM-MIB", "fwImageIndex"))
if mibBuilder.loadTexts: fwInformationEntry.setStatus('current')
if mibBuilder.loadTexts: fwInformationEntry.setDescription('I/O Module Firmware Image entry')
fwImageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fwImageIndex.setStatus('current')
if mibBuilder.loadTexts: fwImageIndex.setDescription('Firmware Image index.')
fwImageInformation = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fwImageInformation.setStatus('current')
if mibBuilder.loadTexts: fwImageInformation.setDescription('Information about the image - This string must follow the format below: Version: %s\\n, Rel-Date: %s\\n, Status: %s\\n, Type: %s\\n, Size: %s\\n, Other-Info: %s\\n\\ Version: The version of the image and should match firmware VPD information. Rel-Date: The release date of the image which should match firmware VPD information of form MM/DD/YYYY. Status: To show if the image is currently Active or Not-Active (backup image ) or Reboot-Active (requires reboot to become active image) and should match firmware VPD information. Type: Boot Rom, Application, Bundled, Diagnostic, Generic Firmware which should match firmware VPD information. A Boot Rom or Application or Diagnostic or Generic image should be used to designate that the image is a single file when updates are performed for the targeted type of firmware. A Bundled image type would be used to designate that the file contains multiple firmware update packages. This should be used if all images in the bundled image have the same version, Release date, . If a bundled image then the image types included in the bundle must be listed in the Other Info. Size: Size of image in KB (Kilobyte) rounded to next 1KB increment. (Note: the MM will read the size of the current image in the IOM and if the size exceeds the allowable space on the MMs internal file system then the MM will not allow the file to be uploaded. In addition if the current image file size is within the limits of the MMs file system but the MM determines the new update image on an external server would exceed the MMs internal file systems allocation then the MM will fail the update. In this case the user on the MM will have to directly transfer the image to the IOM and not use the MMs file system as a source for the update. Other-Info: Any additional information that the IOM wishes to provide. String example 1: (Bundled image that is expanded on IOM) Version: 20.2.2.9, Rel Date: 09/26/2011, Type: Bundled, Status: Active, Size:27500KB, Other Info: Contains Boot ROM and Application images. String example 2: (Application image that is the backup image) Version: 20.1.0.20, Rel Date: 02/27/2012, Type: Application, Status: Not- Active, Size:1200KB, Other Info: None String example 3: (Application image that will become the active image on next reboot) Version: 20.1.0.25, Rel Date: 05/20/2012, Type: Application, Status: Reboot- Active, Size:1200KB, Other Info: None The format of the Firmware Image Information is very important and must be strictly followed. It is intended for other applications to parse and make use of the information. The string is made up of many parts of text information. Each part has the format of the form Token: information_string\\n,. Each part consists of a token followed by token information. The end of each part is marked by a new line character, and a comma or a null character. The total length of the string cannot exceed 256 octets.')
fwImageFileLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("mmServer", 0), ("externalServerRequired", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fwImageFileLocation.setStatus('current')
if mibBuilder.loadTexts: fwImageFileLocation.setDescription('This object indicates whether the IOM implementation of firmware updates has requirements on the server that would prevent the MM acting as the server for the image file(s). If there are no unique requirements then mmIsServer will not be set and one of the other enumerations will need to be set. - If the IOM firmware update requires the update file to be un-compressed on the server before transfer to the IOM then externalServerRequired must be set by IOM. - If the IOM firmware update is larger than 100MB the externalServerRequired must be set by IOM. Additional reasons for restrictions may be added 1198 in the future.')
fwImageProtocols = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fwImageProtocols.setStatus('current')
if mibBuilder.loadTexts: fwImageProtocols.setDescription('The CMM will use this command to read the current supported and enabled IOM file transfer protocols. The bit mask is treated as 32 bits in network byte order. 1310 That is the bit 0 will be the left most bit and bit 31 will be the right most bit. The bit pattern definition is defined as below. Supported Bit Mask (Bits 31:16): Bit(31): This bit is set to 1 if TFTP is supported. Bit(30): This bit is set to 1 if FTP is supported Bit(29): This bit is set to 1 if SFTP (via SSH) is supported Bit(28): This bit is set to 1 if HTTP is supported. Bit(27): This bit is set to 1 if HTTPs is supported Bit(26:16): Reserved: must be set to zeroes. Enabled Bit Mask (Bits 15:0): Bit(15): This bit is set to 1 if TFTP is enabled. Bit(14): This bit is set to 1 if FTP is enabled Bit(13): This bit is set to 1 if SFTP (via SSH) is enabled. Bit(12): This bit is set to 1 if HTTP is enabled. Bit(11): This bit is set to 1 if HTTPs is enabled Bit(10:0): Reserved: must be set to zeroes. .')
fwImageIsUpdateable = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("updateable", 0), ("notupdateable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fwImageIsUpdateable.setStatus('current')
if mibBuilder.loadTexts: fwImageIsUpdateable.setDescription("This object indicates whether the firmware image index can be updated separately using one of the indicated file transfer mechanisms from 'fwImageProtocol'. If this specific image cannot be updated then IOM must return 'notupdateable' otherwise IOM must return updateable'.")
firmwareCmd = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 2))
firmwareImageCnt = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: firmwareImageCnt.setStatus('current')
if mibBuilder.loadTexts: firmwareImageCnt.setDescription('The I/O Module must indicate the number of firmware images that can be updated. For example a value of 0 should be used if no images can be updated, a value of 1 should be used if 1 firmware image can be updated.')
firmwareImageNum = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: firmwareImageNum.setStatus('current')
if mibBuilder.loadTexts: firmwareImageNum.setDescription('This value indicates the image number that will be updated. For example, if the value is 2, that means firmware image 2 must be updated on the I/O Module. This value is write only by MM to the I/O Module.')
firmwareAction = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("unknown", 0), ("get", 1), ("rsvd2", 2), ("rsvd3", 3), ("rsvd4", 4), ("rsvd5", 5), ("rsvd6", 6), ("rsvd7", 7), ("rsvd8", 8), ("rsvd9", 9), ("rsvd10", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: firmwareAction.setStatus('current')
if mibBuilder.loadTexts: firmwareAction.setDescription('The action the I/O Module must take for the firmware update operation.Upon receiving this command IOM must immediately execute the operation with all the necessary information which was preset prior to receiving this request')
fwUpdateOperationStatus = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 101, 201))).clone(namedValues=NamedValues(("noOperation", 0), ("success", 101), ("failure", 201)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fwUpdateOperationStatus.setStatus('current')
if mibBuilder.loadTexts: fwUpdateOperationStatus.setDescription('The status of the firmware update operation 0: No operation pending. 1-100: the percentage of completion of the update operation. 101: success. 201: failed')
firmwareServer = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 2, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: firmwareServer.setStatus('current')
if mibBuilder.loadTexts: firmwareServer.setDescription('This is a string of information about the final result of firmware update operation. It will further qualify in detail the information provided by the firmware update operation status and provide a text string indicating if the operation was successful or not successful. When the operation has completed successfully then the text string Success should be used. When the operation is not successful then a text string such as Failed to contact server or Image was not valid, would be appropriate to explain the reason for the failure.')
fwUpdateImageActivation = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fwUpdateImageActivation.setStatus('current')
if mibBuilder.loadTexts: fwUpdateImageActivation.setDescription('This value indicates which image index that the I/O Module must immediately activate.')
fwUpdateImageUri = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 2, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fwUpdateImageUri.setStatus('current')
if mibBuilder.loadTexts: fwUpdateImageUri.setDescription("This is a URI string specifies the protocol and various location parameters to be used by the switch to perform a get operation using any of the supported protocols TFTP, FTP, sFTP. SFTP and FTP are mandatory and TFTP is recommended to support various user update tools. The IOM must report the protocols supported for the level of executing firmware in the IOM capabilities field of the VPD EEPROM. In this context the CMM (or remote host) acts as the server and the IOM acts as the client. The format of this string is as follows: <protocol>://<username>:<password>@<IP address or hostname:<port>/<path>/<filename> An example of a URI for the firmware packet file would be: ftp://USERID:PASSW0RD@192.168.0.2:30045/tmp/1308 application.img1 or ftp://USERID:PASSW0RD@[fe80::290:27ff:fe29:6019]:30045/tmp/application.img or sftp://USERID:PASSW0RD@192.168.0.2:30045/tmp/application.img or sftp://USERID:PASSW0RD@[fe80::290:27ff:fe29:6019]:30045/tmp/application.img where the FTP or sFTP protocol will be used for transferring the packet file, username is USERID, password is PASSW0RD, host IP address is either fe80::290:27ff:fe29:6019 or 192.168.0.2, port number is 30045, and /tmp is the full pathname to the packet file application.img. Note: The URI may or may not have a port number. If the port number is not included the default port number for that protocol will be used. Some protocols do not need the username, password, and the port number, so the minimum requirement for a fully qualified address would be: <protocol>://<IP address or hostname>/<path</<filename> An example of a fully qualified address for the firmware packet file can be: tftp://192.168.0.2:2022/tmp/application.img. ote: (1) the MM will set the URI to the IOM. This URI may point to a server that is internal to the chassis with an IP address/hostname or if the server is external to the chassis then a public IP address/ hostname. Therefore the IP address of the server may or may not be the MMs IP address. In addition when a public IP address/hostname is used the filename in the URI may point to the top level directory that contains many files that make up the firmware image and the IOM is responsible to accept or reject this operation and indicate this by utilizing the status OID. Notes on sftp file transfers: (3) Summary: CMM will provide to the IOM the fingerprint of the CMM sftp server's public key as part of the other parameters in the URI for the file transfer. (4) CMM 'sets' to the IOM the URI which will contain the fingerprint (128bit MD5 fingerprint). For example assume the 128bit MD5 fingerprint of the 1024-bit RSA key is '00:6d:75:9e:f3:38:2b:6b:2e:e7:a8:87:9f:ea:26:03'. CMM issues a 'set' of the URI to the IOM of form: <protocol>://<username>:<password>;<fingerprint>@<IP address>:<port>/<path>/<filename. Then the URI would be: sftp://USERID:PASSW0RD; 00:6d:75:9e:f3:38:2b:6b:2e:e7:a8:87:9f:ea:26:03@ [fe80::290:27ff:fe29:6019]:30045/tmp/application.img (5) The fingerprint character string then will be used by IOM to create the CMM's sftp servers public key and add to the IOM's known host key file. (6) IOM sftp client then connects to the CMM sftp server. Since IOM has the CMM sftp servers public key fingerprint the IOM sftp client will look into it's known host key file. (7) IOM begins the sftp transfer of application.img using the user credentials (for example USERID, PASSW0RD) and CMM's sftp server key. Note - As of 5/1/2013 this specification assumes that the fingerprint in the URI will be for a RSA key only. Therefore all IOM sftp client's when connecting to the sftp server will respond to the sftp server and indicate in the 'server_host_key_algorithms list that a RSA key is the preferred key by listing this first in the 'server_host_key_algorithms' parameter 'name-list'. The sftp client and server then will be required to use a RSA key for the file transfer. In the future the URI syntax will be changed to allow the user to specify which type of key (RSA or DSA) the fingerprint is for. ")
fwUpdateImageSftpRsaKey = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 3, 1, 2, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fwUpdateImageSftpRsaKey.setStatus('deprecated')
if mibBuilder.loadTexts: fwUpdateImageSftpRsaKey.setDescription('Contains the public 1024 bit RSA key used for a secure file transfer utilizing sFTP over a SSH connection.The CMM will issue a set (write) of this object with the CMMs current public key when a SFTP transfer is required for a firmware transfer will occur to the CMMs SFTP server. This will enable the IOMs SSH client to perform SSH public key authentication with the CMMs SSH server.')
systemFile = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 1))
systemFileInformationTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 1, 1), )
if mibBuilder.loadTexts: systemFileInformationTable.setStatus('current')
if mibBuilder.loadTexts: systemFileInformationTable.setDescription('Table of System File information.')
systemFileInformationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 1, 1, 1), ).setIndexNames((0, "IBM-BCCUSTOM-MIB", "systemFileIndex"))
if mibBuilder.loadTexts: systemFileInformationEntry.setStatus('current')
if mibBuilder.loadTexts: systemFileInformationEntry.setDescription('I/O Module System File entry')
systemFileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemFileIndex.setStatus('current')
if mibBuilder.loadTexts: systemFileIndex.setDescription('System File index.')
systemFileInformation = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 1, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemFileInformation.setStatus('current')
if mibBuilder.loadTexts: systemFileInformation.setDescription('Information about the system file(s) that are supported by the IOM, on which the CMM can perform a get or put operation from/to the IOM. Two types of files are mandatory for the IOM, service file and configuration file. This string must follow the format below - This string must follow the format below: File-Name: %s\\n, Size: %d KB\\n, Date: %s\\n, Category: %s\\n, Type: %s, Other-Info: %s\\n\\0 File-Name: The file name of the file i.e service.log, new_config.cfg Size: The size of the file in Kbyte. Date: The date of the last update to the file. It must be in this format: mm/dd/yyyy hh:mm:ss. The hour is from 0-23. The time is based on GMT. Category: The system file must be one of the categories below: Service-Data, Saved-Configuration, Active-Configuration, New-Configuration, Other Type: It is either binary or text. Other-Info: Any additional information that the IOM wishes to provide about the file. String example 1:File Name: service.log, Size: 98 KB Date: 09/26/2008 14:35:21, Category: Service- Data, Type:text, Other Info: Service Data file. String example 2: File Name: config.cfg, Size: 6 KB Date: 09/26/2011 16:35:32, Category: Active-Configuration, Type: text, Other Info: Active Configuration file. The format of the System File Information is very important and must be strictly followed. It is intended for other applications to parse and make use of the information. The string is made up of many parts of text information. Each part has the format of the form Token: information_string\\n,. Each part consists of a token followed by token information. The end of each part is marked by a new line character, and a comma or a null character.The total length of the string cannot exceed 256 octets. Note: All IOMs must minimally support the Service-Data file type.')
systemFileInformationProtocols = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemFileInformationProtocols.setStatus('current')
if mibBuilder.loadTexts: systemFileInformationProtocols.setDescription('The CMM will use this command to read the current supported and enabled IOM file transfer protocols. The bit mask is treated as 32 bits in network byte order. That is the bit 0 will be the left most bit and bit 31 will be the right most bit. The bit pattern definition is defined as below. Supported Bit Mask (Bits 31:16): Bit(31): This bit is set to 1 if TFTP is supported. Bit(30): This bit is set to 1 if FTP is supported Bit(29): This bit is set to 1 if SFTP (via SSH) is supported Bit(28): This bit is set to 1 if HTTP is supported. Bit(27): This bit is set to 1 if HTTPs is supported Bit(26:16): Reserved: must be set to zeroes. Enabled Bit Mask (Bits 15:0): Bit(15): This bit is set to 1 if TFTP is enabled. Bit(14): This bit is set to 1 if FTP is enabled Bit(13): This bit is set to 1 if SFTP (via SSH) is enabled. Bit(12): This bit is set to 1 if HTTP is enabled. Bit(11): This bit is set to 1 if HTTPs is enabled Bit(10:0): Reserved: must be set to zeroes. .')
systemFileCmd = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 2))
systemFileCmdCnt = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemFileCmdCnt.setStatus('current')
if mibBuilder.loadTexts: systemFileCmdCnt.setDescription('The I/O Module must indicate the number of system files that it has available to user. For an example a value of 0 should be used if it has no system file, a value of 1 should be used if it has 1 system file.')
systemFileCmdFilename = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 2, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemFileCmdFilename.setStatus('deprecated')
if mibBuilder.loadTexts: systemFileCmdFilename.setDescription('The system file name and category of the file set by AMM that the I/O Module must use to perform an operation on the file. The string format of this command is defined: 1366 File-Name: %s\\n, Category: %s\\n\\0 File-Name: The file name of the file i.e service.log, new_config.cfg Category: The system file must be one of the categories defined in the MIB Object systemFileInformation. The format of this string is very important and must be strictly followed. The string is made up of many parts of text information. Each part has the format of the form Token: information_string\\n,. Each part consists of a token followed by token information. The end of each part is marked by a new line character, and a comma or a null character.1433 The total length of the string cannot exceed 256 octets.')
systemFileCmdMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemFileCmdMaxSize.setStatus('current')
if mibBuilder.loadTexts: systemFileCmdMaxSize.setDescription('The AMM will set the maximum file size allowable for the IOM system file when IOM upload its system file to a remote server. IOM must not exceed this file size limit. The file size will be in KB unit. The value of zero is to denote no limitation. If the actual file size of the system file on IOM is greater than the file size limitation, AMM will set other filter such as Severity, or timestamp to help reduce the file size before IOM upload the file to remote server. If the file size still exceeds the limitation, IOM must truncate the file to only include the most recent activity.')
systemFileCmdUri = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 2, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemFileCmdUri.setStatus('current')
if mibBuilder.loadTexts: systemFileCmdUri.setDescription("This is a URI string that specifies the location and various parameters to be used by the switch to perform a get or put operation using any of the supported protocols TFTP, FTP, sFTP, SFTP and FTP are mandatory and TFTP is recommended to support various user update tools. The IOM must report the protocols supported for the level of executing firmware in the IOM capabilities field of the VPD EEPROM. In this context the CMM (or remote host) acts as the server and the IOM acts as the client. The format of this string is as follows: <protocol>://<username>:<password>@<IP address or hostname>:<port>/<path>/<filename> An example of a fully qualified address for the firmware packet file would be: ftp://USERID:PASSW0RD@192.168.0.2:30045/tmp/service.log or ftp://USERID:PASSW0RD@[fe80::290:27ff:fe29:6019]:30045/tmp/service.log or sftp://USERID:PASSW0RD@192.168.0.2:30045/tmp/service.log or sftp://USERID:PASSW0RD@[fe80::290:27ff:fe29:6019]:30045/tmp/service.log where the FTP or sFTP protocol will be used for transferring the packet file, username is USERID, password is PASSW0RD, host IP address is fe80::290:27ff:fe29:6019 or 192.168.0.2, port number is 30045, and /tmp is the full pathname to the packet file service.log. Note: The URI may or may not have a port number. If the port number is not included the default port number for that protocol will be used. Some protocols do not need the username, password, and the port number, so the minimum requirement for a fully qualified address would be: <protocol>://<IP address or hostname>/<path</<filename> An example of a fully qualified address for the firmware packet file can be: tftp://192.168.0.2:2022/1527 tmp/service.log Note: CMM sets the systemFileCmdUri to provide the URI that includes the IP address, protocol, filename.filetype and any authentication parameters. a. If the IOM currently has a file contained in the IOM's file-system then the URI will contain the appropriate filename.filetype b. If the IOM does not generate the file until the file transfer, the CMM will create the URI with a prefix filename.filetype such as IOM3_service_.txt. The IOM is then responsible to parse the file name for a the category of file being requested by the CMM (_'service_' or '_config_' or '_syslog_'). Then concatenate to the MM's created prefix the IOM's VPD part-number and a timestamp. For example the IOM would use the prefix created by CMM 'IOM3_service_.txt' to 'IOM3_service_02R1014_20110916-004651.tgz'. (generic format is; <IOM(slot number)>_service_<IOM Part Number>_<date: 4 digit year 2 digit month 2 digit day>-<time: 2 digit hour 2 digit minutes 2 digit seconds> Note: file-type used is completely up to the IOM. Notes on sftp file transfers: (1) Summary: CMM will provide to the IOM the fingerprint of the CMM sftp server's public key as part of the other parameters in the URI for the file transfer. (2) CMM 'sets' to the IOM the URI which will contain the fingerprint (128bit MD5 fingerprint). For example assume the 128bit MD5 fingerprint of the 1024-bit RSA key is '00:6d:75:9e:f3:38:2b:6b:2e:e7:a8:87:9f:ea:26:03'. CMM issues a 'set' of the URI to the IOM of form: <protocol>://<username>:<password>;<fingerprint>@<IP address>:<port>/<path>/<filename. Then the URI would be: sftp://USERID:PASSW0RD; 00:6d:75:9e:f3:38:2b:6b:2e:e7:a8:87:9f:ea:26:03@ [fe80::290:27ff:fe29:6019]:30045/tmp/application.img (3) The fingerprint character string then will be used by IOM to create the CMM's sftp servers public key and add to the IOM's known host key file. (4) IOM sftp client then connects to the CMM sftp server. Since IOM has the CMM sftp servers public key fingerprint the IOM sftp client will look into it's known host key file. IOM begins the sftp transfer of application.img using the user credentials (for example USERID, PASSW0RD) and CMM's sftp server key. Note - As of 5/1/2013 this specification assumes that the fingerprint in the URI will be for a RSA key only. Therefore all IOM sftp client's when connecting to the sftp server will respond to the sftp server and indicate in the 'server_host_key_algorithms' list that a RSA key is the preferred key by listing this first in the 'server_host_key_algorithms' parameter name-list. ' The sftp client and server then will be required to use a RSA key for the file transfer. In the future the URI syntax will be changed to allow the user to specify which type of key (RSA or DSA) the fingerprint is for. ")
systemFileCmdSftpRsaKey = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 2, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemFileCmdSftpRsaKey.setStatus('deprecated')
if mibBuilder.loadTexts: systemFileCmdSftpRsaKey.setDescription('Contains the public 1024 bit RSA key used for a secure a file transfer utilizing sFTP over a SSH connection. The CMM will issue a set (write) of this object with the CMMs current public key when a SFTP transfer is required for a firmware transfer will occur to the CMMs SFTP server. This will enable the IOMs SSH client to perform SSH public key authentication with the CMMs SSH server.')
systemFileCmdExecuteOp = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("ssget", 1), ("cfgget", 2), ("cfgput", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemFileCmdExecuteOp.setStatus('current')
if mibBuilder.loadTexts: systemFileCmdExecuteOp.setDescription('The action the I/O Module must take on the system file MAX-ACCESS operation. Upon receiving this command IOM must immediately execute the operation with all the necessary information which was preset prior to receiving this request.')
systemFileOperationStatus = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50, 51, 101, 201))).clone(namedValues=NamedValues(("noOperation", 0), ("initiated", 1), ("generationcompleted", 50), ("transfer", 51), ("success", 101), ("failed", 201)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemFileOperationStatus.setStatus('current')
if mibBuilder.loadTexts: systemFileOperationStatus.setDescription('The status of the system file operation: 0: No operation pending. 1: Switch starting to generate supportshow 50: Switch done generating supportshow 51: Switch starting to transfer supportshow .txt file 101: success. 201: failed')
systemFileOpStatusString = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 2, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemFileOpStatusString.setStatus('current')
if mibBuilder.loadTexts: systemFileOpStatusString.setDescription('This is a string of information about the final result of system file operation. It will further qualify in detail the information provided by the system file operation status and provide a text string indicating if the operation was successful or not successful. When the operation has completed successfully then the text string Success should be used. When the operation is not successful then a text string such as Failed to contact server or File was not valid, would be appropriate to explain the reason for the failure.')
systemFileActivation = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 4, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noOp", 0), ("activate", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemFileActivation.setStatus('current')
if mibBuilder.loadTexts: systemFileActivation.setDescription('This object is used only for configuration files. After the transfer of the configuration file is completed to the IOM the CMM can use this object to immediately activate the configuration file at the IOM.')
ntpConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 215, 5, 1))
ntpEnable = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpEnable.setStatus('current')
if mibBuilder.loadTexts: ntpEnable.setDescription('Disable/Enable the NTP client. When set to enabled the MM previously set the following additional NTP client objects The NTP client must then be configured to values specified in the following objects and must update immediately the IOMs clock from the configured NTP server address. Note: certain IOM implementations1 may have their NTP client always enabled AND does not support the ability to disable or enable the NTP client from any external user interface. - If this is true, then a get of this object will always return enabled and a set to enable will return no_error. If a set of this object is performed to disabled then the IOM will return a gen_error. - If this is not true then a get and set to enable or disable must return no_error.')
ntpSrvIpv6Address = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpSrvIpv6Address.setStatus('current')
if mibBuilder.loadTexts: ntpSrvIpv6Address.setDescription("NTP server's IPv6 address. Note: This address represents the address that will be used for NTP requests and responses that utilize the MM internal port. A value of all zeroes indicates no address is configured. Note the MM will set an IPv6 or IPv4 address. If IPv6 address is set then the IPv4 NTP address will be zero. If IPv4 address is set then the IPv4 NTP address will be zero.")
ntpSrvIpv4Address = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 5, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpSrvIpv4Address.setStatus('current')
if mibBuilder.loadTexts: ntpSrvIpv4Address.setDescription("NTP server's IPv4 address. Note: This address represents the address that will be used for NTP requests and responses that utilize the MM internal port. A value of all zeroes indicates no address is configured. Note the MM will set an IPv6 or IPv4 address. If IPv6 address is set then the IPv4 NTP address will be zero. If IPv4 address is set then the IPv4 NTP address will be zero.")
ntpUpdateFrequency = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpUpdateFrequency.setStatus('current')
if mibBuilder.loadTexts: ntpUpdateFrequency.setDescription('The frequency in minutes that the NTP client service will synchronize the local clock with the NTP server. The value range is 1 to 44640 minutes. Note: certain IOM implementations may have their NTP client configured to always perform time synchronization at a specific frequency AND does not support the ability to change this frequency from any external user interface. - If this is true, then a get of this object will always return the frequency rounded to a 1 minute interval. If a set is issued for this object then IOM will return a gen_error. - If this is true, then a get of this object will always return the frequency rounded to a 1 minute interval. If a set is issued for this object then IOM will return a gen_error. If this is not true then a get and set must return no_error ')
ntpv3AuthConfig = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpv3AuthConfig.setStatus('current')
if mibBuilder.loadTexts: ntpv3AuthConfig.setDescription('The NTP v3 authentication entry to be used for time sync with a secure NTP server. The format of an authentication entry is <key index>::<key type>::<key>. The <key index> must be an INTEGER between 1 and 65534. <key type> must be M which signify MD5 encryption. The <key> is the actual value of the authentication key (symmetric) as configured on the NTP server. A SET operation can set the <key>. A GET operation returns back data in the format: <key index>::<key type> and does not return the encryption actual key value.')
ntpv3AuthEnable = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpv3AuthEnable.setStatus('current')
if mibBuilder.loadTexts: ntpv3AuthEnable.setDescription('Enables/Disables NTPv3 authentication')
iomSnmpv3Cfg = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 215, 6, 1))
iomSnmpv3UserName = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 6, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iomSnmpv3UserName.setStatus('current')
if mibBuilder.loadTexts: iomSnmpv3UserName.setDescription('String that contains the SNMPv3 userid. Note: this IOM<92>s SNMPv3 user account configuration must not be allowed to be altered from any of the IOM UI<92>s.')
iomSnmpv3UserAuthProtocol = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("sha", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iomSnmpv3UserAuthProtocol.setStatus('current')
if mibBuilder.loadTexts: iomSnmpv3UserAuthProtocol.setDescription('SNMPv3 - Authentication Protocol supported by the user. The only allowed protocol is <91>SHA<92>.')
iomSnmpv3UserAuthPassword = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iomSnmpv3UserAuthPassword.setStatus('current')
if mibBuilder.loadTexts: iomSnmpv3UserAuthPassword.setDescription('SNMPv3 User - Authentication password string. Notes: (1) The MM does not validate the contents of the password against any password security rules, the IOM is responsible for validation and may fail the set of this object, (2) value returned for a <91>get<92> request is null for security reasons.')
iomSnmpv3UserPrivacyProtocol = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("aes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iomSnmpv3UserPrivacyProtocol.setStatus('current')
if mibBuilder.loadTexts: iomSnmpv3UserPrivacyProtocol.setDescription('SNMPv3 - Privacy Protocol supported by the user. The only allowed protocol is <91>AES<92>.')
iomSnmpv3UserPrivacyPassword = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 6, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iomSnmpv3UserPrivacyPassword.setStatus('current')
if mibBuilder.loadTexts: iomSnmpv3UserPrivacyPassword.setDescription('SNMPv3 User - Privacy password string. Notes: (1) The MM does not validate the contents of the password against any password security rules, the IOM is responsible for validation and may fail the set of this object, (2) value returned for a <91>get<92> request is null for security reasons..')
iomSnmpv3UserAccessType = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("no-access", 0), ("get-traps", 1), ("get-set-traps", 2), ("traps-only", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iomSnmpv3UserAccessType.setStatus('current')
if mibBuilder.loadTexts: iomSnmpv3UserAccessType.setDescription('SNMPv3 User Access level (Get, Set, and Traps) of the user.')
iomSnmpv3UserIPv6TrapAddress = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 6, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iomSnmpv3UserIPv6TrapAddress.setStatus('current')
if mibBuilder.loadTexts: iomSnmpv3UserIPv6TrapAddress.setDescription('Trap destination IPv6 address. Note: This address represents the address that will be used by an external application for receiving SNMPv3 traps directly from the IOM<92>s SNMPv3 agent user account that has been configured in the user account OID(s) (iomSnmpv3User..). This address is in addition to the MM<92>s IP address and does not override or replace that trap address. This value is normally set to zero and will only be set when the external application request the MM to set to a valid IP address. A value of all zeroes indicates no address is configured. Both IPv4 and IPv6 addresses can be set and if they are then the IOM must send traps to both the IPv4 and IPv6 address. The format will be a string with a generic format of the IPv6 address as follows: <91>abcd:abcd:abcd:abcd:abcd:abcd:abcd:abcd<92>, also may be the compressed IPv6 address format, for example fe80::211:25ff:fec3:d364 .')
iomSnmpv3UserIPv4TrapAddress = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 6, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iomSnmpv3UserIPv4TrapAddress.setStatus('current')
if mibBuilder.loadTexts: iomSnmpv3UserIPv4TrapAddress.setDescription(' Trap destination IP4 address. Note: This address represents the address that will be used by an external application for receiving SNMPv3 traps directly from the IOM<92>s SNMPv3 agent user account that has been configured in SNMPv3 user account OID(s) (iomSnmpv3User). This address is in addition to the MM<92>s IP address and does not override or replace that trap address. This value is normally set to zero and will only be set when the external application request the MM to set to a valid IP address. Both IPv4 and IPv6 addresses can be set and if they are then the IOM must send traps to both the IPv4 and IPv6 address. A value of all zeroes indicates no address is configured. For example for a valid IPv4 address <91>9.72.217.85<92>, this would be represented as <91>0948d955<92>.')
iomSnmpv3UserState = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iomSnmpv3UserState.setStatus('current')
if mibBuilder.loadTexts: iomSnmpv3UserState.setDescription('Indicates the state of the user: Enabled or Disabled. The sequence of creating and enabling a user account or changing various OID<92>s of the SNMPv3 user account will be as follows: (1) Set the <91>iomSnmpv3UserState<92> to disabled. (2) Configure all the appropriate v3 user account information and trap address objects. (3) Set the <91>snmpv3UserState<92> to enabled. When the IOM receives a set to enable, the IOM is responsible to validate that all the SNMPv3 user objects are valid to create a functioning v3 user account. If they are not then the response to this set should fail as described in (4). (4) If all objects have been set correctly the response to this object will be <91>success<92> otherwise the response will indicate failure. Note: enforcing disabling then enabling the user account will ensure no partial account will be configured in the IOM SNMP agent.')
iomSnmpv3UserStateStatusString = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 6, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: iomSnmpv3UserStateStatusString.setStatus('current')
if mibBuilder.loadTexts: iomSnmpv3UserStateStatusString.setDescription(' This object will be a bit string that contains detailed information about the SNMPv3 user account status. The intent is that the information string will be passed to the external application in the event that the MM set an <91>enable<92> state using the object <91>iomSnmpv3UserState<92> and the response to the write of that object was a failure due to an invalid account parameter. The bit string in this object is only to be used by the MM for the case above, otherwise the data is not guaranteed to be accurate. The bit mask is treated as 32 bits in network byte order. That is the bit 0 will be the left most bit and bit 31 will be the right most bit. The bit pattern definition is defined as below: Bit(8:31): reserved must be set to zeroes. Bit(8): Set to 1 to indicate the IPv6 trap address is invalid. Bit(7): Set to 1 to indicate the IPv4 trap address is invalid Bit(6): Set to 1 to indicate the access type is invalid or not set. Bit(5): Set to 1 to indicate the privacy 2486 password is invalid or not set Bit(4): Set to 1 to indicate the privacy protocol is invalid or not set. Bit(3): Set to 1 to indicate 1 the authentication password is invalid or not set. Bit(2): Set to 1 to indicate the authentication protocol is invalid or not set. Bit(1): Set to 1 to indicate the user-name is invalid or not set. Bit(0): If this bit is set to <91>0<92> then this will indicate all account parameters are correct. The MM will then ignore all other bits within this object. If this bit is set to <91>1<92> then then at least one other bit must be set to indicate what specific account parameter(s) are invalid and caused the failed response to the <91>iomSnmpv3UserState<92> enable.')
iomSnmpv3TestTrap = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("traptest", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iomSnmpv3TestTrap.setStatus('current')
if mibBuilder.loadTexts: iomSnmpv3TestTrap.setDescription('This object provides a mechanism to generate a <91>test trap<92>. A set of this object will only generate a <91>test trap<92> from the IOM If a valid SNMPv3 user account has been configured and is enabled. The trap information should specifically indicate that it contains an informational test event.')
iomSnmpv3tResetUser = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 215, 6, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iomSnmpv3tResetUser.setStatus('current')
if mibBuilder.loadTexts: iomSnmpv3tResetUser.setDescription("This object provides a method to reset all the other objects that make up the SNMPv3 user account back to default values. This may be used for security reasons by the MM in order to provide a method to ensure the SNMPv3 user account is in a disabled state and all associated account information is back to default values (essentially at manufacturing reset values for the IOM). The following is a description of the expected account default values: - iomSnmpv3UserName - set to zero - iomSnmpv3UserAuthProtocol - set to '1' (sha) - iomSnmpv3UserAuthPassword - set to zero - iomSnmpv3UserPrivacyProtocol - set to '1' (aes) - iomSnmpv3UserPrivacyPassword - set to zero - iomSnmpv3UserAccessType - set to '0' (no-access) - iomSnmpv3UserIPv6TrapAddress - set to zero - iomSnmpv3UserIPv4TrapAddress - set to zero - iomSnmpv3UserState - set to '0' (disabled) - iomSnmpv3UserStateStatusString - set to zero")
licenseKeyInformationTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 215, 7, 1), )
if mibBuilder.loadTexts: licenseKeyInformationTable.setStatus('current')
if mibBuilder.loadTexts: licenseKeyInformationTable.setDescription('Table of License key information.')
licenseKeyInformationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 215, 7, 1, 1), ).setIndexNames((0, "IBM-BCCUSTOM-MIB", "licenseKeyIndex"))
if mibBuilder.loadTexts: licenseKeyInformationEntry.setStatus('current')
if mibBuilder.loadTexts: licenseKeyInformationEntry.setDescription('License Key entry')
licenseKeyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseKeyIndex.setStatus('current')
if mibBuilder.loadTexts: licenseKeyIndex.setDescription('License Key index.')
licenseKeyDescStringInformation = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 7, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseKeyDescStringInformation.setStatus('current')
if mibBuilder.loadTexts: licenseKeyDescStringInformation.setDescription('Information about the system file - This string must follow the format below: Description: %s\\n, Date-Time: %s\\n, License-ID: %s\\n, Other-Info: %s\\n\\0 Description: Description of the license key feature, for example NetCorp 12 Port License Key Upgrade for Fibre Switch. Date-Time: The date and time of the license key was installed in this format: mm/dd/yyyy hh:mm:ss. The hour is from 0-23. The time is based on GMT. License-ID: License ID, for example 222345K. Other-Info: Any additional information that the IOM wishes to provide about the key. String example 1:File Description: NetCorp 12 Port License Key Upgrade for Fibre Switch, Date-Time: 09/26/2008 14:35:21, License-ID: 222345K, Other Info: Test information. The format of the License Key Information is very important and must be strictly followed. It is intended for other applications to parse and make use of the information. The string is made up of many parts of text information. Each part has the format of the form Token: information_string\\n,. Each part consists of a token followed by token information. The end of each part is marked by a new line character, and a comma or a null character. The total length of the string cannot exceed 256 octets.')
licenseKeyCurrentState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 215, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("valid", 1), ("notValid", 2), ("expired", 3), ("usageExceeded", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseKeyCurrentState.setStatus('current')
if mibBuilder.loadTexts: licenseKeyCurrentState.setDescription('Provides information on the current state of the license')
mibBuilder.exportSymbols("IBM-BCCUSTOM-MIB", licenseKeyIndex=licenseKeyIndex, iomSnmpv3UserIPv4TrapAddress=iomSnmpv3UserIPv4TrapAddress, bcCustom=bcCustom, iomSnmpv3UserState=iomSnmpv3UserState, fwImageProtocols=fwImageProtocols, systemFileCmdSftpRsaKey=systemFileCmdSftpRsaKey, fwUpdateImageActivation=fwUpdateImageActivation, portModuleCableManufacturer=portModuleCableManufacturer, firmwareImageCnt=firmwareImageCnt, systemFileInformationEntry=systemFileInformationEntry, ibmProd=ibmProd, licenseKeyInformationTable=licenseKeyInformationTable, systemFileOperationStatus=systemFileOperationStatus, iomSnmpv3UserAuthPassword=iomSnmpv3UserAuthPassword, files=files, iomSnmpv3Cfg=iomSnmpv3Cfg, portModuleTotal=portModuleTotal, iomMode=iomMode, iomGlobal=iomGlobal, licenseKeyDescStringInformation=licenseKeyDescStringInformation, licenseKeyInformationEntry=licenseKeyInformationEntry, systemFileCmdCnt=systemFileCmdCnt, fwImageFileLocation=fwImageFileLocation, ntpSrvIpv6Address=ntpSrvIpv6Address, systemFileCmd=systemFileCmd, iomSnmpv3TestTrap=iomSnmpv3TestTrap, portModuleSpeedList=portModuleSpeedList, portModuleCableCompatiblity=portModuleCableCompatiblity, fwImageInformation=fwImageInformation, ports=ports, portInformation=portInformation, firmware=firmware, systemFileInformationTable=systemFileInformationTable, firmwareServer=firmwareServer, iomSnmpv3UserIPv6TrapAddress=iomSnmpv3UserIPv6TrapAddress, ibm=ibm, portModuleLinkState=portModuleLinkState, fwUpdateOperationStatus=fwUpdateOperationStatus, portModuleProtocol=portModuleProtocol, protocols=protocols, fwInformationEntry=fwInformationEntry, portModuleType=portModuleType, portModuleRelative=portModuleRelative, firmwareImageNum=firmwareImageNum, bcCustomMibVersion=bcCustomMibVersion, portModuleSpeed=portModuleSpeed, portModuleLaneCount=portModuleLaneCount, iomSnmpv3UserStateStatusString=iomSnmpv3UserStateStatusString, portModuleLicensedState=portModuleLicensedState, firmwareOps=firmwareOps, systemFile=systemFile, portInformationEntry=portInformationEntry, mibMajorMinor=mibMajorMinor, ntpv3AuthConfig=ntpv3AuthConfig, ntpv3AuthEnable=ntpv3AuthEnable, firmwareCmd=firmwareCmd, portModuleMedia=portModuleMedia, portModuleCableLength=portModuleCableLength, portModuleIndex=portModuleIndex, systemFileIndex=systemFileIndex, license=license, iomCapability=iomCapability, portModuleReal=portModuleReal, fwInformationTable=fwInformationTable, iomSnmpv3UserAccessType=iomSnmpv3UserAccessType, mibCustomVersion=mibCustomVersion, portModuleCableType=portModuleCableType, portModuleDataRate=portModuleDataRate, systemFileCmdExecuteOp=systemFileCmdExecuteOp, fwUpdateImageUri=fwUpdateImageUri, fwUpdateImageSftpRsaKey=fwUpdateImageSftpRsaKey, iomSnmpv3UserPrivacyProtocol=iomSnmpv3UserPrivacyProtocol, licenseKeyCurrentState=licenseKeyCurrentState, portModuleLabel=portModuleLabel, fwImageIndex=fwImageIndex, systemFileInformationProtocols=systemFileInformationProtocols, systemFileCmdFilename=systemFileCmdFilename, portInformationTable=portInformationTable, systemFileInformation=systemFileInformation, systemFileActivation=systemFileActivation, ntpUpdateFrequency=ntpUpdateFrequency, iomSnmpv3UserPrivacyPassword=iomSnmpv3UserPrivacyPassword, snmpuser=snmpuser, fwImageIsUpdateable=fwImageIsUpdateable, iomSnmpv3UserName=iomSnmpv3UserName, systemFileOpStatusString=systemFileOpStatusString, ntpEnable=ntpEnable, iomSnmpv3tResetUser=iomSnmpv3tResetUser, systemFileCmdMaxSize=systemFileCmdMaxSize, systemFileCmdUri=systemFileCmdUri, ntpConfig=ntpConfig, ntpSrvIpv4Address=ntpSrvIpv4Address, iomSnmpv3UserAuthProtocol=iomSnmpv3UserAuthProtocol, firmwareAction=firmwareAction, PYSNMP_MODULE_ID=bcCustom)

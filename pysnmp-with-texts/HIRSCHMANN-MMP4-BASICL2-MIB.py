#
# PySNMP MIB module HIRSCHMANN-MMP4-BASICL2-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HIRSCHMANN-MMP4-BASICL2-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:30:53 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint")
hirschmann, HmAgentLogSeverity = mibBuilder.importSymbols("HMPRIV-MGMT-SNMP-MIB", "hirschmann", "HmAgentLogSeverity")
IANAifType, = mibBuilder.importSymbols("IANAifType-MIB", "IANAifType")
dot1xPaePortNumber, = mibBuilder.importSymbols("IEEE8021-PAE-MIB", "dot1xPaePortNumber")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
InetAddress, = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress")
dot1qFdbId, VlanIndex, dot1qVlanIndex = mibBuilder.importSymbols("Q-BRIDGE-MIB", "dot1qFdbId", "VlanIndex", "dot1qVlanIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Integer32, Counter32, Gauge32, NotificationType, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Bits, TimeTicks, Counter64, IpAddress, MibIdentifier, iso, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Counter32", "Gauge32", "NotificationType", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Bits", "TimeTicks", "Counter64", "IpAddress", "MibIdentifier", "iso", "ObjectIdentity")
TextualConvention, DisplayString, TruthValue, RowStatus, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue", "RowStatus", "MacAddress")
hmPlatform4BasicL2 = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 15, 1))
hmPlatform4BasicL2.setRevisions(('2005-11-22 12:00', '2005-08-18 12:00', '2004-07-02 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hmPlatform4BasicL2.setRevisionsDescriptions(('Update for SW Release 01.0.01', 'Update for SW Release 01.0.00', 'first release',))
if mibBuilder.loadTexts: hmPlatform4BasicL2.setLastUpdated('200511221200Z')
if mibBuilder.loadTexts: hmPlatform4BasicL2.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hmPlatform4BasicL2.setContactInfo('Customer Support Postal: Hirschmann Automation and Control GmbH Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Tel: +49 7127 14 1981 Web: http://www.hicomcenter.com/ E-Mail: hicomcenter@hirschmann.com')
if mibBuilder.loadTexts: hmPlatform4BasicL2.setDescription('The Hirschmann Private Platform4 Basic Layer 2 MIB definitions for Platform devices.')
hmPlatform4 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15))
class HmAgentPortMask(TextualConvention, OctetString):
    description = "Each octet within this value specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the bridge is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports; the port is not included if its bit has a value of '0' When setting this value, the system will ignore configuration for ports not between the first and last valid ports. Configuration of any port numbers between this range that are not valid ports return a failure message, but will still apply configuration for valid ports."
    status = 'current'

class BridgeId(TextualConvention, OctetString):
    description = 'the Bridge-Identifier as used in the Spanning Tree'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class HmAgentDot1xPortControlMode(TextualConvention, Integer32):
    description = 'The control values of the Authenticator PAE controlled Port.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("forceUnauthorized", 1), ("auto", 2), ("forceAuthorized", 3), ("macBased", 4))

class HmAgentDot1xSessionTerminationAction(TextualConvention, Integer32):
    description = 'The action to be taken on session termination .'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("default", 1), ("reauthenticate", 2))

hmAgentInfoGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 1))
hmAgentTrapLogGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 1, 2))
hmAgentTrapLogTotal = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentTrapLogTotal.setStatus('current')
if mibBuilder.loadTexts: hmAgentTrapLogTotal.setDescription('The total number of traps sent since last reset.')
hmAgentTrapLogTotalSinceLastViewed = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 1, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentTrapLogTotalSinceLastViewed.setStatus('deprecated')
if mibBuilder.loadTexts: hmAgentTrapLogTotalSinceLastViewed.setDescription('The number of traps sent since last viewed.')
hmAgentTrapLogTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 1, 2, 4), )
if mibBuilder.loadTexts: hmAgentTrapLogTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentTrapLogTable.setDescription('Agent Trap Log')
hmAgentTrapLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 1, 2, 4, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentTrapLogIndex"))
if mibBuilder.loadTexts: hmAgentTrapLogEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentTrapLogEntry.setDescription('Agent trap log entry')
hmAgentTrapLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 1, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentTrapLogIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentTrapLogIndex.setDescription('Unique index of trap entry')
hmAgentTrapLogSystemTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 1, 2, 4, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentTrapLogSystemTime.setStatus('current')
if mibBuilder.loadTexts: hmAgentTrapLogSystemTime.setDescription('System uptime when trap was sent. This entry shows how long the system has been up when the trap occurred.')
hmAgentTrapLogTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 1, 2, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentTrapLogTrap.setStatus('current')
if mibBuilder.loadTexts: hmAgentTrapLogTrap.setDescription('Description of the trap sent.')
hmAgentConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2))
hmAgentCLIConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1))
hmAgentLoginSessionTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 1), )
if mibBuilder.loadTexts: hmAgentLoginSessionTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentLoginSessionTable.setDescription("A table of the switch's login session")
hmAgentLoginSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 1, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentLoginSessionIndex"))
if mibBuilder.loadTexts: hmAgentLoginSessionEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentLoginSessionEntry.setDescription('Login Session Entry')
hmAgentLoginSessionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentLoginSessionIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentLoginSessionIndex.setDescription('Agent Login Session Index of the switch')
hmAgentLoginSessionUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentLoginSessionUserName.setStatus('current')
if mibBuilder.loadTexts: hmAgentLoginSessionUserName.setDescription('Agent Login Session UserName of the switch')
hmAgentLoginSessionIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentLoginSessionIPAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentLoginSessionIPAddress.setDescription('Agent Login Session IP Address of the switch')
hmAgentLoginSessionConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("serial", 1), ("telnet", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentLoginSessionConnectionType.setStatus('current')
if mibBuilder.loadTexts: hmAgentLoginSessionConnectionType.setDescription('Agent Login Session Connection Type of the switch')
hmAgentLoginSessionIdleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentLoginSessionIdleTime.setStatus('current')
if mibBuilder.loadTexts: hmAgentLoginSessionIdleTime.setDescription('Agent Login Session Idle Time of the switch')
hmAgentLoginSessionSessionTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 1, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentLoginSessionSessionTime.setStatus('current')
if mibBuilder.loadTexts: hmAgentLoginSessionSessionTime.setDescription('Agent Login Session Time of the switch')
hmAgentLoginSessionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 1, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentLoginSessionStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentLoginSessionStatus.setDescription('Status of the user. active(1) - This connection is active. destroy(6) - Set to this value to disconnect this user.')
hmAgentLogging = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 14))
hmAgentLogConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 14, 1))
hmAgentLogSysLogConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 14, 1, 4))
hmAgentLogSyslogAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 14, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentLogSyslogAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentLogSyslogAdminStatus.setDescription('For Enabling and Disabling logging to configured syslog hosts. Setting this to disable stops logging to all syslog hosts.')
hmAgentLogSyslogHostTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 14, 1, 4, 5), )
if mibBuilder.loadTexts: hmAgentLogSyslogHostTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentLogSyslogHostTable.setDescription('Syslog host table containing syslog host entries.')
hmAgentLogSyslogHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 14, 1, 4, 5, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentLogHostTableIndex"))
if mibBuilder.loadTexts: hmAgentLogSyslogHostEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentLogSyslogHostEntry.setDescription('Syslog Host entry attributes.')
hmAgentLogHostTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 14, 1, 4, 5, 1, 1), Unsigned32())
if mibBuilder.loadTexts: hmAgentLogHostTableIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentLogHostTableIndex.setDescription('Index to syslog host entry in syslog host table.')
hmAgentLogHostTableIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 14, 1, 4, 5, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentLogHostTableIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentLogHostTableIpAddress.setDescription('Syslog Host table IP Address.')
hmAgentLogHostTablePort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 14, 1, 4, 5, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(514)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentLogHostTablePort.setStatus('current')
if mibBuilder.loadTexts: hmAgentLogHostTablePort.setDescription('Syslog Host table port number.')
hmAgentLogHostTableSeverityFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 14, 1, 4, 5, 1, 5), HmAgentLogSeverity().clone('critical')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentLogHostTableSeverityFilter.setStatus('current')
if mibBuilder.loadTexts: hmAgentLogHostTableSeverityFilter.setDescription('Configures the minimum severity that will be stored in the In Memory log.')
hmAgentLogHostTableRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 14, 1, 4, 5, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentLogHostTableRowStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentLogHostTableRowStatus.setDescription('Syslog Host table row status')
hmAgentTelnetConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 2))
hmAgentTelnetLoginTimeout = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 160))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentTelnetLoginTimeout.setStatus('current')
if mibBuilder.loadTexts: hmAgentTelnetLoginTimeout.setDescription('Telnet login timeout (minutes) Config telnet timeout will set the telnet session timeout value. A session is active as long as the session has not remained idle for the value set. Specify a value from 1 to 160. Note: Changing the timeout value for active sessions does not become effective until the session is reaccessed. Any keystroke will also activate the new timeout duration.')
hmAgentTelnetMaxSessions = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentTelnetMaxSessions.setStatus('current')
if mibBuilder.loadTexts: hmAgentTelnetMaxSessions.setDescription('Maximum number of Telnet Sessions Config telnet maxsessions is an integer value from 0 to 5 that specifies the maximum number of telnet sessions that can be established. If the value is 0, no Telnet session can be established. ')
hmAgentTelnetAllowNewMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentTelnetAllowNewMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentTelnetAllowNewMode.setDescription('Allow new telnet sessions (enable or disable) Config telnet disable means that no new Telnet sessions are to be established. Any already established session remains active until the session is ended or an abnormal network error ends it. ')
hmAgentUserConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 3))
hmAgentUserConfigCreate = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentUserConfigCreate.setStatus('current')
if mibBuilder.loadTexts: hmAgentUserConfigCreate.setDescription("Create a new user. When set with a non-empty string, a new user with that name will be created. This object will only return an empty string. This string is limited to alpha-numeric strings (uncluding the '-' and '_' characters).")
hmAgentUserConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 3, 2), )
if mibBuilder.loadTexts: hmAgentUserConfigTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentUserConfigTable.setDescription('User Config Table')
hmAgentUserConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 3, 2, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentUserIndex"))
if mibBuilder.loadTexts: hmAgentUserConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentUserConfigEntry.setDescription('User Config Entry')
hmAgentUserIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 3, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: hmAgentUserIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentUserIndex.setDescription('Agent User Config Index')
hmAgentUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 3, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentUserName.setStatus('current')
if mibBuilder.loadTexts: hmAgentUserName.setDescription("Agent User Name. This string is limited to alpha-numeric strings (including the '-' and '_' characters).")
hmAgentUserPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 3, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentUserPassword.setStatus('current')
if mibBuilder.loadTexts: hmAgentUserPassword.setDescription('Agent User Password This object will return an empty string even if a password is set.')
hmAgentUserAccessMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("read", 1), ("write", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentUserAccessMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentUserAccessMode.setDescription('Agent User Access Mode')
hmAgentUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 3, 2, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentUserStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentUserStatus.setDescription('Agent User Status. active(1) - This user account is active. destroy(6) - Set to this value to remove this user account.')
hmAgentUserAuthenticationType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("hmacmd5", 2), ("hmacsha", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentUserAuthenticationType.setStatus('current')
if mibBuilder.loadTexts: hmAgentUserAuthenticationType.setDescription('SNMPv3 User Authentication. The user passsword must be set to a string greater than or equal to 8 characters for this to be set to anything but none(1). none(1) - no authentication used hmacmd5(1) - Use HMAC-MD5 authentication hmacsha(1) - Use HMAC-SHA authentication')
hmAgentUserEncryptionType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("des", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentUserEncryptionType.setStatus('current')
if mibBuilder.loadTexts: hmAgentUserEncryptionType.setDescription('SNMPv3 User Encryption Can not be set to des(2) if hmAgentUserAuthenticationType is set to none(1). none(1) - no encryption used des(2) - DES encryption used')
hmAgentUserEncryptionPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 3, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentUserEncryptionPassword.setStatus('current')
if mibBuilder.loadTexts: hmAgentUserEncryptionPassword.setDescription('SNMPv3 User Encryption Password This object will return an empty string even if a password is set. hmAgentUserEncryptionType must be set to des(2) before this object can be configured. This object will return an empty string even if a password is set.')
hmAgentUserDefaultPwdActive = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 1, 3, 248), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentUserDefaultPwdActive.setStatus('current')
if mibBuilder.loadTexts: hmAgentUserDefaultPwdActive.setDescription('Shows if one or more default passwords are active for users configured in the hmAgentUserConfigTable.')
hmAgentLagConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2))
hmAgentLagConfigCreate = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 1), DisplayString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(1, 15), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentLagConfigCreate.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagConfigCreate.setDescription('Agent LAG Create. When this object is set with a non-empty string, a new LAG will be created if possible with the entered string as its name.')
hmAgentLagSummaryConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 2), )
if mibBuilder.loadTexts: hmAgentLagSummaryConfigTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagSummaryConfigTable.setDescription("A summary table of the switch's LAG config entries")
hmAgentLagSummaryConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 2, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentLagSummaryLagIndex"))
if mibBuilder.loadTexts: hmAgentLagSummaryConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagSummaryConfigEntry.setDescription("Switch's LAG config entry")
hmAgentLagSummaryLagIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentLagSummaryLagIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagSummaryLagIndex.setDescription('Agent LAG IfIndex. This value corresponds with the LAG interface in the ifTable.')
hmAgentLagSummaryName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentLagSummaryName.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagSummaryName.setDescription('Agent LAG Name. The associated name of the LAG used during creation.')
hmAgentLagSummaryFlushTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentLagSummaryFlushTimer.setStatus('obsolete')
if mibBuilder.loadTexts: hmAgentLagSummaryFlushTimer.setDescription('Agent LAG FlushTimer.')
hmAgentLagSummaryLinkTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentLagSummaryLinkTrap.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagSummaryLinkTrap.setDescription('Agent LAG LinkTrap. Configures sending Link Up/Down traps when the LAG interface goes Up or Down.')
hmAgentLagSummaryAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentLagSummaryAdminMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagSummaryAdminMode.setDescription('Agent LAG AdminMode. Administratively enables or disables this LAG interface.')
hmAgentLagSummaryStpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("off", 3), ("on", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentLagSummaryStpMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagSummaryStpMode.setDescription('Agent LAG StpMode.')
hmAgentLagSummaryAddPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentLagSummaryAddPort.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagSummaryAddPort.setDescription('Agent LAG AddPort. Set to a non 0 value to add a port to the LAG. Values correspond to ifIndex values in the ifTable. Note: hmAgentPortType for the port to be added must be full duplex and the same speed as previously added port(s), if any.')
hmAgentLagSummaryDeletePort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentLagSummaryDeletePort.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagSummaryDeletePort.setDescription('Agent LAG DeletePort. Set to a non 0 value to remove a port from the LAG. Values correspond to ifIndex values in the ifTable.')
hmAgentLagSummaryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 2, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentLagSummaryStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagSummaryStatus.setDescription('Agent LAG Status. active(1) - This LAG is enabled. destroy(6) - Set to this value to remove the LAG.')
hmAgentLagSummaryType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentLagSummaryType.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagSummaryType.setDescription('Agent LAG Type. static(1) - This LAG is staticly maintained. dynamic(2) - This LAG is dynamicly maintained.')
hmAgentLagDetailedConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 3), )
if mibBuilder.loadTexts: hmAgentLagDetailedConfigTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagDetailedConfigTable.setDescription("A detailed table of the switch's LAG config entries")
hmAgentLagDetailedConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 3, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentLagDetailedLagIndex"), (0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentLagDetailedIfIndex"))
if mibBuilder.loadTexts: hmAgentLagDetailedConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagDetailedConfigEntry.setDescription("Switch's LAG config entry")
hmAgentLagDetailedLagIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentLagDetailedLagIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagDetailedLagIndex.setDescription('LAG index')
hmAgentLagDetailedIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentLagDetailedIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagDetailedIfIndex.setDescription('LAG port index')
hmAgentLagDetailedPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 3, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentLagDetailedPortSpeed.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagDetailedPortSpeed.setDescription('LAG port speed. See hmAgentPortType for a description and list of valid values.')
hmAgentLagDetailedPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentLagDetailedPortStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagDetailedPortStatus.setDescription('LAG port status. active(1) - Actively participating in the LAG. inactive(2) - Not participating in the LAG.')
hmAgentLagConfigStaticCapability = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentLagConfigStaticCapability.setStatus('current')
if mibBuilder.loadTexts: hmAgentLagConfigStaticCapability.setDescription('Agent LAG Static Capability. Configures whether Static LAGs are supported on this device.')
hmAgentSpanningTreeConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 7))
hmAgentSpanningTreeMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSpanningTreeMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentSpanningTreeMode.setDescription("The switch's Spanning Tree Switch Status")
hmAgentSwitchConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8))
hmAgentSwitchAddressAgingTimeoutTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 4), )
if mibBuilder.loadTexts: hmAgentSwitchAddressAgingTimeoutTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchAddressAgingTimeoutTable.setDescription("The switch's address aging timeout table")
hmAgentSwitchAddressAgingTimeoutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 4, 1), ).setIndexNames((0, "Q-BRIDGE-MIB", "dot1qFdbId"))
if mibBuilder.loadTexts: hmAgentSwitchAddressAgingTimeoutEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchAddressAgingTimeoutEntry.setDescription('Aging information about a specific Filtering Database.')
hmAgentSwitchAddressAgingTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchAddressAgingTimeout.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchAddressAgingTimeout.setDescription("The FDB entry's address aging timeout (in seconds)")
hmAgentSwitchBroadcastControlMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchBroadcastControlMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchBroadcastControlMode.setDescription('The switch config broadcast allows you to enable or disable broadcast storm recovery mode. When you specify Enable for Broadcast Storm Recovery and the broadcast traffic on any Ethernet port exceeds 20 percent of the link speed, the switch blocks (discards) the broadcast traffic until the broadcast traffic returns to 10 percent or less. Upper limit for 10M link is 20% and lower limit is 10%. For 100M link Upper limit is 5% and lower limit is 2%')
hmAgentSwitchDot3FlowControlMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchDot3FlowControlMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchDot3FlowControlMode.setDescription('Config switchconfig flowcontrol allows you to enable or disable 802.3x flow control for the switch. This value applies to only full-duplex mode ports. ')
hmAgentSwitchStaticMacFilteringTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 5), )
if mibBuilder.loadTexts: hmAgentSwitchStaticMacFilteringTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchStaticMacFilteringTable.setDescription("The switch's static Mac filtering table")
hmAgentSwitchStaticMacFilteringEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 5, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentSwitchStaticMacFilteringVlanId"), (0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentSwitchStaticMacFilteringAddress"))
if mibBuilder.loadTexts: hmAgentSwitchStaticMacFilteringEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchStaticMacFilteringEntry.setDescription('Per-port ingress/egress filter configuration based on VLAN Id and MAC address.')
hmAgentSwitchStaticMacFilteringVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchStaticMacFilteringVlanId.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchStaticMacFilteringVlanId.setDescription('The Static MAC Filter Vlan Id')
hmAgentSwitchStaticMacFilteringAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 5, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchStaticMacFilteringAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchStaticMacFilteringAddress.setDescription('The Static MAC Filter MAC address')
hmAgentSwitchStaticMacFilteringSourcePortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 5, 1, 3), HmAgentPortMask()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchStaticMacFilteringSourcePortMask.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchStaticMacFilteringSourcePortMask.setDescription('The Static MAC Filter source port mask. When setting this value, the system will ignore configuration for ports not between the first and last valid ports. Configuration of any port numbers between this range that are not valid ports return a failure message, but will still apply configuration for valid ports. To obtain port numbers from interface numbers, use the objects hmAgentPortDot1dBasePort and hmAgentPortIfIndex in the hmAgentPortConfigTable table.')
hmAgentSwitchStaticMacFilteringDestPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 5, 1, 4), HmAgentPortMask()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchStaticMacFilteringDestPortMask.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchStaticMacFilteringDestPortMask.setDescription('The Static MAC Filter destination port mask. When setting this value, the system will ignore configuration for ports not between the first and last valid ports. Configuration of any port numbers between this range that are not valid ports return a failure message, but will still apply configuration for valid ports. To obtain port numbers from interface numbers, use the objects hmAgentPortDot1dBasePort and hmAgentPortIfIndex in the hmAgentPortConfigTable table.')
hmAgentSwitchStaticMacFilteringStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 5, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentSwitchStaticMacFilteringStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchStaticMacFilteringStatus.setDescription('The Static MAC Filter status. Supported values: active(1) - valid entry createAndGo(4) - used to create a new entry destroy(6) - removes the entry')
hmAgentSwitchIGMPSnoopingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 6))
hmAgentSwitchIGMPSnoopingAdminMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIGMPSnoopingAdminMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIGMPSnoopingAdminMode.setDescription('This enables or disables IGMP Snooping on the system. ')
hmAgentSwitchIGMPSnoopingGroupMembershipInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 6, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 3600)).clone(260)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIGMPSnoopingGroupMembershipInterval.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIGMPSnoopingGroupMembershipInterval.setDescription('The amount of time in seconds a switch will wait for a report for a particular group on a particular interface before it deletes the interface from the entry. ')
hmAgentSwitchIGMPSnoopingMaxResponseTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 6, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3598)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIGMPSnoopingMaxResponseTime.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIGMPSnoopingMaxResponseTime.setDescription('The amount of time in seconds a switch will wait after sending a query on an interface because it did not receive a report for a particular group in that interface. This value must be less than hmAgentSwitchIGMPSnoopingQueryInterval.')
hmAgentSwitchIGMPSnoopingMRPExpirationTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 6, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(260)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIGMPSnoopingMRPExpirationTime.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIGMPSnoopingMRPExpirationTime.setDescription('Multicast Router Present Expiration Time. The amount of time in seconds a switch will wait for a query to be received on an interface before the interface is removed from the list of interfaces with mutlticast routers attached. A value of zero indicates an infinite timeout, i.e. the entries in the list will not expire.')
hmAgentSwitchIGMPSnoopingPortMask = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 6, 5), HmAgentPortMask().clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIGMPSnoopingPortMask.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIGMPSnoopingPortMask.setDescription('IGMP Snooping Port Mask. This allows configuration of IGMP Snooping on selected ports. IGMP Snooping cannot be enabled on an interface that has routing enabled, or is a member of a LAG. If a port which has IGMP Snooping enabled becomes enabled for routing, or is enlisted as a member of a LAG, IGMP Snooping functionality will be disabled on that port. IGMP Snooping functionality will be subsequently be reenabled if routing is disabled or LAG membership is removed from an interface that had previously had IGMP Snooping enabled. To obtain port numbers from interface numbers, use the objects hmAgentPortDot1dBasePort and hmAgentPortIfIndex in the hmAgentPortConfigTable table.')
hmAgentSwitchIGMPSnoopingMulticastControlFramesProcessed = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 6, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchIGMPSnoopingMulticastControlFramesProcessed.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIGMPSnoopingMulticastControlFramesProcessed.setDescription('Multicast Control Frames Processed by CPU. The number of multicast control frames that have been processed by the CPU.')
hmAgentSwitchMFDBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7))
hmAgentSwitchMFDBTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 1), )
if mibBuilder.loadTexts: hmAgentSwitchMFDBTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBTable.setDescription('The Multicast Forwarding Database table')
hmAgentSwitchMFDBEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 1, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentSwitchMFDBVlanId"), (0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentSwitchMFDBMacAddress"), (0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentSwitchMFDBProtocolType"))
if mibBuilder.loadTexts: hmAgentSwitchMFDBEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBEntry.setDescription('Contains Forwarding and Filtering information per Vlan Index, MAC Address, and Component User.')
hmAgentSwitchMFDBVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 1, 1, 1), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchMFDBVlanId.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBVlanId.setDescription('Vlan Index for which this entry is associated with.')
hmAgentSwitchMFDBMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchMFDBMacAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBMacAddress.setDescription('A multicast MAC address for which the switch has forwarding and or filtering information.')
hmAgentSwitchMFDBProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("static", 1), ("gmrp", 2), ("igmp", 3), ("msd", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchMFDBProtocolType.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBProtocolType.setDescription('The component that is responsible for this entry in the Multicast Forwarding Database.')
hmAgentSwitchMFDBType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchMFDBType.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBType.setDescription('This displays the type of the entry. static(1) - Entries configured by the end user dynamic(2) - Entries added as a result of a learning process or protocol')
hmAgentSwitchMFDBDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchMFDBDescription.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBDescription.setDescription('Text description of this multicast table entry.')
hmAgentSwitchMFDBForwardingPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 1, 1, 6), HmAgentPortMask()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchMFDBForwardingPortMask.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBForwardingPortMask.setDescription('BitMask indicating which ports this entry indicates should be forwarded. To obtain port numbers from interface numbers, use the objects hmAgentPortDot1dBasePort and hmAgentPortIfIndex in the hmAgentPortConfigTable table.')
hmAgentSwitchMFDBFilteringPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 1, 1, 7), HmAgentPortMask()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchMFDBFilteringPortMask.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBFilteringPortMask.setDescription('BitMask indicating which ports this entry indicates should be filtered. To obtain port numbers from interface numbers, use the objects hmAgentPortDot1dBasePort and hmAgentPortIfIndex in the hmAgentPortConfigTable table.')
hmAgentSwitchMFDBSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 2), )
if mibBuilder.loadTexts: hmAgentSwitchMFDBSummaryTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBSummaryTable.setDescription('The Multicast Forwarding Database Summary table')
hmAgentSwitchMFDBSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 2, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentSwitchMFDBSummaryVlanId"), (0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentSwitchMFDBSummaryMacAddress"))
if mibBuilder.loadTexts: hmAgentSwitchMFDBSummaryEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBSummaryEntry.setDescription('Summarizes the forwarding ports for all components registered for all MFDB table entries with the same Vlan Index and MAC Address.')
hmAgentSwitchMFDBSummaryVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 2, 1, 1), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchMFDBSummaryVlanId.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBSummaryVlanId.setDescription('Vlan Index for which this entry is associated with.')
hmAgentSwitchMFDBSummaryMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 2, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchMFDBSummaryMacAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBSummaryMacAddress.setDescription('A multicast MAC address for which the switch has forwarding and or filtering information.')
hmAgentSwitchMFDBSummaryForwardingPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 2, 1, 3), HmAgentPortMask()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchMFDBSummaryForwardingPortMask.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBSummaryForwardingPortMask.setDescription('Port Mask indicating which ports this entry indicates should be forwarded. To obtain port numbers from interface numbers, use the objects hmAgentPortDot1dBasePort and hmAgentPortIfIndex in the hmAgentPortConfigTable table.')
hmAgentSwitchMFDBMaxTableEntries = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchMFDBMaxTableEntries.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBMaxTableEntries.setDescription('This displays the maximum number of entries that can possibly be in the Multicast Forwarding Database table.')
hmAgentSwitchMFDBMostEntriesUsed = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchMFDBMostEntriesUsed.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBMostEntriesUsed.setDescription('This displays the largest number of entries that have been present in the Multicast Forwarding Database table. This value is also known as the MFDB high-water mark.')
hmAgentSwitchMFDBCurrentEntries = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 7, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchMFDBCurrentEntries.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchMFDBCurrentEntries.setDescription('This displays the current number of entries in the Multicast Forwarding Database table.')
hmAgentSwitchDVlanTagGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 8))
hmAgentSwitchDVlanTagEthertype = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchDVlanTagEthertype.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchDVlanTagEthertype.setDescription('Configures the Double Vlan Tag Ethertype for the switch. If this object is supported, ethertype cannot be configured per port. Commonly used are the Ethertypes for vman tags (34984, or 0x88A8) and dot1q tags (33024, or 0x8100).')
hmAgentTransferConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9))
hmAgentTransferUploadGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 1))
hmAgentTransferUploadMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tftp", 1), ("xmodem", 2), ("ymodem", 3), ("zmodem", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentTransferUploadMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentTransferUploadMode.setDescription('Transfer upload mode configures the mode to use when uploading from the switch. The mode is either X/Y/ZMODEM or TFTP. X/Y/ZMODEM is valid only when the file transfer is initiated by the serial EIA 232 port. ')
hmAgentTransferUploadServerIP = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentTransferUploadServerIP.setStatus('current')
if mibBuilder.loadTexts: hmAgentTransferUploadServerIP.setDescription('Transfer upload tftpserverip configures the IP address of the server where the file is located. It is valid only when the Transfer Mode is TFTP. The address is 4 integer bytes ranging from 0 to 255.')
hmAgentTransferUploadPath = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentTransferUploadPath.setStatus('current')
if mibBuilder.loadTexts: hmAgentTransferUploadPath.setDescription('Transfer upload tftppath configures the directory path where the file is to be uploaded to. The switch remembers the last file path used. ')
hmAgentTransferUploadFilename = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentTransferUploadFilename.setStatus('current')
if mibBuilder.loadTexts: hmAgentTransferUploadFilename.setDescription('Transfer upload tftpfilename configures the file name for the file being uploaded from the switch. It can be up to 32 alphanumeric characters. The switch remembers the last file name used. File path can be appended to the file name if the string is less than 17 characters. Otherwise, the File Path field will need to be used and the File Name will be appended to the File Path as is. An example would be File Path set to c:/tftp/code/ and File Name set to e1r1v1.opr. Note: File Name, File Path, and TFTP Server IP Address are applicable only if the Transfer Mode is TFTP.')
hmAgentTransferUploadDataType = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("config", 2), ("errorlog", 3), ("messagelog", 4), ("traplog", 5), ("clibanner", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentTransferUploadDataType.setStatus('current')
if mibBuilder.loadTexts: hmAgentTransferUploadDataType.setDescription('Transfer upload datatype configures the type of file to upload from the switch. The types for upload are: - Configuration File - Error log - Message log - Trap log ')
hmAgentTransferUploadStart = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentTransferUploadStart.setStatus('current')
if mibBuilder.loadTexts: hmAgentTransferUploadStart.setDescription('Transfer upload start will start an upload transfer. The hmAgentTransferUploadMode object must not be set to xmodem(2), ymodem(3), or zmodem(4) to initiate a transfer via SNMP.')
hmAgentTransferUploadStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("notInitiated", 1), ("transferStarting", 2), ("errorStarting", 3), ("wrongFileType", 4), ("updatingConfig", 5), ("invalidConfigFile", 6), ("writingToFlash", 7), ("failureWritingToFlash", 8), ("checkingCRC", 9), ("failedCRC", 10), ("unknownDirection", 11), ("transferSuccessful", 12), ("transferFailed", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentTransferUploadStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentTransferUploadStatus.setDescription('Indicates the current status of an upload transfer.')
hmAgentTransferDownloadGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 2))
hmAgentTransferDownloadMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tftp", 1), ("xmodem", 2), ("ymodem", 3), ("zmodem", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentTransferDownloadMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentTransferDownloadMode.setDescription('Transfer download mode configures the mode to use when downloading to the switch. The mode is either X/Y/ZMODEM or TFTP. X/Y/ZMODEM is valid only when the file transfer is initiated by the serial EIA 232 port. ')
hmAgentTransferDownloadServerIP = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentTransferDownloadServerIP.setStatus('current')
if mibBuilder.loadTexts: hmAgentTransferDownloadServerIP.setDescription('Transfer download tftpserverip configures the IP address of the server where the file is located. It is valid only when the Transfer Mode is TFTP. The address is 4 integer bytes ranging from 0 to 255. ')
hmAgentTransferDownloadPath = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentTransferDownloadPath.setStatus('current')
if mibBuilder.loadTexts: hmAgentTransferDownloadPath.setDescription('Transfer download tftppath configures the directory path where the file is located. The switch remembers the last file path used. ')
hmAgentTransferDownloadFilename = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 2, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentTransferDownloadFilename.setStatus('current')
if mibBuilder.loadTexts: hmAgentTransferDownloadFilename.setDescription('Transfer download tftpfilename configures the file name for the file being downloaded to the switch. It can be up to 32 alphanumeric characters. The switch remembers the last file name used. File path can be appended to the file name if the string is less than 33 characters. Otherwise, the File Path field will need to be used and the File Name will be appended to the File Path as is. An example would be File Path set to c:/tftp/code/ and File Name set to e1r1v1.opr. Note: File Name, File Path, and TFTP Server IP Address are applicable only if the Transfer Mode is TFTP.')
hmAgentTransferDownloadDataType = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("code", 2), ("config", 3), ("sshkey-rsa1", 4), ("sshkey-rsa2", 5), ("sshkey-dsa", 6), ("sslpem-root", 7), ("sslpem-server", 8), ("sslpem-dhweak", 9), ("sslpem-dhstrong", 10), ("clibanner", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentTransferDownloadDataType.setStatus('current')
if mibBuilder.loadTexts: hmAgentTransferDownloadDataType.setDescription('Transfer download datatype configures the type of file to download to the switch. The types for download are: code - Code File config - Configuration File ')
hmAgentTransferDownloadStart = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentTransferDownloadStart.setStatus('current')
if mibBuilder.loadTexts: hmAgentTransferDownloadStart.setDescription('Transfer download start will start an download transfer. The hmAgentTransferDownloadMode object must not be set to xmodem(2), ymodem(3), or zmodem(4) to initiate a transfer via SNMP.')
hmAgentTransferDownloadStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 9, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("notInitiated", 1), ("transferStarting", 2), ("errorStarting", 3), ("wrongFileType", 4), ("updatingConfig", 5), ("invalidConfigFile", 6), ("writingToFlash", 7), ("failureWritingToFlash", 8), ("checkingCRC", 9), ("failedCRC", 10), ("unknownDirection", 11), ("transferSuccessful", 12), ("transferFailed", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentTransferDownloadStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentTransferDownloadStatus.setDescription('Indicates the current status of an download transfer.')
hmAgentPortMirroringGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 10))
hmAgentMirroredPortIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 10, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentMirroredPortIfIndex.setStatus('obsolete')
if mibBuilder.loadTexts: hmAgentMirroredPortIfIndex.setDescription('IfIndex of the mirrored port')
hmAgentProbePortIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 10, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentProbePortIfIndex.setStatus('obsolete')
if mibBuilder.loadTexts: hmAgentProbePortIfIndex.setDescription('IfIndex of the probe port')
hmAgentPortMirroringMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("delete", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortMirroringMode.setStatus('obsolete')
if mibBuilder.loadTexts: hmAgentPortMirroringMode.setDescription('Port mirroring mode: enable - enable mirroring mode disable - disable mirroring mode delete - clear MirroredPort and Probe Port configuration')
hmAgentPortMirrorTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 10, 4), )
if mibBuilder.loadTexts: hmAgentPortMirrorTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortMirrorTable.setDescription('This table includes entries for each Port Mirroring session.')
hmAgentPortMirrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 10, 4, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentPortMirrorSessionNum"))
if mibBuilder.loadTexts: hmAgentPortMirrorEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortMirrorEntry.setDescription('Provides configuration of a Port Mirroring session specifying the destination port, and the source Port Mask, providing a many-to-one mapping.')
hmAgentPortMirrorSessionNum = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 10, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: hmAgentPortMirrorSessionNum.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortMirrorSessionNum.setDescription('The Session number of this mirroring entry. The number of sessions is fixed, and is platform dependant.')
hmAgentPortMirrorDestinationPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 10, 4, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortMirrorDestinationPort.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortMirrorDestinationPort.setDescription('The port which traffic from the mirrored ports will be sent to.')
hmAgentPortMirrorSourcePortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 10, 4, 1, 3), HmAgentPortMask()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortMirrorSourcePortMask.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortMirrorSourcePortMask.setDescription('The ports from which traffic will be sent to the destination port. The destination port can not be included in this list of ports.')
hmAgentPortMirrorIngressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 10, 4, 1, 248), HmAgentPortMask()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortMirrorIngressMask.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortMirrorIngressMask.setDescription('The ports from which ingress traffic will be mirrored.')
hmAgentPortMirrorEgressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 10, 4, 1, 249), HmAgentPortMask()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortMirrorEgressMask.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortMirrorEgressMask.setDescription('The ports from which egress traffic will be mirrored.')
hmAgentPortMirrorAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 10, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortMirrorAdminMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortMirrorAdminMode.setDescription('The status of this port mirroring session. enable(1) - This session is active and all traffic from the source ports will be mirrored to the destination port. disable(2) - This session is not active. delete(3) - Remove the configuration for this Session')
hmAgentDot3adAggPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 12), )
if mibBuilder.loadTexts: hmAgentDot3adAggPortTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot3adAggPortTable.setDescription('This table provides 802.3ad link aggregation information for each physical port that is not available through the standard MIB.')
hmAgentDot3adAggPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 12, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentDot3adAggPort"))
if mibBuilder.loadTexts: hmAgentDot3adAggPortEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot3adAggPortEntry.setDescription('Information about a table entry. The hmAgentDot3adAggPort identifies the external interface number of the port.')
hmAgentDot3adAggPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot3adAggPort.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot3adAggPort.setDescription('ifIndex of this physical port')
hmAgentDot3adAggPortLACPMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentDot3adAggPortLACPMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot3adAggPortLACPMode.setDescription('Enable/disable 802.3ad LACP on this port')
hmAgentPortConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13), )
if mibBuilder.loadTexts: hmAgentPortConfigTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortConfigTable.setDescription("A table of the switch's physical port config entries")
hmAgentPortConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentPortDot1dBasePort"))
if mibBuilder.loadTexts: hmAgentPortConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortConfigEntry.setDescription("Switch's physical port config entry")
hmAgentPortDot1dBasePort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentPortDot1dBasePort.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortDot1dBasePort.setDescription('The port number of this port.')
hmAgentPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentPortIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortIfIndex.setDescription("The switch's Port IfIndex")
hmAgentPortIanaType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 3), IANAifType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentPortIanaType.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortIanaType.setDescription("The switch's Port Type")
hmAgentPortSTPMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dot1d", 1), ("fast", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortSTPMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortSTPMode.setDescription("The switch's Port Spanning Tree Protocol Mode STP mode values are: dot1d (the default) fast, indicates you want to use the fast spanning tree mode off, indicates the STP mode is turned off for a particular port This object is only supported when the Dot1d Protocol is enabled.")
hmAgentPortSTPState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("blocking", 1), ("listening", 2), ("learning", 3), ("forwarding", 4), ("disabled", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentPortSTPState.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortSTPState.setDescription("The switch's Port Spanning Tree Protocol State. This object is only supported when the Dot1d Protocol is enabled.")
hmAgentPortAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortAdminMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortAdminMode.setDescription("The switch's Port Admin Mode")
hmAgentPortPhysicalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("auto-negotiate", 1), ("half-10", 2), ("full-10", 3), ("half-100", 4), ("full-100", 5), ("half-100fx", 6), ("full-100fx", 7), ("full-1000sx", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortPhysicalMode.setStatus('obsolete')
if mibBuilder.loadTexts: hmAgentPortPhysicalMode.setDescription("The switch's Port Speed Mode. This is the configured physical mode. This object is read-only for gigabit ports")
hmAgentPortPhysicalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("auto-negotiate", 1), ("half-10", 2), ("full-10", 3), ("half-100", 4), ("full-100", 5), ("half-100fx", 6), ("full-100fx", 7), ("full-1000sx", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentPortPhysicalStatus.setStatus('obsolete')
if mibBuilder.loadTexts: hmAgentPortPhysicalStatus.setDescription("The switch's Port Physical Speed Status. This is the current actual speed.")
hmAgentPortLinkTrapMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortLinkTrapMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortLinkTrapMode.setDescription('If enabled, link up and link down traps will be sent for this port.')
hmAgentPortClearStats = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortClearStats.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortClearStats.setDescription('clear stats for this port only')
hmAgentPortDefaultType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 11), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortDefaultType.setReference('RFC 2668')
if mibBuilder.loadTexts: hmAgentPortDefaultType.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortDefaultType.setDescription('This object identifies the default administrative port type, to be used in conjunction with the operational port type denoted by hmAgentPortType. The set of possible values for this object is the same as the set defined for the hmAgentPortType object. This object represents the administratively-configured type of the MAU. If auto-negotiation is not enabled or is not implemented for this MAU, the value of this object determines the operational type of the MAU. In this case, a set to this object will force the MAU into the specified operating mode. If auto-negotiation is implemented and enabled for this MAU, the operational type of the MAU is determined by auto-negotiation, and the value of this object denotes the type to which the MAU will automatically revert if/when auto-negotiation is later disabled. The valid values for this object are: dot3MauType10BaseTHD dot3MauType10BaseTFD dot3MauType100BaseTXHD dot3MauType100BaseTXFD dot3MauType100BaseFXFD dot3MauType1000BaseSXFD')
hmAgentPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 12), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentPortType.setReference('RFC 2668')
if mibBuilder.loadTexts: hmAgentPortType.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortType.setDescription('This object identifies the port type. An initial set of MAU types are defined in RFC 2668. The assignment of OBJECT IDENTIFIERs to new types of MAUs is managed by the IANA. If the MAU type is unknown, the object identifier unknownMauType OBJECT IDENTIFIER ::= { 0 0 } is returned. Note that unknownMauType is a syntactically valid object identifier, and any conformant implementation of ASN.1 and the BER must be able to generate and recognize this value. This object represents the operational type of the MAU, as determined by either (1) the result of the auto-negotiation function or (2) if auto-negotiation is not enabled or is not implemented for this MAU, by the value of the object hmAgentPortDefaultType, or (3) for the GigE card a value determined by the GBIC connected to the card. In case (2), a set to the object hmAgentPortDefaultType will force the MAU into the new operating mode. The valid values for this object are: dot3MauType10BaseTHD dot3MauType10BaseTFD dot3MauType100BaseTXHD dot3MauType100BaseTXFD dot3MauType100BaseFXFD dot3MauType1000BaseSXFD dot3MauType1000BaseTFD')
hmAgentPortAutoNegAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortAutoNegAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortAutoNegAdminStatus.setDescription('This object identifies the administration status of auto negotiation for this port.')
hmAgentPortDot3FlowControlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortDot3FlowControlMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortDot3FlowControlMode.setDescription('Config flowcontrol allows you to enable or disable 802.3x flow control for this port. This value applies to only full-duplex mode ports. ')
hmAgentPortDVlanTagMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("core", 1), ("normal", 2), ("access", 3))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortDVlanTagMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortDVlanTagMode.setDescription('Controls the Double Vlan Tag mode on this port. Default is normal(2).')
hmAgentPortDVlanTagEthertype = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(33024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortDVlanTagEthertype.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortDVlanTagEthertype.setDescription('Configures the Double Vlan Tag Ethertype for this port. If this object is supported, ethertype cannot be configured globally for the switch. Commonly used are the Ethertypes for vman tags (34984, or 0x88A8) and dot1q tags (33024, or 0x8100).')
hmAgentPortDVlanTagCustomerId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortDVlanTagCustomerId.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortDVlanTagCustomerId.setDescription('Configures the Customer ID for the Double Vlan Tag for this port.')
hmAgentPortMaxFrameSizeLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentPortMaxFrameSizeLimit.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortMaxFrameSizeLimit.setDescription('This object identifies the largest value that can be configured for hmAgentPortMaxFrameSize')
hmAgentPortMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortMaxFrameSize.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortMaxFrameSize.setDescription('This object identifies the currently configured maximum frame size value for this port. The maximmum value that this object can be set to is the value of hmAgentPortMaxFrameSizeLimit. For Ethernet ports which support 802.1Q vlan tagging, the minimum value that this object can be set to is 1522')
hmAgentPortVoiceVlanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("vlanid", 2), ("dot1p", 3), ("vlanidanddot1p", 4), ("untagged", 5), ("disable", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortVoiceVlanMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortVoiceVlanMode.setDescription('Describes and Configures the Port Voice VLAN Mode.')
hmAgentPortVoiceVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4093))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortVoiceVlanID.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortVoiceVlanID.setDescription('Describes and Configures the Port Voice VLAN ID if the Voice Vlan Mode is Vlan ID.')
hmAgentPortVoiceVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 7), ValueRangeConstraint(255, 255), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortVoiceVlanPriority.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortVoiceVlanPriority.setDescription('Describes and Configures the Port Voice VLAN Priority if the Voice Vlan Mode is dot1p. A value of 255 indicates that the priority is not configured.')
hmAgentPortVoiceVlanDataPriorityMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trust", 1), ("untrust", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortVoiceVlanDataPriorityMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortVoiceVlanDataPriorityMode.setDescription('Describes and Configures the Port Voice VLAN Data Priority Mode.')
hmAgentPortVoiceVlanOperationalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentPortVoiceVlanOperationalStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortVoiceVlanOperationalStatus.setDescription('Describes the Port Voice VLAN Operational Status.')
hmAgentPortVoiceVlanDSCP = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortVoiceVlanDSCP.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortVoiceVlanDSCP.setDescription('Describes and Configures the Port Voice VLAN DSCP value.')
hmAgentPortVoiceVlanAuthMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 13, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentPortVoiceVlanAuthMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentPortVoiceVlanAuthMode.setDescription('Describes and Configures the Port Voice VLAN Authentication mode. Disable means authentication not required for voice devices when dot1x is enabled.')
hmAgentProtocolConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 14))
hmAgentProtocolGroupCreate = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 14, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentProtocolGroupCreate.setStatus('current')
if mibBuilder.loadTexts: hmAgentProtocolGroupCreate.setDescription('Set to non-empty string to create a Protocol-Based VLAN group.')
hmAgentProtocolGroupTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 14, 2), )
if mibBuilder.loadTexts: hmAgentProtocolGroupTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentProtocolGroupTable.setDescription("A table of the switch's Protocol-based VLAN entries")
hmAgentProtocolGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 14, 2, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentProtocolGroupId"))
if mibBuilder.loadTexts: hmAgentProtocolGroupEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentProtocolGroupEntry.setDescription("Switch's Protocol-based VLAN entry")
hmAgentProtocolGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 14, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentProtocolGroupId.setStatus('current')
if mibBuilder.loadTexts: hmAgentProtocolGroupId.setDescription('Group identifier of the Protocol-based VLAN entry.')
hmAgentProtocolGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 14, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentProtocolGroupName.setStatus('current')
if mibBuilder.loadTexts: hmAgentProtocolGroupName.setDescription('Group name of the Protocol-based VLAN entry.')
hmAgentProtocolGroupVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 14, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentProtocolGroupVlanId.setStatus('current')
if mibBuilder.loadTexts: hmAgentProtocolGroupVlanId.setDescription('VLAN associated with the Protocol-based VLAN entry. Set to 0 to remove.')
hmAgentProtocolGroupProtocolIP = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 14, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentProtocolGroupProtocolIP.setStatus('current')
if mibBuilder.loadTexts: hmAgentProtocolGroupProtocolIP.setDescription('The status of the IP protocol association with the Protocol-based VLAN entry.')
hmAgentProtocolGroupProtocolARP = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 14, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentProtocolGroupProtocolARP.setStatus('current')
if mibBuilder.loadTexts: hmAgentProtocolGroupProtocolARP.setDescription('The status of the ARP protocol association with the Protocol-based VLAN entry.')
hmAgentProtocolGroupProtocolIPX = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 14, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentProtocolGroupProtocolIPX.setStatus('current')
if mibBuilder.loadTexts: hmAgentProtocolGroupProtocolIPX.setDescription('The status of the IPX protocol association with the Protocol-based VLAN entry.')
hmAgentProtocolGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 14, 2, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentProtocolGroupStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentProtocolGroupStatus.setDescription('The status of the Protocol-based VLAN entry. active(1) - this entry is active destroy(6) - remove this entry')
hmAgentProtocolGroupPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 14, 3), )
if mibBuilder.loadTexts: hmAgentProtocolGroupPortTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentProtocolGroupPortTable.setDescription("A table of the switch's physical port config entries")
hmAgentProtocolGroupPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 14, 3, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentProtocolGroupId"), (0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentProtocolGroupPortIfIndex"))
if mibBuilder.loadTexts: hmAgentProtocolGroupPortEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentProtocolGroupPortEntry.setDescription("Switch's physical port config entry")
hmAgentProtocolGroupPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 14, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentProtocolGroupPortIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentProtocolGroupPortIfIndex.setDescription('The interface number of this instance.')
hmAgentProtocolGroupPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 14, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentProtocolGroupPortStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentProtocolGroupPortStatus.setDescription('The status of this entry. active(1) - the port is associated with this group createAndGo(4) - add the port to this group createAndWait(5) - add the port to this group destroy(6) - remove the port from this group')
hmAgentStpSwitchConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15))
hmAgentStpConfigDigestKey = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpConfigDigestKey.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpConfigDigestKey.setDescription('The MST configuration digest key.')
hmAgentStpConfigFormatSelector = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpConfigFormatSelector.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpConfigFormatSelector.setDescription('The MST configuration format selector. A value other than 0 (zero) indicates non-support for the IEEE 802.1s standard.')
hmAgentStpConfigName = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpConfigName.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpConfigName.setDescription('The MST configuration name of at most 32 characters.')
hmAgentStpConfigRevision = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpConfigRevision.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpConfigRevision.setDescription('The MST configuration revision. The default value is 1.')
hmAgentStpForceVersion = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dot1d", 1), ("dot1w", 2), ("dot1s", 3))).clone('dot1w')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpForceVersion.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpForceVersion.setDescription('The MST configuration force protocol version. The default version is dot1w.')
hmAgentStpAdminMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpAdminMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpAdminMode.setDescription('The spanning tree operational status. enable(1) - enables spanning tree operational status on the switch. disable(2) - disables spanning tree operational status on the switch. The default status is enabled.')
hmAgentStpBpduGuardMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpBpduGuardMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpBpduGuardMode.setDescription('The spanning tree BPDU Guard Mode. enable(1) - enables BPDU Guard Mode on the switch. disable(2) - disables BPDU Guard Mode on the switch. The default status is disabled.')
hmAgentStpBpduFilterDefault = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpBpduFilterDefault.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpBpduFilterDefault.setDescription('The spanning tree BPDU Filter Mode, it enables BPDU Filter on all edge ports. enable(1) - enables BPDU Filter Mode on the switch. disable(2) - disables BPDU Filter Mode on the switch. The default status is disabled.')
hmAgentStpPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 7), )
if mibBuilder.loadTexts: hmAgentStpPortTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpPortTable.setDescription('STP port table.')
hmAgentStpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hmAgentStpPortEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpPortEntry.setDescription('STP port entry.')
hmAgentStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpPortState.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpPortState.setDescription('The administrative STP state for the port. enable(1) - enables STP on the port. disable(2) - disables STP on the port. The default port STP state is enabled for the first 4095 ports and disabled for any ports beyond.')
hmAgentStpPortStatsMstpBpduRx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpPortStatsMstpBpduRx.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpPortStatsMstpBpduRx.setDescription('The MSTP BPDUs received on a specific port.')
hmAgentStpPortStatsMstpBpduTx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpPortStatsMstpBpduTx.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpPortStatsMstpBpduTx.setDescription('The MSTP BPDUs sent from a specific port.')
hmAgentStpPortStatsRstpBpduRx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpPortStatsRstpBpduRx.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpPortStatsRstpBpduRx.setDescription('The RSTP BPDUs received on a specific port.')
hmAgentStpPortStatsRstpBpduTx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpPortStatsRstpBpduTx.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpPortStatsRstpBpduTx.setDescription('The RSTP BPDUs sent from a specific port.')
hmAgentStpPortStatsStpBpduRx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpPortStatsStpBpduRx.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpPortStatsStpBpduRx.setDescription('The STP BPDUs received on a specific port.')
hmAgentStpPortStatsStpBpduTx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpPortStatsStpBpduTx.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpPortStatsStpBpduTx.setDescription('The STP BPDUs sent from a specific port.')
hmAgentStpPortUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 7, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpPortUpTime.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpPortUpTime.setDescription('Time since port was reset. It is displayed in days, hours, minutes, and seconds.')
hmAgentStpPortMigrationCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpPortMigrationCheck.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpPortMigrationCheck.setDescription("Force the specified port to transmit RSTP or MSTP BPDU's. Supported values: false(0) - BPDUs are not to be transmitted. true(1) - BPDUs are to be transmitted A non-zero value indicates that BPDUs are to be sent on the specified port.")
hmAgentStpPortHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 7, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpPortHelloTime.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpPortHelloTime.setDescription('Hello time for the STP port. The default value is 2.')
hmAgentStpCstConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8))
hmAgentStpCstHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstHelloTime.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstHelloTime.setDescription('The MSTP root port hello time for the CIST.')
hmAgentStpCstMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstMaxAge.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstMaxAge.setDescription('The MSTP root port max age for the CIST.')
hmAgentStpCstRegionalRootId = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstRegionalRootId.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstRegionalRootId.setDescription('The MSTP regional root identifier for the CIST.')
hmAgentStpCstRegionalRootPathCost = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstRegionalRootPathCost.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstRegionalRootPathCost.setDescription('The MSTP regional root path cost for the CIST.')
hmAgentStpCstRootFwdDelay = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstRootFwdDelay.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstRootFwdDelay.setDescription('The MSTP root port forward delay for the CIST.')
hmAgentStpCstBridgeFwdDelay = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 30)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstBridgeFwdDelay.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstBridgeFwdDelay.setDescription('The MSTP bridge forward delay for the CIST. The default value is 15.')
hmAgentStpCstBridgeHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstBridgeHelloTime.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstBridgeHelloTime.setDescription('The MSTP bridge hello time for the CIST. The default value is 2.')
hmAgentStpCstBridgeHoldTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstBridgeHoldTime.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstBridgeHoldTime.setDescription('The MSTP bridge hold time for the CIST.')
hmAgentStpCstBridgeMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(6, 40)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstBridgeMaxAge.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstBridgeMaxAge.setDescription('The MSTP bridge max age for the CIST. The default value is 20.')
hmAgentStpCstBridgeDesignatedRoot = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 10), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstBridgeDesignatedRoot.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstBridgeDesignatedRoot.setDescription('The Designated Root like in dot1dStpDesignatedRoot.')
hmAgentStpCstBridgePriority = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 61440)).clone(32768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstBridgePriority.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstBridgePriority.setDescription('The MSTP bridge priority for the CIST. The default value is 32768.')
hmAgentStpCstBridgeTimeSinceTopologyChange = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstBridgeTimeSinceTopologyChange.setReference('IEEE 802.1D-1990: Section 6.8.1.1.3')
if mibBuilder.loadTexts: hmAgentStpCstBridgeTimeSinceTopologyChange.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstBridgeTimeSinceTopologyChange.setDescription('The time (in hundredths of a second) since the last time a topology change was detected by the bridge entity.')
hmAgentStpCstBridgeTopChanges = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstBridgeTopChanges.setReference('IEEE 802.1D-1990: Section 6.8.1.1.3')
if mibBuilder.loadTexts: hmAgentStpCstBridgeTopChanges.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstBridgeTopChanges.setDescription('The total number of topology changes detected by this bridge since the management entity was last reset or initialized.')
hmAgentStpCstBridgeRootCost = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstBridgeRootCost.setReference('IEEE 802.1D-1990: Section 4.5.3.2')
if mibBuilder.loadTexts: hmAgentStpCstBridgeRootCost.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstBridgeRootCost.setDescription('The cost of the path to the root as seen from this bridge.')
hmAgentStpCstBridgeRootPort = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstBridgeRootPort.setReference('IEEE 802.1D-1990: Section 4.5.3.3')
if mibBuilder.loadTexts: hmAgentStpCstBridgeRootPort.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstBridgeRootPort.setDescription('The port number of the port which offers the lowest cost path from this bridge to the root bridge.')
hmAgentStpCstBridgeMaxHops = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(6, 40)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstBridgeMaxHops.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstBridgeMaxHops.setDescription('The MSTP bridge max hops for the CIST. The default value is 20.')
hmAgentStpCstBridgeHoldCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 8, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 40)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstBridgeHoldCount.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstBridgeHoldCount.setDescription('The MSTP bridge hold count for the CIST. This command sets the value of maximum bpdus that a bridge is allowed to send within a hello time window. The default value is 10.')
hmAgentStpCstPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9), )
if mibBuilder.loadTexts: hmAgentStpCstPortTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortTable.setDescription('CIST port table.')
hmAgentStpCstPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hmAgentStpCstPortEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortEntry.setDescription('CIST port entry.')
hmAgentStpCstPortOperEdge = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstPortOperEdge.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortOperEdge.setDescription('The MSTP operational status of a specific port for the CIST.')
hmAgentStpCstPortOperPointToPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstPortOperPointToPoint.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortOperPointToPoint.setDescription('The MSTP operational point to point mac of a specific port for the CIST.')
hmAgentStpCstPortTopologyChangeAck = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstPortTopologyChangeAck.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortTopologyChangeAck.setDescription('The MSTP topology change acknowledge for a specific port in the CIST.')
hmAgentStpCstPortEdge = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstPortEdge.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortEdge.setDescription('The administrative state of a specific port in CIST. true(1) - port is edge port. false(2) - port is auto-edge or no edge port. The default port state is disabled.')
hmAgentStpCstPortForwardingState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("discarding", 1), ("learning", 2), ("forwarding", 3), ("disabled", 4), ("manualFwd", 5), ("notParticipate", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstPortForwardingState.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortForwardingState.setDescription('The MSTP forwarding state of a specific port in CIST.')
hmAgentStpCstPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstPortId.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortId.setDescription('The MSTP port identifier of a specific port in CIST.')
hmAgentStpCstPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstPortPathCost.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortPathCost.setDescription('The MSTP port path cost in CIST. The default value will correspond to the recommendation specified in IEEE 802.1s Table 13-2 which varies depending upon link speed.')
hmAgentStpCstPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 240)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstPortPriority.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortPriority.setDescription('The MSTP port priority in CIST. The priority is in the increments of 16. The default value is 128.')
hmAgentStpCstDesignatedBridgeId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstDesignatedBridgeId.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstDesignatedBridgeId.setDescription('The MSTP designated bridge ID of a specific port in CIST.')
hmAgentStpCstDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstDesignatedCost.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstDesignatedCost.setDescription('The MSTP designated cost of a specific port in CIST.')
hmAgentStpCstDesignatedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstDesignatedPortId.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstDesignatedPortId.setDescription('The MSTP designated port ID of a specific port in CIST.')
hmAgentStpCstExtPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstExtPortPathCost.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstExtPortPathCost.setDescription('The MSTP external port path cost in CIST. The default value varies depending upon the link speed.')
hmAgentStpCstPortAutoEdge = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstPortAutoEdge.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortAutoEdge.setDescription('The auto edge state of a specific port in CIST. true(1) - enables the port. false(2) - disables the port. The default port state is enabled.')
hmAgentStpCstPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("root", 1), ("alternate", 2), ("designated", 3), ("backup", 4), ("master", 5), ("disabled", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstPortRole.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortRole.setDescription('The current Port Role for the Port (i.e., Root, Alternate, Designated, or Backup), for the CIST.')
hmAgentStpCstPortDisputed = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstPortDisputed.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortDisputed.setDescription('The current value of the disputed variable for the CIST for the Port. A value of true(1) indicates that the disputed variable is set. A value of false(2) indicates that the agreed variable is cleared.')
hmAgentStpCstPortBpduGuardEffect = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpCstPortBpduGuardEffect.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortBpduGuardEffect.setDescription('BPDU Guard Mode effect on the port. enable(1) - BPDU Guard Mode is enabled on the port. disable(2) - BPDU Guard Mode is disabled on the port.')
hmAgentStpCstPortBpduFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstPortBpduFilter.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortBpduFilter.setDescription('This command sets BPDU Filter mode on the port. enable(1) - BPDU Filter Mode is enabled on the port. disable(2) - BPDU Filter Mode is disabled on the port.')
hmAgentStpCstPortBpduFlood = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstPortBpduFlood.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortBpduFlood.setDescription('This command sets BPDU Flood mode on the port. enable(1) - BPDU Flood Mode is enabled on the port. disable(2) - BPDU Flood Mode is disabled on the port.')
hmAgentStpCstPortRootGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstPortRootGuard.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortRootGuard.setDescription('This command sets a port to discard any superior information received by the port and thus protect against root of the device from changing.The port gets put into discarding state and does not forward any packets. enable(1) - enables the root-guard mode for the port. disable(2) - disables the root-guard mode for the port. The default root-guard mode is disabled.')
hmAgentStpCstPortTCNGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstPortTCNGuard.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortTCNGuard.setDescription('This command restricts the port from propagating any topology change information received through that port. enable(1) - enables the tcn-guard mode for the port. disable(2) - disables the tcn-guard mode for the port. The default tcn-guard mode is disabled.')
hmAgentStpCstPortLoopGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 9, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpCstPortLoopGuard.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpCstPortLoopGuard.setDescription('This command enables loop guard on this port. This setting applies to all Spanning Tree instances of which this port is a member. enable(1) - enables the loop guard mode for the port. disable(2) - disables the loop guard mode for the port. The default loop-guard mode is disabled.')
hmAgentStpMstTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 10), )
if mibBuilder.loadTexts: hmAgentStpMstTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstTable.setDescription('MST table.')
hmAgentStpMstEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 10, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentStpMstId"))
if mibBuilder.loadTexts: hmAgentStpMstEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstEntry.setDescription('MST entry.')
hmAgentStpMstId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 10, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstId.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstId.setDescription('The MSTP instance ID.')
hmAgentStpMstBridgePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 61440)).clone(32768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpMstBridgePriority.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstBridgePriority.setDescription('The MSTP bridge priority in a specific instance. The priority is in the increments of 4096. The recommended default value is 32768.')
hmAgentStpMstBridgeIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstBridgeIdentifier.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstBridgeIdentifier.setDescription('The MSTP bridge identifier in a specific instance.')
hmAgentStpMstDesignatedRootId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstDesignatedRootId.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstDesignatedRootId.setDescription('The MSTP designated root bridge identifier in a specific instance.')
hmAgentStpMstRootPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 10, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstRootPathCost.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstRootPathCost.setDescription('The MSTP root path cost in a specific instance.')
hmAgentStpMstRootPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 10, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstRootPortId.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstRootPortId.setDescription('The MSTP root port ID in a specific instance.')
hmAgentStpMstTimeSinceTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 10, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstTimeSinceTopologyChange.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstTimeSinceTopologyChange.setDescription('The MSTP time since the last topology change in a specific instance.')
hmAgentStpMstTopologyChangeCount = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstTopologyChangeCount.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstTopologyChangeCount.setDescription('The MSTP count of topology changes in a specific instance.')
hmAgentStpMstTopologyChangeParm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstTopologyChangeParm.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstTopologyChangeParm.setDescription('The MSTP topology change parameter in a specific instance.')
hmAgentStpMstRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 10, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentStpMstRowStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstRowStatus.setDescription('The MSTP instance status. Supported values: active(1) - valid instance. createAndGo(4) - used to create a new instance. destroy(6) - removes an instance.')
hmAgentStpMstPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11), )
if mibBuilder.loadTexts: hmAgentStpMstPortTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstPortTable.setDescription('MST port table.')
hmAgentStpMstPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentStpMstId"), (0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hmAgentStpMstPortEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstPortEntry.setDescription('MST port entry.')
hmAgentStpMstPortForwardingState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("discarding", 1), ("learning", 2), ("forwarding", 3), ("disabled", 4), ("manualFwd", 5), ("notParticipate", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstPortForwardingState.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstPortForwardingState.setDescription('The MSTP forwarding state of a specific port in a specific instance.')
hmAgentStpMstPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstPortId.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstPortId.setDescription('The MSTP port identifier of a specific port in a specific instance.')
hmAgentStpMstPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpMstPortPathCost.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstPortPathCost.setDescription('The MSTP port path cost in a specific instance. The default value will correspond to the recommendation specified in IEEE 802.1s Table 13-2 which varies depending upon link speed.')
hmAgentStpMstPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 240)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentStpMstPortPriority.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstPortPriority.setDescription('The MSTP port priority in a specific instance. The priority is in the increments of 16. The default value is 128.')
hmAgentStpMstDesignatedBridgeId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstDesignatedBridgeId.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstDesignatedBridgeId.setDescription('The MSTP designated bridge ID of a specific port in a specific instance.')
hmAgentStpMstDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstDesignatedCost.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstDesignatedCost.setDescription('The MSTP designated cost of a specific port in a specific instance.')
hmAgentStpMstDesignatedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstDesignatedPortId.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstDesignatedPortId.setDescription('The MSTP designated port ID of a specific port in a specific instance.')
hmAgentStpMstPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("root", 1), ("alternate", 2), ("designated", 3), ("backup", 4), ("master", 5), ("disabled", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstPortRole.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstPortRole.setDescription('In an MSTP Bridge, the current Port Role for the Port (i.e., Root, Alternate, Designated, or Backup), for the MSTI.')
hmAgentStpMstPortDisputed = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstPortDisputed.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstPortDisputed.setDescription('In an MSTP Bridge, the current value of the disputed variable for the MSTI for the Port.')
hmAgentStpMstPortLoopInconsistentState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstPortLoopInconsistentState.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstPortLoopInconsistentState.setDescription('The loop inconsistent state of a specific port in a specific instance. This value can only report as true(1) when loop guard is enabled on the port and the port has transitioned from blocking state in this MST instance.')
hmAgentStpMstPortTransitionsIntoLoopInconsistentState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstPortTransitionsIntoLoopInconsistentState.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstPortTransitionsIntoLoopInconsistentState.setDescription('The number of times this interface has transitioned into loop inconsistent state.')
hmAgentStpMstPortTransitionsOutOfLoopInconsistentState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstPortTransitionsOutOfLoopInconsistentState.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstPortTransitionsOutOfLoopInconsistentState.setDescription('The number of times this interface has transitioned out of loop inconsistent state.')
hmAgentStpMstReceivedBridgeId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstReceivedBridgeId.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstReceivedBridgeId.setDescription('The MSTP received bridge ID on a specific port in a specific instance.')
hmAgentStpMstReceivedRPC = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstReceivedRPC.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstReceivedRPC.setDescription('The MSTP received root path cost of a specific port in a specific instance.')
hmAgentStpMstReceivedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 11, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentStpMstReceivedPortId.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstReceivedPortId.setDescription('The MSTP received port ID on a specific port in a specific instance.')
hmAgentStpMstVlanTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 12), )
if mibBuilder.loadTexts: hmAgentStpMstVlanTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstVlanTable.setDescription('MST VLAN table.')
hmAgentStpMstVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 12, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentStpMstId"), (0, "Q-BRIDGE-MIB", "dot1qVlanIndex"))
if mibBuilder.loadTexts: hmAgentStpMstVlanEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstVlanEntry.setDescription('MST VLAN entry.')
hmAgentStpMstVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 15, 12, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentStpMstVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentStpMstVlanRowStatus.setDescription('The association status of an MSTP instance and a VLAN. Supported values: active(1) - valid association between an MSTP instance and a VLAN. createAndGo(4) - used to create a new association between an MSTP instance and a VLAN. destroy(6) - removes the association between an MSTP instance and a VLAN.')
hmAgentClassOfServiceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 17))
hmAgentClassOfServicePortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 17, 1), )
if mibBuilder.loadTexts: hmAgentClassOfServicePortTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentClassOfServicePortTable.setDescription('A table that contains information about the 802.1p priority mapping to traffic class priority queue for every physical port.')
hmAgentClassOfServicePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 17, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentClassOfServicePortPriority"))
if mibBuilder.loadTexts: hmAgentClassOfServicePortEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentClassOfServicePortEntry.setDescription('A 802.1p priority mapped to a traffic class priority queue.')
hmAgentClassOfServicePortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 17, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: hmAgentClassOfServicePortPriority.setStatus('current')
if mibBuilder.loadTexts: hmAgentClassOfServicePortPriority.setDescription('The Priority value determined for the received frame. This value is equivalent to the priority indicated in the tagged frame received, or one of the evaluated priorities, determined according to the media-type. For untagged frames received from Ethernet media, this value is equal to the dot1dPortDefaultUserPriority value for the ingress port.')
hmAgentClassOfServicePortClass = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 17, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentClassOfServicePortClass.setStatus('current')
if mibBuilder.loadTexts: hmAgentClassOfServicePortClass.setDescription('Traffic class priority queue the received frame is mapped to. The possible range depends on the number of supported traffic classes for the appropriate port, as shown in dot1dPortNumTrafficClasses.')
hmAgentSystemGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 3))
hmAgentSaveConfig = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSaveConfig.setStatus('current')
if mibBuilder.loadTexts: hmAgentSaveConfig.setDescription('Enable hmAgentSaveConfig will initiate an configuration save to nvram. Disable hmAgentSaveConfig after a configuration save will reset hmAgentSaveConfigStatus back to notInitiated state.')
hmAgentClearConfig = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentClearConfig.setStatus('current')
if mibBuilder.loadTexts: hmAgentClearConfig.setDescription('clear config to factory defaults')
hmAgentClearLags = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentClearLags.setStatus('current')
if mibBuilder.loadTexts: hmAgentClearLags.setDescription('clear lag configuration')
hmAgentClearLoginSessions = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentClearLoginSessions.setStatus('current')
if mibBuilder.loadTexts: hmAgentClearLoginSessions.setDescription('close all telnet sessions')
hmAgentClearPasswords = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentClearPasswords.setStatus('current')
if mibBuilder.loadTexts: hmAgentClearPasswords.setDescription('reset passwords')
hmAgentClearPortStats = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentClearPortStats.setStatus('current')
if mibBuilder.loadTexts: hmAgentClearPortStats.setDescription('clear all port statistics')
hmAgentClearSwitchStats = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentClearSwitchStats.setStatus('current')
if mibBuilder.loadTexts: hmAgentClearSwitchStats.setDescription('clear all switch statistics')
hmAgentClearTrapLog = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentClearTrapLog.setStatus('current')
if mibBuilder.loadTexts: hmAgentClearTrapLog.setDescription('clear trap log')
hmAgentClearVlan = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentClearVlan.setStatus('current')
if mibBuilder.loadTexts: hmAgentClearVlan.setDescription('clear vlan entries')
hmAgentResetSystem = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentResetSystem.setStatus('current')
if mibBuilder.loadTexts: hmAgentResetSystem.setDescription('reset the switch')
hmAgentSaveConfigStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notInitiated", 1), ("savingInProcess", 2), ("savingComplete", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSaveConfigStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentSaveConfigStatus.setDescription('Indicates the current status of an save configuration request.')
hmAgentCableTesterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 4))
hmAgentCableTesterStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("success", 2), ("failure", 3), ("uninitialized", 4))).clone('uninitialized')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentCableTesterStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentCableTesterStatus.setDescription('Status of the Virtual Cable Tester active(1) - cable testing is in progress. Set to this value to start the test. success(2) - A successful test was performed. Cannot be set. failure(3) - A failure was encountered during the test. Cannot be set. uninitialized(4) - No test has been performed yet. Cannot be set.')
hmAgentCableTesterIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 4, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentCableTesterIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentCableTesterIfIndex.setDescription('Determines on which port to perform the cable test. Limited to copper based ports.')
hmAgentCableTesterCableStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal", 1), ("open", 2), ("short", 3), ("unknown", 4))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentCableTesterCableStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentCableTesterCableStatus.setDescription('Indicates the results of the Cable Test. normal(1) - The cable is working correctly. open(2) - The cable is disconnected or there is a faulty connector. short(3) - There is an electrical short in the cable. unknown(4) - No test has been performed yet, or a test is currently in progress.')
hmAgentCableTesterMinimumCableLength = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 4, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentCableTesterMinimumCableLength.setStatus('current')
if mibBuilder.loadTexts: hmAgentCableTesterMinimumCableLength.setDescription('The estimated length of the cable in meters. This value indicates the shortest length estimated. This object will return 0 if hmAgentCableTesterStatus is not success(2) or the cable length is unknown.')
hmAgentCableTesterMaximumCableLength = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 4, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentCableTesterMaximumCableLength.setStatus('current')
if mibBuilder.loadTexts: hmAgentCableTesterMaximumCableLength.setDescription('The estimated length of the cable in meters. This value indicates the longest length estimated. This object will return 0 if hmAgentCableTesterStatus is not success(2) or the cable length is unknown.')
hmAgentCableTesterCableFailureLocation = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 4, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentCableTesterCableFailureLocation.setStatus('current')
if mibBuilder.loadTexts: hmAgentCableTesterCableFailureLocation.setDescription('The estimated distance in meters from the end of the cable to the failure location. This object will return 0 if hmAgentCableTesterStatus is not success(2).')
hmAgentMgmtSecurity = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 11))
hmAgentSSHConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 11, 2))
hmAgentSSHAdminMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 11, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSSHAdminMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentSSHAdminMode.setDescription('Configures whether the SSH service is enabled on this switch. The default value is disable(2).')
hmAgentSSHProtocolLevel = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 11, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ssh10", 1), ("ssh20", 2), ("both", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSSHProtocolLevel.setStatus('current')
if mibBuilder.loadTexts: hmAgentSSHProtocolLevel.setDescription('Configures which protocol versions of SSH are enabled on this switch. The default value is both(3).')
hmAgentSSHSessionsCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 11, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSSHSessionsCount.setStatus('current')
if mibBuilder.loadTexts: hmAgentSSHSessionsCount.setDescription('Current number of active SSH sessions on this switch.')
hmAgentSSHMaxSessionsCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 11, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSSHMaxSessionsCount.setStatus('current')
if mibBuilder.loadTexts: hmAgentSSHMaxSessionsCount.setDescription('Max number of SSH sessions permitted on this switch.')
hmAgentSSHSessionTimeout = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 11, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 160))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSSHSessionTimeout.setStatus('current')
if mibBuilder.loadTexts: hmAgentSSHSessionTimeout.setDescription('ssh idle timeout value for this switch im minutes.')
hmRadius = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 8))
hmAgentRadiusConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 8, 1))
hmAgentRadiusMaxTransmit = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRadiusMaxTransmit.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusMaxTransmit.setDescription('Maximum number of retransmissions of a RADIUS request packet')
hmAgentRadiusTimeout = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRadiusTimeout.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusTimeout.setDescription('Time out duration (in seconds) before packets are retransmitted')
hmAgentRadiusAccountingMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRadiusAccountingMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusAccountingMode.setDescription('Identifies if RADIUS Accounting has been enabled or not')
hmAgentRadiusStatsClear = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRadiusStatsClear.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusStatsClear.setDescription('When set to enable(1), all Radius statistics will be reset.')
hmAgentRadiusAccountingIndexNextValid = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentRadiusAccountingIndexNextValid.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusAccountingIndexNextValid.setDescription('Indicates the next valid index into the hmAgentRadiusAccountingConfigTable for creation. If no additional entries are allowed, this will be 0.')
hmAgentRadiusAccountingConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 6), )
if mibBuilder.loadTexts: hmAgentRadiusAccountingConfigTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusAccountingConfigTable.setDescription('Table with information about Radius Accounting Server IP Addresses, port numbers and shared secret. Only one entry is supported at this time.')
hmAgentRadiusAccountingConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 6, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentRadiusAccountingServerIndex"))
if mibBuilder.loadTexts: hmAgentRadiusAccountingConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusAccountingConfigEntry.setDescription('Entry consisting of configuration data for a Radius Accounting Server.')
hmAgentRadiusAccountingServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hmAgentRadiusAccountingServerIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusAccountingServerIndex.setDescription('Unique index of the configured RADIUS accounting server. The next valid value of this object for creation is specified by hmAgentRadiusAccountingIndexNextValid. ')
hmAgentRadiusAccountingServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 6, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentRadiusAccountingServerAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusAccountingServerAddress.setDescription('IP Address of the configured RADIUS accounting server. This object cannot be changed after creation.')
hmAgentRadiusAccountingPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 6, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1813)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRadiusAccountingPort.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusAccountingPort.setDescription('Port number for the RADIUS accounting server.')
hmAgentRadiusAccountingSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 6, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRadiusAccountingSecret.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusAccountingSecret.setDescription('Configured shared sercret for the RADIUS accounting server.')
hmAgentRadiusAccountingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 6, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentRadiusAccountingStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusAccountingStatus.setDescription('Creates or destroys a RADIUS accounting server entry. During creation, the next available index is specified by the hmAgentRadiusAccountingIndexNextValid object. Rows creation using a different value for hmAgentRadiusAccountingServerIndex will fail. active(1) - This entry is active. createAndGo(4) - Creates a new entry. destroy(6) - Deletes an entry.')
hmAgentRadiusServerIndexNextValid = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentRadiusServerIndexNextValid.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusServerIndexNextValid.setDescription('Indicates the next valid index into the hmAgentRadiusServerConfigTable for creation. If no additional entries are allowed, this will be 0.')
hmAgentRadiusServerConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 8), )
if mibBuilder.loadTexts: hmAgentRadiusServerConfigTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusServerConfigTable.setDescription('Table with information about Radius Authentication Server IP Addresses, port numbers and shared secret')
hmAgentRadiusServerConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 8, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentRadiusServerIndex"))
if mibBuilder.loadTexts: hmAgentRadiusServerConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusServerConfigEntry.setDescription('Entry consisting of configuration data for a Radius Authentication Server.')
hmAgentRadiusServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hmAgentRadiusServerIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusServerIndex.setDescription('Unique index of the configured RADIUS server')
hmAgentRadiusServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 8, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentRadiusServerAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusServerAddress.setDescription('IP Address of the configured RADIUS server. This object cannot be changed after creation.')
hmAgentRadiusServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 8, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1812)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRadiusServerPort.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusServerPort.setDescription('Port number for the RADIUS server.')
hmAgentRadiusServerSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 8, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRadiusServerSecret.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusServerSecret.setDescription('Configured shared sercret for the RADIUS server.')
hmAgentRadiusServerPrimaryMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRadiusServerPrimaryMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusServerPrimaryMode.setDescription('Configure the RADIUS server to be the primary server. If there is any other server that is configured to be primary, that server is set to be a seconday server and this entry is set Primary.')
hmAgentRadiusServerCurrentMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 8, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentRadiusServerCurrentMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusServerCurrentMode.setDescription('Indicate if the RADIUS server is the current server in user for authentication.')
hmAgentRadiusServerMsgAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRadiusServerMsgAuth.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusServerMsgAuth.setDescription('Enable or disable the message authenticator attribute for this RADIUS server.')
hmAgentRadiusServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 8, 1, 8, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentRadiusServerStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentRadiusServerStatus.setDescription('Creates or destroys a RADIUS Authentication server entry. During creation, the next available index is specified by the hmAgentRadiusServerIndexNextValid object. Rows creation using a different value for hmAgentRadiusServerIndex will fail. active(1) - This entry is active. createAndGo(4) - Creates a new entry. destroy(6) - Deletes an entry.')
hmPlatform4OutboundTelnetPrivate = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 19))
hmAgentOutboundTelnetGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 19, 1))
hmAgentOutboundTelnetAdminMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 19, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOutboundTelnetAdminMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentOutboundTelnetAdminMode.setDescription(' Admin-mode of the Outbound Telnet.')
hmAgentOutboundTelnetMaxNoOfSessions = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 19, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOutboundTelnetMaxNoOfSessions.setStatus('current')
if mibBuilder.loadTexts: hmAgentOutboundTelnetMaxNoOfSessions.setDescription(' The maximum no. of Outbound Telnet sessions allowed.')
hmAgentOutboundTelnetTimeout = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 19, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 160))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOutboundTelnetTimeout.setStatus('current')
if mibBuilder.loadTexts: hmAgentOutboundTelnetTimeout.setDescription(' The login inactivity timeout value for Outbound Telnet.')
hmAgentSwitchVoiceVLANGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 25))
hmAgentSwitchVoiceVLANAdminMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 25, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchVoiceVLANAdminMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchVoiceVLANAdminMode.setDescription('This enables or disables Voice VLAN on the system.')
hmAgentSwitchVoiceVlanDeviceTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 25, 2), )
if mibBuilder.loadTexts: hmAgentSwitchVoiceVlanDeviceTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchVoiceVlanDeviceTable.setDescription('A table of the Voice Vlan device entries.')
hmAgentSwitchVoiceVlanDeviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 25, 2, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentSwitchVoiceVlanInterfaceNum"), (0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentSwitchVoiceVlanDeviceMacAddress"))
if mibBuilder.loadTexts: hmAgentSwitchVoiceVlanDeviceEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchVoiceVlanDeviceEntry.setDescription('Represents entry for a Voice Device on the interface.')
hmAgentSwitchVoiceVlanInterfaceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 25, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchVoiceVlanInterfaceNum.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchVoiceVlanInterfaceNum.setDescription('The interface number of this interface.')
hmAgentSwitchVoiceVlanDeviceMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 1, 2, 8, 25, 2, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchVoiceVlanDeviceMacAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchVoiceVlanDeviceMacAddress.setDescription('The Voice Device Mac address')
hmAgentDot1xAdvanced = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 36))
hmAgentDot1xEnhancementConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 36, 1))
hmAgentDot1xRadiusVlanAssignment = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 36, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentDot1xRadiusVlanAssignment.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xRadiusVlanAssignment.setDescription('Enable/Disable dot1x Vlan Assignment Support on the switch.')
hmAgentDot1xDynamicVlanCreationMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 36, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentDot1xDynamicVlanCreationMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xDynamicVlanCreationMode.setDescription('Enable/Disable dot1x dynamic vlan creation Support on the switch.')
hmAgentDot1xSafeVlanMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 36, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentDot1xSafeVlanMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xSafeVlanMode.setDescription('Enable/Disable dot1x safe vlan assignment on the switch for multi-client authentication.')
hmAgentDot1xPortConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 36, 2))
hmAgentDot1xPortConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 36, 2, 1), )
if mibBuilder.loadTexts: hmAgentDot1xPortConfigTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xPortConfigTable.setDescription('A table for dot1x enhanced Port details and associated functionality.')
hmAgentDot1xPortConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 36, 2, 1, 1), ).setIndexNames((0, "IEEE8021-PAE-MIB", "dot1xPaePortNumber"))
if mibBuilder.loadTexts: hmAgentDot1xPortConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xPortConfigEntry.setDescription('Represents entry for port config table.')
hmAgentDot1xPortControlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 2, 1, 1, 1), HmAgentDot1xPortControlMode().clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentDot1xPortControlMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xPortControlMode.setDescription('Dot1x port control mode of this port.The Port control mode . The port control mode for this interface can take the following values , force-unauthorized - the port is in unauthorized mode, auto-Port based mode. If a client authenticates suscessfully, then the interface is authorized . Otherwise, the port is in unauthorized mode. If more than one clients are attached to the port , then only one client needs to authenticate to allow other clients access. force-authorized - The port is placed in authorized mode macBased - If more than one client is attached to the port, then each client needs to authenticate separately. This object depcreates dot1xAuthAuthControlledPortControl object in IEEE8021-PAE-MIB')
hmAgentDot1xGuestVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 2, 1, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentDot1xGuestVlanId.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xGuestVlanId.setDescription('Specifies the Guest Vlan of the port. A port will be moved to its Guest Vlan if no client sucessfully authenticates on that port for the Guest Vlan Period. A value of zero indicates no Guest Vlan is configured for the interface.')
hmAgentDot1xGuestVlanPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 2, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(90)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentDot1xGuestVlanPeriod.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xGuestVlanPeriod.setDescription('The value, in seconds, of the guestVlanPeriod constant currently in use for Guest Vlan Assignment for the port .')
hmAgentDot1xUnauthenticatedVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 2, 1, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentDot1xUnauthenticatedVlan.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xUnauthenticatedVlan.setDescription('Specifies the Unauthenticated Vlan of the port. A port will be moved to its unauthenticated Vlan if the client authenticates unsucessfully on that port . A value of zero indicates no Unauthenticated Vlan is configured for the port. ')
hmAgentDot1xMaxUsers = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 2, 1, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentDot1xMaxUsers.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xMaxUsers.setDescription(' Specifies the maximum users or clients that can authenticate on this port when the port control mode is macBased. ')
hmAgentDot1xPortVlanAssigned = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 2, 1, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xPortVlanAssigned.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xPortVlanAssigned.setDescription(' Specifies the vlan the port is assigned to by Dot1x . Only relevant if the port control mode of the port is auto. ')
hmAgentDot1xPortVlanAssignedReason = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7))).clone(namedValues=NamedValues(("default", 1), ("radius", 2), ("unauthenticatedVlan", 3), ("guestVlan", 4), ("voiceVlan", 5), ("notAssigned", 7))).clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xPortVlanAssignedReason.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xPortVlanAssignedReason.setDescription(' Reason the port is assigned to the vlan specified by hmAgentDot1xPortVlanAssigned . Only relevant if the port control mode of the port is auto. ')
hmAgentDot1xPortSessionTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 2, 1, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xPortSessionTimeout.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xPortSessionTimeout.setDescription(' Specifies the session timeout value assigned by the Radius server for this port . Only relevant if the port control mode of the port is auto. ')
hmAgentDot1xPortTerminationAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 2, 1, 1, 9), HmAgentDot1xSessionTerminationAction().clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xPortTerminationAction.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xPortTerminationAction.setDescription(' Specifies the session termination action assigned by the Radius Server .This is the action taken when the session times out . Only relevant if the port control mode of the port is auto. ')
hmAgentDot1xPortMABenabled = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentDot1xPortMABenabled.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xPortMABenabled.setDescription(' Specifies if Mac-based bypass authentication is configured for the port. ')
hmAgentDot1xPortMABenabledOperational = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xPortMABenabledOperational.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xPortMABenabledOperational.setDescription(' Displays the operational value of the Mac-based authentication bypass mode (MAB) on the port. ')
hmAgentDot1xClientConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 36, 3))
hmAgentDot1xClientConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 36, 3, 1), )
if mibBuilder.loadTexts: hmAgentDot1xClientConfigTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xClientConfigTable.setDescription('A table for dot1x Client details and associated functionality.')
hmAgentDot1xClientConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 36, 3, 1, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentDot1xClientMacAddress"))
if mibBuilder.loadTexts: hmAgentDot1xClientConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xClientConfigEntry.setDescription('Represents entry for port config table.')
hmAgentDot1xClientMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 3, 1, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xClientMacAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xClientMacAddress.setDescription('Specifies the client MAC address of the client. ')
hmAgentDot1xLogicalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 3, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xLogicalPort.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xLogicalPort.setDescription('Specifies the client MAC address of the client . ')
hmAgentDot1xInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 3, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xInterface.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xInterface.setDescription('Specifies the physical interface to which the client is attached . ')
hmAgentDot1xClientAuthPAEstate = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("initialize", 1), ("disconnected", 2), ("connecting", 3), ("authenticating", 4), ("authenticated", 5), ("aborting", 6), ("held", 7), ("forceAuth", 8), ("forceUnauth", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xClientAuthPAEstate.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xClientAuthPAEstate.setDescription('The current value of the Authenticator PAE state machine for the client.')
hmAgentDot1xClientBackendState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("request", 1), ("response", 2), ("success", 3), ("fail", 4), ("timeout", 5), ("idle", 6), ("initialize", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xClientBackendState.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xClientBackendState.setDescription('The current state of the Backend Authentication state machine.')
hmAgentDot1xClientUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 3, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xClientUserName.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xClientUserName.setDescription('Specifies the username with which the client is authenticated to the Radius server . This value is only valid when the client is in authenticated state. ')
hmAgentDot1xClientSessionTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 3, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xClientSessionTime.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xClientSessionTime.setDescription('Specifies the time elapsed in seconds since the client was authenticated in this session. This value is only valid when the client is in authenticated state. ')
hmAgentDot1xClientFilterID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 3, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xClientFilterID.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xClientFilterID.setDescription('Specifies the Filter ID or Diffserv Policy name to be applied to the session . This vlaue is populated only if it has been assigned by the RADIUS server. This value is only valid when the client is in authenticated state.')
hmAgentDot1xClientVlanAssigned = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 3, 1, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xClientVlanAssigned.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xClientVlanAssigned.setDescription('Specifies the vlan the client is associated with by Dot1x . This value is only valid when the client is in authenticated state.')
hmAgentDot1xClientVlanAssignedReason = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7))).clone(namedValues=NamedValues(("default", 1), ("radius", 2), ("unauthenticatedVlan", 3), ("guestVlan", 4), ("voiceVlan", 5), ("invalid", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xClientVlanAssignedReason.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xClientVlanAssignedReason.setDescription(' Reason the client is associated to the vlan specified by hmAgentDot1xClientVlanAssigned . This value is only valid when the client is in authenticated state.')
hmAgentDot1xClientSessionTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 3, 1, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xClientSessionTimeout.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xClientSessionTimeout.setDescription('Specifies the session time remaining for the client if assigned by the Radius server . A value of 0 indicates that no session timeout was assigned by the RADIUS server. This value is only valid when the client is in authenticated state. ')
hmAgentDot1xClientTerminationAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 36, 3, 1, 1, 12), HmAgentDot1xSessionTerminationAction()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentDot1xClientTerminationAction.setStatus('current')
if mibBuilder.loadTexts: hmAgentDot1xClientTerminationAction.setDescription('Specifies the session termination action assigned by the Radius Server . This is the action taken when the session times out . This value is only valid when the client is in authenticated state. ')
hmPlatform4SwitchingTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 1, 50))
multipleUsersTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 1, 50, 1))
if mibBuilder.loadTexts: multipleUsersTrap.setStatus('current')
if mibBuilder.loadTexts: multipleUsersTrap.setDescription('This trap is sent when more than one user is logged in with administrative access. Only applies to CLI interface.')
broadcastStormStartTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 1, 50, 2))
if mibBuilder.loadTexts: broadcastStormStartTrap.setStatus('obsolete')
if mibBuilder.loadTexts: broadcastStormStartTrap.setDescription('Trap is obsolete.')
broadcastStormEndTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 1, 50, 3))
if mibBuilder.loadTexts: broadcastStormEndTrap.setStatus('obsolete')
if mibBuilder.loadTexts: broadcastStormEndTrap.setDescription('Trap is obsolete.')
linkFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 1, 50, 4))
if mibBuilder.loadTexts: linkFailureTrap.setStatus('obsolete')
if mibBuilder.loadTexts: linkFailureTrap.setDescription('Trap is obsolete.')
vlanRequestFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 1, 50, 5)).setObjects(("Q-BRIDGE-MIB", "dot1qVlanIndex"))
if mibBuilder.loadTexts: vlanRequestFailureTrap.setStatus('obsolete')
if mibBuilder.loadTexts: vlanRequestFailureTrap.setDescription('Trap is obsolete.')
vlanDeleteLastTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 1, 50, 6)).setObjects(("Q-BRIDGE-MIB", "dot1qVlanIndex"))
if mibBuilder.loadTexts: vlanDeleteLastTrap.setStatus('current')
if mibBuilder.loadTexts: vlanDeleteLastTrap.setDescription('Trap is sent when attempting to delete the last configured VLAN or the Default VLAN.')
vlanDefaultCfgFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 1, 50, 7)).setObjects(("Q-BRIDGE-MIB", "dot1qVlanIndex"))
if mibBuilder.loadTexts: vlanDefaultCfgFailureTrap.setStatus('current')
if mibBuilder.loadTexts: vlanDefaultCfgFailureTrap.setDescription('Trap is sent if there are failures in resetting VLAN configuration to defaults.')
vlanRestoreFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 1, 50, 8)).setObjects(("Q-BRIDGE-MIB", "dot1qVlanIndex"))
if mibBuilder.loadTexts: vlanRestoreFailureTrap.setStatus('obsolete')
if mibBuilder.loadTexts: vlanRestoreFailureTrap.setDescription('Trap is obsolete.')
fanFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 1, 50, 9))
if mibBuilder.loadTexts: fanFailureTrap.setStatus('obsolete')
if mibBuilder.loadTexts: fanFailureTrap.setDescription('Trap is obsolete.')
stpInstanceNewRootTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 1, 50, 10)).setObjects(("HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentStpMstId"))
if mibBuilder.loadTexts: stpInstanceNewRootTrap.setStatus('current')
if mibBuilder.loadTexts: stpInstanceNewRootTrap.setDescription('Trap is sent when this machine is a new STP Root when there is more than one STP instance.')
stpInstanceTopologyChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 1, 50, 11)).setObjects(("HIRSCHMANN-MMP4-BASICL2-MIB", "hmAgentStpMstId"))
if mibBuilder.loadTexts: stpInstanceTopologyChangeTrap.setStatus('current')
if mibBuilder.loadTexts: stpInstanceTopologyChangeTrap.setDescription('Trap is sent when there is a STP topology change when there is more than one STP instance.')
powerSupplyStatusChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 1, 50, 12))
if mibBuilder.loadTexts: powerSupplyStatusChangeTrap.setStatus('obsolete')
if mibBuilder.loadTexts: powerSupplyStatusChangeTrap.setDescription('Trap is obsolete.')
failedUserLoginTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 1, 50, 13))
if mibBuilder.loadTexts: failedUserLoginTrap.setStatus('current')
if mibBuilder.loadTexts: failedUserLoginTrap.setDescription('Trap is sent when a user fails to authenticate via the CLI or Web interfaces.')
dot1xTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 36, 4))
dot1xPortStatusAuthorized = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 36, 4, 1)).setObjects(("IEEE8021-PAE-MIB", "dot1xPaePortNumber"))
if mibBuilder.loadTexts: dot1xPortStatusAuthorized.setStatus('current')
if mibBuilder.loadTexts: dot1xPortStatusAuthorized.setDescription('DOT1X port status is authorized.')
dot1xPortStatusUnauthorized = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 36, 4, 2)).setObjects(("IEEE8021-PAE-MIB", "dot1xPaePortNumber"))
if mibBuilder.loadTexts: dot1xPortStatusUnauthorized.setStatus('current')
if mibBuilder.loadTexts: dot1xPortStatusUnauthorized.setDescription('DOT1X port status is unauthorized.')
mibBuilder.exportSymbols("HIRSCHMANN-MMP4-BASICL2-MIB", hmAgentPortConfigTable=hmAgentPortConfigTable, hmAgentRadiusServerPort=hmAgentRadiusServerPort, hmAgentProtocolGroupProtocolIP=hmAgentProtocolGroupProtocolIP, hmAgentDot1xPortConfigTable=hmAgentDot1xPortConfigTable, hmAgentDot1xClientTerminationAction=hmAgentDot1xClientTerminationAction, hmAgentProbePortIfIndex=hmAgentProbePortIfIndex, stpInstanceTopologyChangeTrap=stpInstanceTopologyChangeTrap, hmAgentStpCstExtPortPathCost=hmAgentStpCstExtPortPathCost, hmAgentLoginSessionIdleTime=hmAgentLoginSessionIdleTime, vlanRequestFailureTrap=vlanRequestFailureTrap, hmAgentStpCstPortAutoEdge=hmAgentStpCstPortAutoEdge, hmAgentLagSummaryConfigTable=hmAgentLagSummaryConfigTable, hmAgentPortDot3FlowControlMode=hmAgentPortDot3FlowControlMode, hmAgentStpMstVlanEntry=hmAgentStpMstVlanEntry, broadcastStormEndTrap=broadcastStormEndTrap, hmAgentLagSummaryName=hmAgentLagSummaryName, hmAgentStpCstDesignatedPortId=hmAgentStpCstDesignatedPortId, PYSNMP_MODULE_ID=hmPlatform4BasicL2, hmAgentDot1xPortMABenabled=hmAgentDot1xPortMABenabled, hmAgentDot3adAggPortTable=hmAgentDot3adAggPortTable, hmAgentTrapLogGroup=hmAgentTrapLogGroup, hmAgentProtocolGroupEntry=hmAgentProtocolGroupEntry, hmAgentDot1xClientFilterID=hmAgentDot1xClientFilterID, hmAgentUserName=hmAgentUserName, hmAgentTransferDownloadFilename=hmAgentTransferDownloadFilename, hmAgentUserAccessMode=hmAgentUserAccessMode, hmAgentStpCstPortTCNGuard=hmAgentStpCstPortTCNGuard, hmAgentClassOfServicePortPriority=hmAgentClassOfServicePortPriority, hmAgentSwitchMFDBSummaryMacAddress=hmAgentSwitchMFDBSummaryMacAddress, hmAgentSwitchDVlanTagEthertype=hmAgentSwitchDVlanTagEthertype, hmAgentStpCstHelloTime=hmAgentStpCstHelloTime, hmAgentSwitchMFDBGroup=hmAgentSwitchMFDBGroup, hmAgentDot1xClientConfigEntry=hmAgentDot1xClientConfigEntry, hmAgentProtocolGroupProtocolARP=hmAgentProtocolGroupProtocolARP, hmAgentSSHProtocolLevel=hmAgentSSHProtocolLevel, hmAgentLoginSessionIPAddress=hmAgentLoginSessionIPAddress, hmAgentClearPortStats=hmAgentClearPortStats, hmAgentConfigGroup=hmAgentConfigGroup, hmAgentCLIConfigGroup=hmAgentCLIConfigGroup, hmAgentPortMirrorSourcePortMask=hmAgentPortMirrorSourcePortMask, hmAgentStpPortState=hmAgentStpPortState, hmAgentClearSwitchStats=hmAgentClearSwitchStats, hmAgentPortMirrorIngressMask=hmAgentPortMirrorIngressMask, hmAgentUserConfigEntry=hmAgentUserConfigEntry, hmAgentLagDetailedPortSpeed=hmAgentLagDetailedPortSpeed, hmAgentSwitchIGMPSnoopingGroupMembershipInterval=hmAgentSwitchIGMPSnoopingGroupMembershipInterval, hmAgentTransferUploadServerIP=hmAgentTransferUploadServerIP, failedUserLoginTrap=failedUserLoginTrap, hmAgentResetSystem=hmAgentResetSystem, hmAgentStpCstPortTopologyChangeAck=hmAgentStpCstPortTopologyChangeAck, hmAgentDot1xMaxUsers=hmAgentDot1xMaxUsers, hmAgentTransferDownloadStatus=hmAgentTransferDownloadStatus, hmAgentClassOfServicePortClass=hmAgentClassOfServicePortClass, hmAgentTransferUploadDataType=hmAgentTransferUploadDataType, hmAgentStpForceVersion=hmAgentStpForceVersion, hmAgentStpCstMaxAge=hmAgentStpCstMaxAge, hmAgentStpSwitchConfigGroup=hmAgentStpSwitchConfigGroup, hmAgentSwitchAddressAgingTimeoutTable=hmAgentSwitchAddressAgingTimeoutTable, hmAgentStpCstRootFwdDelay=hmAgentStpCstRootFwdDelay, dot1xTraps=dot1xTraps, hmAgentDot1xAdvanced=hmAgentDot1xAdvanced, hmAgentStpCstPortBpduFlood=hmAgentStpCstPortBpduFlood, hmAgentRadiusTimeout=hmAgentRadiusTimeout, hmAgentDot1xClientConfigGroup=hmAgentDot1xClientConfigGroup, hmAgentDot1xClientConfigTable=hmAgentDot1xClientConfigTable, hmAgentSwitchMFDBTable=hmAgentSwitchMFDBTable, hmAgentDot1xPortMABenabledOperational=hmAgentDot1xPortMABenabledOperational, hmAgentPortMirrorEntry=hmAgentPortMirrorEntry, hmAgentRadiusAccountingServerAddress=hmAgentRadiusAccountingServerAddress, hmAgentClearConfig=hmAgentClearConfig, hmAgentStpMstPortDisputed=hmAgentStpMstPortDisputed, hmAgentStpMstEntry=hmAgentStpMstEntry, hmAgentLagSummaryLagIndex=hmAgentLagSummaryLagIndex, hmAgentStpPortStatsRstpBpduTx=hmAgentStpPortStatsRstpBpduTx, hmAgentStpMstRootPathCost=hmAgentStpMstRootPathCost, hmAgentSSHMaxSessionsCount=hmAgentSSHMaxSessionsCount, hmAgentPortPhysicalMode=hmAgentPortPhysicalMode, hmAgentInfoGroup=hmAgentInfoGroup, hmAgentStpMstVlanRowStatus=hmAgentStpMstVlanRowStatus, hmAgentRadiusAccountingIndexNextValid=hmAgentRadiusAccountingIndexNextValid, hmAgentStpMstPortId=hmAgentStpMstPortId, hmAgentPortDefaultType=hmAgentPortDefaultType, hmAgentStpCstPortOperEdge=hmAgentStpCstPortOperEdge, hmAgentLogging=hmAgentLogging, hmAgentSSHSessionTimeout=hmAgentSSHSessionTimeout, hmAgentDot3adAggPortEntry=hmAgentDot3adAggPortEntry, hmAgentLoginSessionConnectionType=hmAgentLoginSessionConnectionType, hmAgentStpMstId=hmAgentStpMstId, hmPlatform4BasicL2=hmPlatform4BasicL2, hmAgentStpMstReceivedBridgeId=hmAgentStpMstReceivedBridgeId, hmAgentClearTrapLog=hmAgentClearTrapLog, hmAgentLogHostTableSeverityFilter=hmAgentLogHostTableSeverityFilter, hmAgentStpCstBridgeHelloTime=hmAgentStpCstBridgeHelloTime, hmAgentSwitchAddressAgingTimeoutEntry=hmAgentSwitchAddressAgingTimeoutEntry, hmAgentPortIanaType=hmAgentPortIanaType, hmAgentPortMirrorEgressMask=hmAgentPortMirrorEgressMask, hmAgentRadiusServerIndex=hmAgentRadiusServerIndex, hmAgentPortPhysicalStatus=hmAgentPortPhysicalStatus, hmAgentDot1xClientSessionTimeout=hmAgentDot1xClientSessionTimeout, hmAgentStpMstPortLoopInconsistentState=hmAgentStpMstPortLoopInconsistentState, hmAgentRadiusServerConfigEntry=hmAgentRadiusServerConfigEntry, hmAgentTrapLogEntry=hmAgentTrapLogEntry, hmAgentUserPassword=hmAgentUserPassword, hmAgentSwitchVoiceVLANAdminMode=hmAgentSwitchVoiceVLANAdminMode, hmAgentPortAdminMode=hmAgentPortAdminMode, hmAgentCableTesterCableFailureLocation=hmAgentCableTesterCableFailureLocation, hmAgentPortVoiceVlanMode=hmAgentPortVoiceVlanMode, hmAgentLoginSessionEntry=hmAgentLoginSessionEntry, hmAgentTrapLogTable=hmAgentTrapLogTable, hmAgentDot1xClientBackendState=hmAgentDot1xClientBackendState, hmAgentStpPortEntry=hmAgentStpPortEntry, hmAgentStpMstRowStatus=hmAgentStpMstRowStatus, hmAgentProtocolGroupName=hmAgentProtocolGroupName, hmAgentLagDetailedPortStatus=hmAgentLagDetailedPortStatus, hmAgentStpCstDesignatedBridgeId=hmAgentStpCstDesignatedBridgeId, hmAgentSpanningTreeConfigGroup=hmAgentSpanningTreeConfigGroup, hmAgentPortDVlanTagMode=hmAgentPortDVlanTagMode, hmAgentSwitchMFDBMacAddress=hmAgentSwitchMFDBMacAddress, hmAgentLogSyslogHostTable=hmAgentLogSyslogHostTable, hmAgentPortLinkTrapMode=hmAgentPortLinkTrapMode, hmAgentRadiusServerStatus=hmAgentRadiusServerStatus, hmAgentClassOfServicePortEntry=hmAgentClassOfServicePortEntry, hmAgentLoginSessionIndex=hmAgentLoginSessionIndex, hmAgentSwitchStaticMacFilteringEntry=hmAgentSwitchStaticMacFilteringEntry, hmAgentMirroredPortIfIndex=hmAgentMirroredPortIfIndex, hmAgentSwitchMFDBSummaryForwardingPortMask=hmAgentSwitchMFDBSummaryForwardingPortMask, hmAgentLagSummaryStpMode=hmAgentLagSummaryStpMode, hmAgentLogSyslogHostEntry=hmAgentLogSyslogHostEntry, hmAgentSwitchMFDBMaxTableEntries=hmAgentSwitchMFDBMaxTableEntries, hmAgentDot1xGuestVlanPeriod=hmAgentDot1xGuestVlanPeriod, hmAgentPortMirrorSessionNum=hmAgentPortMirrorSessionNum, hmAgentTrapLogSystemTime=hmAgentTrapLogSystemTime, hmAgentProtocolGroupPortStatus=hmAgentProtocolGroupPortStatus, hmAgentTransferDownloadServerIP=hmAgentTransferDownloadServerIP, hmAgentStpPortStatsStpBpduTx=hmAgentStpPortStatsStpBpduTx, hmAgentLagConfigCreate=hmAgentLagConfigCreate, hmAgentStpCstBridgePriority=hmAgentStpCstBridgePriority, hmAgentLagConfigGroup=hmAgentLagConfigGroup, hmPlatform4OutboundTelnetPrivate=hmPlatform4OutboundTelnetPrivate, hmAgentStpPortHelloTime=hmAgentStpPortHelloTime, hmAgentStpCstDesignatedCost=hmAgentStpCstDesignatedCost, hmAgentStpMstDesignatedRootId=hmAgentStpMstDesignatedRootId, hmAgentPortMirrorAdminMode=hmAgentPortMirrorAdminMode, hmAgentClearPasswords=hmAgentClearPasswords, hmAgentSpanningTreeMode=hmAgentSpanningTreeMode, hmAgentPortMirrorTable=hmAgentPortMirrorTable, hmAgentTrapLogTotalSinceLastViewed=hmAgentTrapLogTotalSinceLastViewed, hmAgentLagSummaryConfigEntry=hmAgentLagSummaryConfigEntry, hmAgentTransferUploadStart=hmAgentTransferUploadStart, hmAgentStpCstBridgeFwdDelay=hmAgentStpCstBridgeFwdDelay, hmAgentStpMstPortTransitionsIntoLoopInconsistentState=hmAgentStpMstPortTransitionsIntoLoopInconsistentState, hmAgentPortDVlanTagEthertype=hmAgentPortDVlanTagEthertype, hmAgentPortMirroringGroup=hmAgentPortMirroringGroup, hmAgentStpCstBridgeHoldTime=hmAgentStpCstBridgeHoldTime, hmAgentStpConfigRevision=hmAgentStpConfigRevision, hmAgentStpCstPortPathCost=hmAgentStpCstPortPathCost, fanFailureTrap=fanFailureTrap, linkFailureTrap=linkFailureTrap, hmAgentStpCstPortDisputed=hmAgentStpCstPortDisputed, vlanRestoreFailureTrap=vlanRestoreFailureTrap, hmAgentSwitchVoiceVlanDeviceTable=hmAgentSwitchVoiceVlanDeviceTable, hmAgentLagSummaryType=hmAgentLagSummaryType, hmAgentStpCstPortOperPointToPoint=hmAgentStpCstPortOperPointToPoint, hmAgentDot1xDynamicVlanCreationMode=hmAgentDot1xDynamicVlanCreationMode, hmAgentRadiusAccountingSecret=hmAgentRadiusAccountingSecret, stpInstanceNewRootTrap=stpInstanceNewRootTrap, hmAgentDot1xClientAuthPAEstate=hmAgentDot1xClientAuthPAEstate, dot1xPortStatusUnauthorized=dot1xPortStatusUnauthorized, hmAgentTransferUploadGroup=hmAgentTransferUploadGroup, hmAgentPortMirroringMode=hmAgentPortMirroringMode, hmAgentDot1xSafeVlanMode=hmAgentDot1xSafeVlanMode, hmAgentStpMstPortTransitionsOutOfLoopInconsistentState=hmAgentStpMstPortTransitionsOutOfLoopInconsistentState, hmAgentStpCstBridgeRootPort=hmAgentStpCstBridgeRootPort, HmAgentDot1xSessionTerminationAction=HmAgentDot1xSessionTerminationAction, hmAgentUserConfigGroup=hmAgentUserConfigGroup, hmAgentRadiusAccountingConfigTable=hmAgentRadiusAccountingConfigTable, hmAgentSwitchDVlanTagGroup=hmAgentSwitchDVlanTagGroup, hmAgentStpPortTable=hmAgentStpPortTable, hmAgentClassOfServiceGroup=hmAgentClassOfServiceGroup, hmAgentDot1xClientUserName=hmAgentDot1xClientUserName, hmAgentRadiusMaxTransmit=hmAgentRadiusMaxTransmit, hmAgentStpCstPortBpduGuardEffect=hmAgentStpCstPortBpduGuardEffect, hmAgentUserDefaultPwdActive=hmAgentUserDefaultPwdActive, hmAgentStpCstPortPriority=hmAgentStpCstPortPriority, hmAgentClearLags=hmAgentClearLags, hmAgentDot1xClientMacAddress=hmAgentDot1xClientMacAddress, hmAgentDot1xRadiusVlanAssignment=hmAgentDot1xRadiusVlanAssignment, hmAgentRadiusAccountingServerIndex=hmAgentRadiusAccountingServerIndex, hmAgentUserStatus=hmAgentUserStatus, broadcastStormStartTrap=broadcastStormStartTrap, hmAgentStpPortStatsMstpBpduTx=hmAgentStpPortStatsMstpBpduTx, hmAgentOutboundTelnetTimeout=hmAgentOutboundTelnetTimeout, hmAgentSwitchStaticMacFilteringSourcePortMask=hmAgentSwitchStaticMacFilteringSourcePortMask, hmAgentDot1xGuestVlanId=hmAgentDot1xGuestVlanId, vlanDefaultCfgFailureTrap=vlanDefaultCfgFailureTrap, hmAgentTransferDownloadGroup=hmAgentTransferDownloadGroup, hmAgentCableTesterStatus=hmAgentCableTesterStatus, hmAgentSSHSessionsCount=hmAgentSSHSessionsCount, hmAgentRadiusServerMsgAuth=hmAgentRadiusServerMsgAuth, hmAgentDot1xUnauthenticatedVlan=hmAgentDot1xUnauthenticatedVlan, hmAgentStpMstDesignatedCost=hmAgentStpMstDesignatedCost, hmAgentSwitchMFDBSummaryVlanId=hmAgentSwitchMFDBSummaryVlanId, hmAgentStpConfigName=hmAgentStpConfigName, hmAgentDot3adAggPortLACPMode=hmAgentDot3adAggPortLACPMode, multipleUsersTrap=multipleUsersTrap, hmAgentLogHostTableIndex=hmAgentLogHostTableIndex, hmAgentRadiusServerCurrentMode=hmAgentRadiusServerCurrentMode, hmAgentStpMstTimeSinceTopologyChange=hmAgentStpMstTimeSinceTopologyChange, hmAgentTransferUploadFilename=hmAgentTransferUploadFilename, hmAgentTrapLogTrap=hmAgentTrapLogTrap, hmAgentUserConfigTable=hmAgentUserConfigTable, HmAgentPortMask=HmAgentPortMask, hmAgentStpCstPortLoopGuard=hmAgentStpCstPortLoopGuard, hmAgentCableTesterCableStatus=hmAgentCableTesterCableStatus, hmAgentSaveConfigStatus=hmAgentSaveConfigStatus, hmAgentProtocolGroupPortIfIndex=hmAgentProtocolGroupPortIfIndex, hmAgentLagSummaryAdminMode=hmAgentLagSummaryAdminMode, hmAgentStpCstConfigGroup=hmAgentStpCstConfigGroup, hmAgentSaveConfig=hmAgentSaveConfig, hmAgentLagDetailedConfigEntry=hmAgentLagDetailedConfigEntry, hmAgentLagDetailedIfIndex=hmAgentLagDetailedIfIndex, hmAgentSwitchStaticMacFilteringVlanId=hmAgentSwitchStaticMacFilteringVlanId, BridgeId=BridgeId, hmAgentCableTesterIfIndex=hmAgentCableTesterIfIndex, hmAgentLagSummaryDeletePort=hmAgentLagSummaryDeletePort, hmAgentStpCstPortBpduFilter=hmAgentStpCstPortBpduFilter, hmAgentStpMstPortPathCost=hmAgentStpMstPortPathCost, hmAgentPortDVlanTagCustomerId=hmAgentPortDVlanTagCustomerId, hmAgentDot1xPortVlanAssignedReason=hmAgentDot1xPortVlanAssignedReason, hmAgentRadiusStatsClear=hmAgentRadiusStatsClear, hmAgentDot1xEnhancementConfigGroup=hmAgentDot1xEnhancementConfigGroup, hmAgentStpCstPortForwardingState=hmAgentStpCstPortForwardingState, hmAgentSwitchVoiceVlanDeviceMacAddress=hmAgentSwitchVoiceVlanDeviceMacAddress, hmAgentStpMstPortEntry=hmAgentStpMstPortEntry, hmAgentSystemGroup=hmAgentSystemGroup, hmAgentClearLoginSessions=hmAgentClearLoginSessions, hmAgentStpPortUpTime=hmAgentStpPortUpTime, hmAgentStpCstBridgeTopChanges=hmAgentStpCstBridgeTopChanges, hmAgentLagSummaryLinkTrap=hmAgentLagSummaryLinkTrap, hmAgentSwitchConfigGroup=hmAgentSwitchConfigGroup, hmAgentStpCstPortRootGuard=hmAgentStpCstPortRootGuard, hmAgentStpMstReceivedRPC=hmAgentStpMstReceivedRPC, hmAgentProtocolConfigGroup=hmAgentProtocolConfigGroup, hmAgentPortVoiceVlanDSCP=hmAgentPortVoiceVlanDSCP, hmAgentTransferConfigGroup=hmAgentTransferConfigGroup, hmAgentOutboundTelnetMaxNoOfSessions=hmAgentOutboundTelnetMaxNoOfSessions, hmAgentSwitchMFDBSummaryEntry=hmAgentSwitchMFDBSummaryEntry, hmAgentStpPortMigrationCheck=hmAgentStpPortMigrationCheck, hmAgentLagSummaryAddPort=hmAgentLagSummaryAddPort, hmAgentSwitchDot3FlowControlMode=hmAgentSwitchDot3FlowControlMode, hmAgentSwitchIGMPSnoopingMRPExpirationTime=hmAgentSwitchIGMPSnoopingMRPExpirationTime, hmAgentRadiusServerIndexNextValid=hmAgentRadiusServerIndexNextValid, hmAgentSwitchIGMPSnoopingGroup=hmAgentSwitchIGMPSnoopingGroup, hmAgentRadiusServerPrimaryMode=hmAgentRadiusServerPrimaryMode)
mibBuilder.exportSymbols("HIRSCHMANN-MMP4-BASICL2-MIB", hmAgentPortMaxFrameSize=hmAgentPortMaxFrameSize, hmAgentUserConfigCreate=hmAgentUserConfigCreate, hmAgentSSHConfigGroup=hmAgentSSHConfigGroup, hmAgentLoginSessionSessionTime=hmAgentLoginSessionSessionTime, hmAgentStpAdminMode=hmAgentStpAdminMode, hmAgentProtocolGroupPortEntry=hmAgentProtocolGroupPortEntry, hmAgentOutboundTelnetGroup=hmAgentOutboundTelnetGroup, hmAgentDot1xPortConfigGroup=hmAgentDot1xPortConfigGroup, hmAgentPortClearStats=hmAgentPortClearStats, hmAgentSwitchBroadcastControlMode=hmAgentSwitchBroadcastControlMode, hmAgentStpCstPortEdge=hmAgentStpCstPortEdge, hmAgentSwitchMFDBDescription=hmAgentSwitchMFDBDescription, hmAgentDot1xLogicalPort=hmAgentDot1xLogicalPort, hmAgentStpCstRegionalRootId=hmAgentStpCstRegionalRootId, hmAgentStpCstBridgeTimeSinceTopologyChange=hmAgentStpCstBridgeTimeSinceTopologyChange, hmAgentSwitchMFDBType=hmAgentSwitchMFDBType, hmAgentStpPortStatsStpBpduRx=hmAgentStpPortStatsStpBpduRx, hmAgentPortSTPState=hmAgentPortSTPState, hmAgentStpMstBridgeIdentifier=hmAgentStpMstBridgeIdentifier, hmAgentLogHostTableRowStatus=hmAgentLogHostTableRowStatus, hmAgentStpMstPortTable=hmAgentStpMstPortTable, hmAgentStpMstTopologyChangeCount=hmAgentStpMstTopologyChangeCount, hmAgentStpCstBridgeMaxHops=hmAgentStpCstBridgeMaxHops, hmAgentStpPortStatsMstpBpduRx=hmAgentStpPortStatsMstpBpduRx, hmAgentTelnetLoginTimeout=hmAgentTelnetLoginTimeout, vlanDeleteLastTrap=vlanDeleteLastTrap, hmAgentRadiusServerSecret=hmAgentRadiusServerSecret, hmAgentUserAuthenticationType=hmAgentUserAuthenticationType, hmAgentStpMstDesignatedBridgeId=hmAgentStpMstDesignatedBridgeId, hmAgentLogConfigGroup=hmAgentLogConfigGroup, hmAgentLoginSessionStatus=hmAgentLoginSessionStatus, hmAgentClassOfServicePortTable=hmAgentClassOfServicePortTable, hmAgentRadiusAccountingConfigEntry=hmAgentRadiusAccountingConfigEntry, hmAgentSwitchAddressAgingTimeout=hmAgentSwitchAddressAgingTimeout, hmAgentLogSyslogAdminStatus=hmAgentLogSyslogAdminStatus, hmAgentMgmtSecurity=hmAgentMgmtSecurity, hmAgentLagDetailedLagIndex=hmAgentLagDetailedLagIndex, hmAgentOutboundTelnetAdminMode=hmAgentOutboundTelnetAdminMode, hmAgentCableTesterMinimumCableLength=hmAgentCableTesterMinimumCableLength, hmAgentRadiusServerAddress=hmAgentRadiusServerAddress, hmAgentPortDot1dBasePort=hmAgentPortDot1dBasePort, hmAgentStpMstReceivedPortId=hmAgentStpMstReceivedPortId, hmAgentDot1xPortVlanAssigned=hmAgentDot1xPortVlanAssigned, hmAgentCableTesterGroup=hmAgentCableTesterGroup, hmAgentSwitchVoiceVlanInterfaceNum=hmAgentSwitchVoiceVlanInterfaceNum, hmAgentLogSysLogConfigGroup=hmAgentLogSysLogConfigGroup, hmAgentPortType=hmAgentPortType, hmAgentRadiusAccountingMode=hmAgentRadiusAccountingMode, hmAgentStpMstDesignatedPortId=hmAgentStpMstDesignatedPortId, hmAgentPortVoiceVlanOperationalStatus=hmAgentPortVoiceVlanOperationalStatus, hmAgentLagConfigStaticCapability=hmAgentLagConfigStaticCapability, hmAgentSwitchStaticMacFilteringTable=hmAgentSwitchStaticMacFilteringTable, hmAgentDot1xClientSessionTime=hmAgentDot1xClientSessionTime, hmAgentSwitchMFDBSummaryTable=hmAgentSwitchMFDBSummaryTable, hmAgentStpCstBridgeMaxAge=hmAgentStpCstBridgeMaxAge, hmAgentLogHostTablePort=hmAgentLogHostTablePort, hmAgentTransferUploadPath=hmAgentTransferUploadPath, hmAgentTrapLogIndex=hmAgentTrapLogIndex, hmAgentTransferDownloadStart=hmAgentTransferDownloadStart, hmAgentSwitchIGMPSnoopingMaxResponseTime=hmAgentSwitchIGMPSnoopingMaxResponseTime, hmAgentSwitchMFDBEntry=hmAgentSwitchMFDBEntry, hmAgentTransferDownloadDataType=hmAgentTransferDownloadDataType, hmAgentTransferDownloadMode=hmAgentTransferDownloadMode, hmAgentSwitchIGMPSnoopingPortMask=hmAgentSwitchIGMPSnoopingPortMask, hmAgentRadiusServerConfigTable=hmAgentRadiusServerConfigTable, hmAgentSwitchMFDBCurrentEntries=hmAgentSwitchMFDBCurrentEntries, hmAgentProtocolGroupTable=hmAgentProtocolGroupTable, hmAgentStpCstBridgeHoldCount=hmAgentStpCstBridgeHoldCount, hmAgentSwitchStaticMacFilteringStatus=hmAgentSwitchStaticMacFilteringStatus, hmAgentStpCstBridgeRootCost=hmAgentStpCstBridgeRootCost, hmAgentStpMstVlanTable=hmAgentStpMstVlanTable, hmAgentStpCstPortEntry=hmAgentStpCstPortEntry, hmAgentPortAutoNegAdminStatus=hmAgentPortAutoNegAdminStatus, hmAgentProtocolGroupStatus=hmAgentProtocolGroupStatus, hmAgentDot1xClientVlanAssigned=hmAgentDot1xClientVlanAssigned, hmAgentDot1xPortControlMode=hmAgentDot1xPortControlMode, hmAgentUserIndex=hmAgentUserIndex, hmAgentDot1xPortConfigEntry=hmAgentDot1xPortConfigEntry, hmAgentRadiusAccountingStatus=hmAgentRadiusAccountingStatus, hmAgentStpCstPortRole=hmAgentStpCstPortRole, hmAgentProtocolGroupVlanId=hmAgentProtocolGroupVlanId, hmAgentSwitchIGMPSnoopingAdminMode=hmAgentSwitchIGMPSnoopingAdminMode, hmAgentStpCstPortTable=hmAgentStpCstPortTable, powerSupplyStatusChangeTrap=powerSupplyStatusChangeTrap, hmAgentLagSummaryStatus=hmAgentLagSummaryStatus, hmAgentDot1xPortSessionTimeout=hmAgentDot1xPortSessionTimeout, hmAgentProtocolGroupCreate=hmAgentProtocolGroupCreate, hmAgentSwitchMFDBVlanId=hmAgentSwitchMFDBVlanId, hmAgentSwitchVoiceVlanDeviceEntry=hmAgentSwitchVoiceVlanDeviceEntry, hmAgentSwitchStaticMacFilteringDestPortMask=hmAgentSwitchStaticMacFilteringDestPortMask, hmAgentDot1xInterface=hmAgentDot1xInterface, hmAgentStpCstPortId=hmAgentStpCstPortId, hmAgentLoginSessionTable=hmAgentLoginSessionTable, hmAgentTransferUploadMode=hmAgentTransferUploadMode, hmAgentTelnetConfigGroup=hmAgentTelnetConfigGroup, hmAgentPortConfigEntry=hmAgentPortConfigEntry, hmAgentStpMstRootPortId=hmAgentStpMstRootPortId, hmAgentProtocolGroupPortTable=hmAgentProtocolGroupPortTable, hmAgentTransferUploadStatus=hmAgentTransferUploadStatus, hmAgentStpMstTopologyChangeParm=hmAgentStpMstTopologyChangeParm, hmAgentProtocolGroupProtocolIPX=hmAgentProtocolGroupProtocolIPX, hmAgentStpBpduGuardMode=hmAgentStpBpduGuardMode, hmAgentSwitchMFDBForwardingPortMask=hmAgentSwitchMFDBForwardingPortMask, hmAgentProtocolGroupId=hmAgentProtocolGroupId, hmAgentSwitchMFDBMostEntriesUsed=hmAgentSwitchMFDBMostEntriesUsed, hmAgentLogHostTableIpAddress=hmAgentLogHostTableIpAddress, hmAgentStpMstPortPriority=hmAgentStpMstPortPriority, hmAgentClearVlan=hmAgentClearVlan, hmAgentLoginSessionUserName=hmAgentLoginSessionUserName, hmAgentSwitchIGMPSnoopingMulticastControlFramesProcessed=hmAgentSwitchIGMPSnoopingMulticastControlFramesProcessed, hmAgentTransferDownloadPath=hmAgentTransferDownloadPath, hmAgentRadiusConfigGroup=hmAgentRadiusConfigGroup, hmAgentStpMstTable=hmAgentStpMstTable, hmAgentTrapLogTotal=hmAgentTrapLogTotal, hmPlatform4=hmPlatform4, hmAgentPortVoiceVlanID=hmAgentPortVoiceVlanID, hmAgentRadiusAccountingPort=hmAgentRadiusAccountingPort, hmAgentDot1xPortTerminationAction=hmAgentDot1xPortTerminationAction, hmAgentSwitchVoiceVLANGroup=hmAgentSwitchVoiceVLANGroup, hmAgentPortIfIndex=hmAgentPortIfIndex, hmAgentSwitchMFDBFilteringPortMask=hmAgentSwitchMFDBFilteringPortMask, hmAgentStpCstRegionalRootPathCost=hmAgentStpCstRegionalRootPathCost, hmAgentPortMirrorDestinationPort=hmAgentPortMirrorDestinationPort, hmAgentPortVoiceVlanPriority=hmAgentPortVoiceVlanPriority, hmAgentCableTesterMaximumCableLength=hmAgentCableTesterMaximumCableLength, hmAgentDot3adAggPort=hmAgentDot3adAggPort, hmAgentSwitchMFDBProtocolType=hmAgentSwitchMFDBProtocolType, hmAgentStpMstPortForwardingState=hmAgentStpMstPortForwardingState, hmAgentStpMstPortRole=hmAgentStpMstPortRole, hmAgentDot1xClientVlanAssignedReason=hmAgentDot1xClientVlanAssignedReason, hmAgentPortVoiceVlanAuthMode=hmAgentPortVoiceVlanAuthMode, hmPlatform4SwitchingTraps=hmPlatform4SwitchingTraps, hmAgentPortVoiceVlanDataPriorityMode=hmAgentPortVoiceVlanDataPriorityMode, hmAgentStpConfigFormatSelector=hmAgentStpConfigFormatSelector, dot1xPortStatusAuthorized=dot1xPortStatusAuthorized, hmAgentStpCstBridgeDesignatedRoot=hmAgentStpCstBridgeDesignatedRoot, hmAgentLagDetailedConfigTable=hmAgentLagDetailedConfigTable, hmAgentUserEncryptionType=hmAgentUserEncryptionType, hmAgentTelnetMaxSessions=hmAgentTelnetMaxSessions, hmRadius=hmRadius, hmAgentLagSummaryFlushTimer=hmAgentLagSummaryFlushTimer, hmAgentPortSTPMode=hmAgentPortSTPMode, hmAgentStpBpduFilterDefault=hmAgentStpBpduFilterDefault, hmAgentTelnetAllowNewMode=hmAgentTelnetAllowNewMode, hmAgentStpPortStatsRstpBpduRx=hmAgentStpPortStatsRstpBpduRx, HmAgentDot1xPortControlMode=HmAgentDot1xPortControlMode, hmAgentSSHAdminMode=hmAgentSSHAdminMode, hmAgentUserEncryptionPassword=hmAgentUserEncryptionPassword, hmAgentStpConfigDigestKey=hmAgentStpConfigDigestKey, hmAgentPortMaxFrameSizeLimit=hmAgentPortMaxFrameSizeLimit, hmAgentStpMstBridgePriority=hmAgentStpMstBridgePriority, hmAgentSwitchStaticMacFilteringAddress=hmAgentSwitchStaticMacFilteringAddress)

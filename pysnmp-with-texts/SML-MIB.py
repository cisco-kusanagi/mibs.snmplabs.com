#
# PySNMP MIB module SML-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SML-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:07:42 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
IpAddress, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, enterprises, Unsigned32, Counter32, iso, MibIdentifier, ObjectIdentity, ModuleIdentity, NotificationType, TimeTicks, Gauge32, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "enterprises", "Unsigned32", "Counter32", "iso", "MibIdentifier", "ObjectIdentity", "ModuleIdentity", "NotificationType", "TimeTicks", "Gauge32", "Integer32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class UShortReal(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class CimDateTime(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(24, 24)
    fixedLength = 24

class UINT64(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class UINT32(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class UINT16(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

ibm = MibIdentifier((1, 3, 6, 1, 4, 1, 2))
ibmProd = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6))
ibm3584 = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 182))
smlRoot = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 182, 3))
smlMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smlMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: smlMibVersion.setDescription('This string contains version information for the MIB file')
smlCimVersion = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smlCimVersion.setStatus('mandatory')
if mibBuilder.loadTexts: smlCimVersion.setDescription('This string contains information about the CIM version that corresponds to the MIB. The decriptions in this MIB file are based on CIM version 2.7, as documented by Steve Jerman for HP.')
productGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 3))
product_Name = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setLabel("product-Name").setMaxAccess("readonly")
if mibBuilder.loadTexts: product_Name.setStatus('mandatory')
if mibBuilder.loadTexts: product_Name.setDescription('Commonly used Product name.')
product_IdentifyingNumber = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setLabel("product-IdentifyingNumber").setMaxAccess("readonly")
if mibBuilder.loadTexts: product_IdentifyingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: product_IdentifyingNumber.setDescription('Product identification such as a serial number on software, a die number on a hardware chip, or (for non-commercial Products) a project number.')
product_Vendor = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setLabel("product-Vendor").setMaxAccess("readonly")
if mibBuilder.loadTexts: product_Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: product_Vendor.setDescription("The name of the Product's supplier, or entity selling the Product (the manufacturer, reseller, OEM, etc.). Corresponds to the Vendor property in the Product object in the DMTF Solution Exchange Standard.")
product_Version = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 3, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setLabel("product-Version").setMaxAccess("readonly")
if mibBuilder.loadTexts: product_Version.setStatus('mandatory')
if mibBuilder.loadTexts: product_Version.setDescription('Product version information. Corresponds to the Version property in the Product object in the DMTF Solution Exchange Standard.')
chassisGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 4))
chassis_Manufacturer = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 4, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setLabel("chassis-Manufacturer").setMaxAccess("readonly")
if mibBuilder.loadTexts: chassis_Manufacturer.setStatus('mandatory')
if mibBuilder.loadTexts: chassis_Manufacturer.setDescription('The name of the organization responsible for producing the PhysicalElement. This may be the entity from whom the Element is purchased, but this is not necessarily true. The latter information is contained in the Vendor property of CIM_Product.')
chassis_Model = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 4, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setLabel("chassis-Model").setMaxAccess("readonly")
if mibBuilder.loadTexts: chassis_Model.setStatus('mandatory')
if mibBuilder.loadTexts: chassis_Model.setDescription('The name by which the PhysicalElement is generally known.')
chassis_SerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 4, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setLabel("chassis-SerialNumber").setMaxAccess("readonly")
if mibBuilder.loadTexts: chassis_SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: chassis_SerialNumber.setDescription('A manufacturer-allocated number used to identify the Physical Element.')
chassis_LockPresent = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("true", 1), ("false", 2)))).setLabel("chassis-LockPresent").setMaxAccess("readonly")
if mibBuilder.loadTexts: chassis_LockPresent.setStatus('mandatory')
if mibBuilder.loadTexts: chassis_LockPresent.setDescription('Boolean indicating whether the Frame is protected with a lock.')
chassis_SecurityBreach = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("other", 1), ("noBreach", 2), ("breachAttempted", 3)))).setLabel("chassis-SecurityBreach").setMaxAccess("readonly")
if mibBuilder.loadTexts: chassis_SecurityBreach.setStatus('mandatory')
if mibBuilder.loadTexts: chassis_SecurityBreach.setDescription("SecurityBreach is an enumerated, integer-valued property indicating whether a physical breach of the Frame was attempted but unsuccessful (value=4) or attempted and successful (5). Also, the values, 'Unknown', 'Other' or 'No Breach', can be specified.")
chassis_IsLocked = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("true", 1), ("false", 2)))).setLabel("chassis-IsLocked").setMaxAccess("readonly")
if mibBuilder.loadTexts: chassis_IsLocked.setStatus('mandatory')
if mibBuilder.loadTexts: chassis_IsLocked.setDescription('Boolean indicating that the Frame is currently locked.')
storageLibraryGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 5))
storageLibrary_Name = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 5, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setLabel("storageLibrary-Name").setMaxAccess("readonly")
if mibBuilder.loadTexts: storageLibrary_Name.setStatus('mandatory')
if mibBuilder.loadTexts: storageLibrary_Name.setDescription('The inherited Name serves as key of a System instance in an enterprise environment.')
storageLibrary_Description = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 5, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setLabel("storageLibrary-Description").setMaxAccess("readonly")
if mibBuilder.loadTexts: storageLibrary_Description.setStatus('mandatory')
if mibBuilder.loadTexts: storageLibrary_Description.setDescription('The Description property provides a textual description of the object.')
storageLibrary_Caption = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 5, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setLabel("storageLibrary-Caption").setMaxAccess("readonly")
if mibBuilder.loadTexts: storageLibrary_Caption.setStatus('mandatory')
if mibBuilder.loadTexts: storageLibrary_Caption.setDescription('The Caption property is a short textual description (one- line string) of the object.')
storageLibrary_Status = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 5, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setLabel("storageLibrary-Status").setMaxAccess("readonly")
if mibBuilder.loadTexts: storageLibrary_Status.setStatus('mandatory')
if mibBuilder.loadTexts: storageLibrary_Status.setDescription('A string indicating the current status of the object. Various operational and non-operational statuses are defined. This property is deprecated in lieu of OperationalStatus, which includes the same semantics in its enumeration. This change is made for three reasons: 1) Status is more correctly defined as an array property. This overcomes the limitation of describing status via a single value, when it is really a multi-valued property (for example, an element may be OK AND Stopped. 2) A MaxLen of 10 is too restrictive and leads to unclear enumerated values. And, 3) The change to a uint16 data type was discussed when CIM V2.0 was defined. However, existing V1.0 implementations used the string property and did not want to modify their code. Therefore, Status was grandfathered into the Schema. Use of the Deprecated qualifier allows the maintenance of the existing property, but also permits an improved definition using OperationalStatus.')
storageLibrary_InstallDate = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 5, 5), CimDateTime()).setLabel("storageLibrary-InstallDate").setMaxAccess("readonly")
if mibBuilder.loadTexts: storageLibrary_InstallDate.setStatus('mandatory')
if mibBuilder.loadTexts: storageLibrary_InstallDate.setDescription('A datetime value indicating when the object was installed. A lack of a value does not indicate that the object is not installed.')
mediaAccessDeviceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 6))
numberOfMediaAccessDevices = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfMediaAccessDevices.setStatus('mandatory')
if mibBuilder.loadTexts: numberOfMediaAccessDevices.setDescription('This value specifies the number of MediaAccessDevices that are present.')
mediaAccessDeviceTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 6, 2), )
if mibBuilder.loadTexts: mediaAccessDeviceTable.setStatus('mandatory')
if mibBuilder.loadTexts: mediaAccessDeviceTable.setDescription('A MediaAccessDevice represents the ability to access one or more media and use this media to store and retrieve data.')
mediaAccessDeviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 6, 2, 1), ).setIndexNames((0, "SML-MIB", "mediaAccessDeviceIndex"))
if mibBuilder.loadTexts: mediaAccessDeviceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mediaAccessDeviceEntry.setDescription('Each entry in the table contains information about a MediaAccessDevice that is present in the library.')
mediaAccessDeviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 6, 2, 1, 1), UINT32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaAccessDeviceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mediaAccessDeviceIndex.setDescription('The current index value for the MediaAccessDevice.')
mediaAccessDeviceObjectType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 0), ("wormDrive", 1), ("magnetoOpticalDrive", 2), ("tapeDrive", 3), ("dvdDrive", 4), ("cdromDrive", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaAccessDeviceObjectType.setStatus('mandatory')
if mibBuilder.loadTexts: mediaAccessDeviceObjectType.setDescription('In the 2.7 CIM Schema a Type property is no longer associated with MediaAccessDevice. However, it can be used here to specify the type of drive that is present.')
mediaAccessDevice_Name = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 6, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setLabel("mediaAccessDevice-Name").setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaAccessDevice_Name.setStatus('mandatory')
if mibBuilder.loadTexts: mediaAccessDevice_Name.setDescription('The Name property defines the label by which the object is known. When subclassed, the Name property can be overridden to be a Key property.')
mediaAccessDevice_Status = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 6, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setLabel("mediaAccessDevice-Status").setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaAccessDevice_Status.setStatus('mandatory')
if mibBuilder.loadTexts: mediaAccessDevice_Status.setDescription('A string indicating the current status of the object. Various operational and non-operational statuses are defined. This property is deprecated in lieu of OperationalStatus, which includes the same semantics in its enumeration. This change is made for three reasons: 1) Status is more correctly defined as an array property. This overcomes the limitation of describing status via a single value, when it is really a multi-valued property (for example, an element may be OK AND Stopped. 2) A MaxLen of 10 is too restrictive and leads to unclear enumerated values. And, 3) The change to a uint16 data type was discussed when CIM V2.0 was defined. However, existing V1.0 implementations used the string property and did not want to modify their code. Therefore, Status was grandfathered into the Schema. Use of the Deprecated qualifier allows the maintenance of the existing property, but also permits an improved definition using OperationalStatus.')
mediaAccessDevice_Availability = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("unknown", 0), ("other", 1), ("runningFullPower", 2), ("warning", 3), ("inTest", 4), ("notApplicable", 5), ("powerOff", 6), ("offLine", 7), ("offDuty", 8), ("degraded", 9), ("notInstalled", 10), ("installError", 11), ("powerSaveUnknown", 12), ("powerSaveLowPowerMode", 13), ("powerSaveStandby", 14), ("powerCycle", 15), ("powerSaveWarning", 16), ("paused", 17), ("notReady", 18)))).setLabel("mediaAccessDevice-Availability").setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaAccessDevice_Availability.setStatus('mandatory')
if mibBuilder.loadTexts: mediaAccessDevice_Availability.setDescription("The primary availability and status of the Device. (Additional status information can be specified using the AdditionalAvailability array property.) For example, the Availability property indicates that the Device is running and has full power (value=3), or is in a warning (4), test (5), degraded (10) or power save state (values 13-15 and 17). Regarding the Power Save states, these are defined as follows: Value 13 ('Power Save - Unknown') indicates that the Device is known to be in a power save mode, but its exact status in this mode is unknown; 14 ('Power Save - Low Power Mode') indicates that the Device is in a power save state but still functioning, and may exhibit degraded performance; 15 ('Power Save - Standby') describes that the Device is not functioning but could be brought to full power 'quickly'; and value 17 ('Power Save - Warning') indicates that the Device is in a warning state, though also in a power save mode.")
mediaAccessDevice_NeedsCleaning = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 6, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("true", 1), ("false", 2)))).setLabel("mediaAccessDevice-NeedsCleaning").setMaxAccess("readonly")
if mibBuilder.loadTexts: mediaAccessDevice_NeedsCleaning.setStatus('mandatory')
if mibBuilder.loadTexts: mediaAccessDevice_NeedsCleaning.setDescription('Boolean indicating that the MediaAccessDevice needs cleaning. Whether manual or automatic cleaning is possible is indicated in the Capabilities array property. ')
physicalMediaGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 7))
numberOfPhysicalMedias = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfPhysicalMedias.setStatus('mandatory')
if mibBuilder.loadTexts: numberOfPhysicalMedias.setDescription('This value specifies the number of PhysicalMedia that are present.')
physicalMediaTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 7, 2), )
if mibBuilder.loadTexts: physicalMediaTable.setStatus('mandatory')
if mibBuilder.loadTexts: physicalMediaTable.setDescription("The PhysicalMedia class represents any type of documentation or storage medium, such as tapes, CDROMs, etc. This class is typically used to locate and manage Removable Media (versus Media sealed with the MediaAccessDevice, as a single Package, as is the case with hard disks). However, 'sealed' Media can also be modeled using this class, where the Media would then be associated with the PhysicalPackage using the PackagedComponent relationship.")
physicalMediaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 7, 2, 1), ).setIndexNames((0, "SML-MIB", "physicalMediaIndex"))
if mibBuilder.loadTexts: physicalMediaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: physicalMediaEntry.setDescription('Each entry in the table contains information about a PhysicalMedia that is present in the library.')
physicalMediaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 7, 2, 1, 1), UINT32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalMediaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: physicalMediaIndex.setDescription('The current index value for the PhysicalMedia.')
physicalMediaObjectType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("tape", 0), ("other", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalMediaObjectType.setStatus('mandatory')
if mibBuilder.loadTexts: physicalMediaObjectType.setDescription('In the 2.7 CIM Schema a Type property is no longer associated with physicalMedia. The MediaType property provides more detailed information.')
physicalMedia_Removable = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("true", 1), ("false", 2)))).setLabel("physicalMedia-Removable").setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalMedia_Removable.setStatus('mandatory')
if mibBuilder.loadTexts: physicalMedia_Removable.setDescription("A PhysicalComponent is Removable if it is designed to be taken in and out of the physical container in which it is normally found, without impairing the function of the overall packaging. A Component can still be Removable if power must be 'off' in order to perform the removal. If power can be 'on' and the Component removed, then the Element is both Removable and HotSwappable. For example, an upgradeable Processor chip is Removable.")
physicalMedia_Replaceable = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("true", 1), ("false", 2)))).setLabel("physicalMedia-Replaceable").setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalMedia_Replaceable.setStatus('mandatory')
if mibBuilder.loadTexts: physicalMedia_Replaceable.setDescription('A PhysicalComponent is Replaceable if it is possible to replace (FRU or upgrade) the Element with a physically different one. For example, some ComputerSystems allow the main Processor chip to be upgraded to one of a higher clock rating. In this case, the Processor is said to be Replaceable. All Removable Components are inherently Replaceable.')
physicalMedia_HotSwappable = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("true", 1), ("false", 2)))).setLabel("physicalMedia-HotSwappable").setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalMedia_HotSwappable.setStatus('mandatory')
if mibBuilder.loadTexts: physicalMedia_HotSwappable.setDescription("A PhysicalComponent is HotSwappable if it is possible to replace the Element with a physically different but equivalent one while the containing Package has power applied to it (ie, is 'on'). For example, a fan Component may be designed to be HotSwappable. All HotSwappable Components are inherently Removable and Replaceable.")
physicalMedia_Capacity = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 7, 2, 1, 6), UINT64()).setLabel("physicalMedia-Capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalMedia_Capacity.setStatus('mandatory')
if mibBuilder.loadTexts: physicalMedia_Capacity.setDescription("The number of bytes that can be read from or written to a Media. This property is not applicable to 'Hard Copy' (documentation) or cleaner Media. Data compression should not be assumed, as it would increase the value in this property. For tapes, it should be assumed that no filemarks or blank space areas are recorded on the Media.")
physicalMedia_MediaType = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 7, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59))).clone(namedValues=NamedValues(("unknown", 0), ("other", 1), ("tape", 2), ("qic", 3), ("ait", 4), ("dtf", 5), ("dat", 6), ("eightmmTape", 7), ("nineteenmmTape", 8), ("dlt", 9), ("halfInchMO", 10), ("catridgeDisk", 11), ("jazDisk", 12), ("zipDisk", 13), ("syQuestDisk", 14), ("winchesterDisk", 15), ("cdRom", 16), ("cdRomXA", 17), ("cdI", 18), ("cdRecordable", 19), ("dvd", 20), ("dvdRWPlus", 21), ("dvdRAM", 22), ("dvdROM", 23), ("dvdVideo", 24), ("divx", 25), ("cdRW", 26), ("cdDA", 27), ("cdPlus", 28), ("dvdRecordable", 29), ("dvdRW", 30), ("dvdAudio", 31), ("dvd5", 32), ("dvd9", 33), ("dvd10", 34), ("dvd18", 35), ("moRewriteable", 36), ("moWriteOnce", 37), ("moLIMDOW", 38), ("phaseChangeWO", 39), ("phaseChangeRewriteable", 40), ("phaseChangeDualRewriteable", 41), ("ablativeWriteOnce", 42), ("nearField", 43), ("miniQic", 44), ("travan", 45), ("eightmmMetal", 46), ("eightmmAdvanced", 47), ("nctp", 48), ("ltoUltrium", 49), ("ltoAccelis", 50), ("tape9Track", 51), ("tape18Track", 52), ("tape36Track", 53), ("magstar3590", 54), ("magstarMP", 55), ("d2Tape", 56), ("dstSmall", 57), ("dstMedium", 58), ("dstLarge", 59)))).setLabel("physicalMedia-MediaType").setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalMedia_MediaType.setStatus('mandatory')
if mibBuilder.loadTexts: physicalMedia_MediaType.setDescription('Specifies the type of the PhysicalMedia, as an enumerated integer. The MediaDescription property is used to provide more explicit definition of the Media type, whether it is pre-formatted, compatability features, etc.')
physicalMedia_MediaDescription = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 7, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setLabel("physicalMedia-MediaDescription").setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalMedia_MediaDescription.setStatus('mandatory')
if mibBuilder.loadTexts: physicalMedia_MediaDescription.setDescription("Additional detail related to the MediaType enumeration. For example, if value 3 ('QIC Cartridge') is specified, this property could indicate whether the tape is wide or 1/4 inch, whether it is pre-formatted, whether it is Travan compatible, etc.")
physicalMedia_CleanerMedia = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 7, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("true", 1), ("false", 2)))).setLabel("physicalMedia-CleanerMedia").setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalMedia_CleanerMedia.setStatus('mandatory')
if mibBuilder.loadTexts: physicalMedia_CleanerMedia.setDescription('Boolean indicating that the PhysicalMedia is used for cleaning purposes and not data storage.')
physicalMedia_DualSided = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 7, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("true", 1), ("false", 2)))).setLabel("physicalMedia-DualSided").setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalMedia_DualSided.setStatus('mandatory')
if mibBuilder.loadTexts: physicalMedia_DualSided.setDescription('Boolean indicating that the Media has two recording sides (TRUE) or only a single side (FALSE). Examples of dual sided Media include DVD-ROM and some optical disks. Examples of single sided Media are tapes and CD-ROM.')
physicalMedia_PhysicalLabel = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 7, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setLabel("physicalMedia-PhysicalLabel").setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalMedia_PhysicalLabel.setStatus('mandatory')
if mibBuilder.loadTexts: physicalMedia_PhysicalLabel.setDescription("One or more strings on 'labels' on the PhysicalMedia. The format of the labels and their state (readable, unreadable, upside-down) are indicated in the LabelFormats and LabelStates array properties.")
physicalPackageGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 8))
numberOfPhysicalPackages = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 8, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfPhysicalPackages.setStatus('mandatory')
if mibBuilder.loadTexts: numberOfPhysicalPackages.setDescription('This value specifies the number of PhysicalPackages that are present.')
physicalPackageTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 8, 2), )
if mibBuilder.loadTexts: physicalPackageTable.setStatus('mandatory')
if mibBuilder.loadTexts: physicalPackageTable.setDescription('The PhysicalPackage class represents PhysicalElements that contain or host other components. Examples are a Rack enclosure or an adapter Card. (also a tape magazine inside an auto-loader)')
physicalPackageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 8, 2, 1), ).setIndexNames((0, "SML-MIB", "physicalPackageIndex"))
if mibBuilder.loadTexts: physicalPackageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: physicalPackageEntry.setDescription('Each entry in the table contains information about a PhysicalPackage that is present in the library.')
physicalPackageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 8, 2, 1, 1), UINT32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalPackageIndex.setStatus('mandatory')
if mibBuilder.loadTexts: physicalPackageIndex.setDescription('The current index value for the PhysicalPackage.')
physicalPackage_Manufacturer = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 8, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setLabel("physicalPackage-Manufacturer").setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalPackage_Manufacturer.setStatus('mandatory')
if mibBuilder.loadTexts: physicalPackage_Manufacturer.setDescription('The name of the organization responsible for producing the PhysicalElement. This may be the entity from whom the Element is purchased, but this is not necessarily true. The latter information is contained in the Vendor property of CIM_Product.')
physicalPackage_Model = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 8, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setLabel("physicalPackage-Model").setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalPackage_Model.setStatus('mandatory')
if mibBuilder.loadTexts: physicalPackage_Model.setDescription('The name by which the PhysicalElement is generally known.')
physicalPackage_SerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 8, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setLabel("physicalPackage-SerialNumber").setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalPackage_SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: physicalPackage_SerialNumber.setDescription('A manufacturer-allocated number used to identify the Physical Element.')
physicalPackage_Realizes_MediaAccessDeviceIndex = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 8, 2, 1, 5), Integer32()).setLabel("physicalPackage-Realizes-MediaAccessDeviceIndex").setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalPackage_Realizes_MediaAccessDeviceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: physicalPackage_Realizes_MediaAccessDeviceIndex.setDescription("The index value of the the MediaAccess device that is associated with this physical package.'")
softwareElementGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9))
numberOfSoftwareElements = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfSoftwareElements.setStatus('mandatory')
if mibBuilder.loadTexts: numberOfSoftwareElements.setDescription('This value specifies the number of SoftwareElements that are present.')
softwareElementTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 2), )
if mibBuilder.loadTexts: softwareElementTable.setStatus('mandatory')
if mibBuilder.loadTexts: softwareElementTable.setDescription("The CIM_SoftwareElement class is used to decompose a CIM_SoftwareFeature object into a set of individually manageable or deployable parts for a particular platform. A software element's platform is uniquely identified by its underlying hardware architecture and operating system (for example Sun Solaris on Sun Sparc or Windows NT on Intel). As such, to understand the details of how the functionality of a particular software feature is provided on a particular platform, the CIM_SoftwareElement objects referenced by CIM_SoftwareFeatureSoftwareElement associations are organized in disjoint sets based on the TargetOperatingSystem property. A CIM_SoftwareElement object captures the management details of a part or component in one of four states characterized by the SoftwareElementState property. ")
softwareElementEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 2, 1), ).setIndexNames((0, "SML-MIB", "softwareElementIndex"))
if mibBuilder.loadTexts: softwareElementEntry.setStatus('mandatory')
if mibBuilder.loadTexts: softwareElementEntry.setDescription('Each entry in the table contains information about a SoftwareElement that is present in the library.')
softwareElementIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 2, 1, 1), UINT32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareElementIndex.setStatus('mandatory')
if mibBuilder.loadTexts: softwareElementIndex.setDescription('The current index value for the SoftwareElement.')
softwareElement_Name = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setLabel("softwareElement-Name").setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareElement_Name.setStatus('mandatory')
if mibBuilder.loadTexts: softwareElement_Name.setDescription('The name used to identify this software element')
softwareElement_Version = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setLabel("softwareElement-Version").setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareElement_Version.setStatus('mandatory')
if mibBuilder.loadTexts: softwareElement_Version.setDescription('Version should be in the form .. or . ')
softwareElement_SoftwareElementID = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setLabel("softwareElement-SoftwareElementID").setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareElement_SoftwareElementID.setStatus('mandatory')
if mibBuilder.loadTexts: softwareElement_SoftwareElementID.setDescription('This is an identifier for this software element and is designed to be used in conjunction with other keys to create a unique representation of this SoftwareElement')
softwareElement_Manufacturer = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setLabel("softwareElement-Manufacturer").setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareElement_Manufacturer.setStatus('mandatory')
if mibBuilder.loadTexts: softwareElement_Manufacturer.setDescription('Manufacturer of this software element')
softwareElement_BuildNumber = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setLabel("softwareElement-BuildNumber").setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareElement_BuildNumber.setStatus('mandatory')
if mibBuilder.loadTexts: softwareElement_BuildNumber.setDescription('The internal identifier for this compilation of this software element.')
softwareElement_SerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setLabel("softwareElement-SerialNumber").setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareElement_SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: softwareElement_SerialNumber.setDescription('The assigned serial number of this software element.')
softwareElement_CodeSet = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setLabel("softwareElement-CodeSet").setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareElement_CodeSet.setStatus('mandatory')
if mibBuilder.loadTexts: softwareElement_CodeSet.setDescription('The code set used by this software element. ')
softwareElement_IdentificationCode = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setLabel("softwareElement-IdentificationCode").setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareElement_IdentificationCode.setStatus('mandatory')
if mibBuilder.loadTexts: softwareElement_IdentificationCode.setDescription("The value of this property is the manufacturer's identifier for this software element. Often this will be a stock keeping unit (SKU) or a part number.")
softwareElement_LanguageEdition = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 2, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setLabel("softwareElement-LanguageEdition").setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareElement_LanguageEdition.setStatus('mandatory')
if mibBuilder.loadTexts: softwareElement_LanguageEdition.setDescription('The value of this property identifies the language edition of this software element. The language codes defined in ISO 639 should be used. Where the software element represents multi-lingual or international version of a product, the string multilingual should be used.')
softwareElement_Associations = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 2, 1, 11), ObjectIdentifier()).setLabel("softwareElement-Associations")
if mibBuilder.loadTexts: softwareElement_Associations.setStatus('mandatory')
if mibBuilder.loadTexts: softwareElement_Associations.setDescription('Use this value to associate a SoftwareElement with another object in the MIB')
softwareElement_DeviceSoftware_LogicalDeviceAssociation_ObjectT = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("mediaAccessDevice", 0), ("storageLibrary", 1), ("other", 2)))).setLabel("softwareElement-DeviceSoftware-LogicalDeviceAssociation-ObjectT").setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareElement_DeviceSoftware_LogicalDeviceAssociation_ObjectT.setStatus('mandatory')
if mibBuilder.loadTexts: softwareElement_DeviceSoftware_LogicalDeviceAssociation_ObjectT.setDescription('Use this value to associate a SoftwareElement with a specific media access device or the library itself.')
softwareElement_DeviceSoftware_LogicalDeviceAssociationId = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 9, 2, 1, 13), Integer32()).setLabel("softwareElement-DeviceSoftware-LogicalDeviceAssociationId").setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareElement_DeviceSoftware_LogicalDeviceAssociationId.setStatus('mandatory')
if mibBuilder.loadTexts: softwareElement_DeviceSoftware_LogicalDeviceAssociationId.setDescription('Further clarification required.')
endOfSmlMib = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 182, 3, 10), ObjectIdentifier())
if mibBuilder.loadTexts: endOfSmlMib.setStatus('mandatory')
if mibBuilder.loadTexts: endOfSmlMib.setDescription('Description here')
mibBuilder.exportSymbols("SML-MIB", physicalMedia_MediaType=physicalMedia_MediaType, mediaAccessDeviceTable=mediaAccessDeviceTable, storageLibrary_Description=storageLibrary_Description, softwareElementEntry=softwareElementEntry, physicalPackageGroup=physicalPackageGroup, storageLibrary_InstallDate=storageLibrary_InstallDate, chassis_Manufacturer=chassis_Manufacturer, CimDateTime=CimDateTime, chassis_SecurityBreach=chassis_SecurityBreach, softwareElement_Manufacturer=softwareElement_Manufacturer, mediaAccessDeviceEntry=mediaAccessDeviceEntry, smlMibVersion=smlMibVersion, physicalPackage_Manufacturer=physicalPackage_Manufacturer, numberOfPhysicalMedias=numberOfPhysicalMedias, mediaAccessDevice_NeedsCleaning=mediaAccessDevice_NeedsCleaning, softwareElement_LanguageEdition=softwareElement_LanguageEdition, chassis_IsLocked=chassis_IsLocked, softwareElement_Name=softwareElement_Name, mediaAccessDevice_Name=mediaAccessDevice_Name, softwareElement_SerialNumber=softwareElement_SerialNumber, mediaAccessDeviceObjectType=mediaAccessDeviceObjectType, physicalMedia_Capacity=physicalMedia_Capacity, physicalMediaIndex=physicalMediaIndex, ibmProd=ibmProd, physicalMediaTable=physicalMediaTable, physicalMediaObjectType=physicalMediaObjectType, mediaAccessDeviceIndex=mediaAccessDeviceIndex, physicalMedia_HotSwappable=physicalMedia_HotSwappable, product_Vendor=product_Vendor, storageLibrary_Caption=storageLibrary_Caption, softwareElement_DeviceSoftware_LogicalDeviceAssociationId=softwareElement_DeviceSoftware_LogicalDeviceAssociationId, ibm=ibm, physicalMedia_PhysicalLabel=physicalMedia_PhysicalLabel, endOfSmlMib=endOfSmlMib, physicalPackage_Model=physicalPackage_Model, chassis_LockPresent=chassis_LockPresent, physicalMedia_Replaceable=physicalMedia_Replaceable, softwareElement_SoftwareElementID=softwareElement_SoftwareElementID, ibm3584=ibm3584, mediaAccessDevice_Status=mediaAccessDevice_Status, softwareElement_BuildNumber=softwareElement_BuildNumber, physicalMediaEntry=physicalMediaEntry, softwareElement_IdentificationCode=softwareElement_IdentificationCode, softwareElementGroup=softwareElementGroup, physicalPackageEntry=physicalPackageEntry, mediaAccessDevice_Availability=mediaAccessDevice_Availability, softwareElement_DeviceSoftware_LogicalDeviceAssociation_ObjectT=softwareElement_DeviceSoftware_LogicalDeviceAssociation_ObjectT, physicalMediaGroup=physicalMediaGroup, physicalMedia_MediaDescription=physicalMedia_MediaDescription, UINT16=UINT16, softwareElement_Version=softwareElement_Version, physicalMedia_Removable=physicalMedia_Removable, storageLibrary_Status=storageLibrary_Status, mediaAccessDeviceGroup=mediaAccessDeviceGroup, numberOfMediaAccessDevices=numberOfMediaAccessDevices, storageLibraryGroup=storageLibraryGroup, physicalPackageIndex=physicalPackageIndex, chassis_SerialNumber=chassis_SerialNumber, productGroup=productGroup, softwareElementTable=softwareElementTable, numberOfPhysicalPackages=numberOfPhysicalPackages, physicalPackage_SerialNumber=physicalPackage_SerialNumber, softwareElementIndex=softwareElementIndex, softwareElement_CodeSet=softwareElement_CodeSet, storageLibrary_Name=storageLibrary_Name, physicalPackageTable=physicalPackageTable, numberOfSoftwareElements=numberOfSoftwareElements, UShortReal=UShortReal, UINT32=UINT32, product_IdentifyingNumber=product_IdentifyingNumber, physicalMedia_DualSided=physicalMedia_DualSided, UINT64=UINT64, product_Version=product_Version, physicalMedia_CleanerMedia=physicalMedia_CleanerMedia, softwareElement_Associations=softwareElement_Associations, chassis_Model=chassis_Model, product_Name=product_Name, smlRoot=smlRoot, smlCimVersion=smlCimVersion, chassisGroup=chassisGroup, physicalPackage_Realizes_MediaAccessDeviceIndex=physicalPackage_Realizes_MediaAccessDeviceIndex)

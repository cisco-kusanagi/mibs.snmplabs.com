#
# PySNMP MIB module NBS-EUSM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NBS-EUSM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:17:15 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
nbsCmmcPortEntry, nbs, nbsCmmcSlotEntry = mibBuilder.importSymbols("NBS-CMMC-MIB", "nbsCmmcPortEntry", "nbs", "nbsCmmcSlotEntry")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibIdentifier, Unsigned32, NotificationType, IpAddress, Integer32, iso, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, ModuleIdentity, ObjectIdentity, Gauge32, TimeTicks, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Unsigned32", "NotificationType", "IpAddress", "Integer32", "iso", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "ModuleIdentity", "ObjectIdentity", "Gauge32", "TimeTicks", "Counter64")
RowStatus, StorageType, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "StorageType", "DisplayString", "TextualConvention")
nbsEusmMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 629, 202))
if mibBuilder.loadTexts: nbsEusmMib.setLastUpdated('200710100000Z')
if mibBuilder.loadTexts: nbsEusmMib.setOrganization('MRV')
if mibBuilder.loadTexts: nbsEusmMib.setContactInfo('For technical support, please contact your service channel')
if mibBuilder.loadTexts: nbsEusmMib.setDescription('MIB for representing MRV Eusm information')
nbsEusmSlotGrp = ObjectIdentity((1, 3, 6, 1, 4, 1, 629, 202, 1))
if mibBuilder.loadTexts: nbsEusmSlotGrp.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotGrp.setDescription('Stage-II Slot context features for EUSM boards')
nbsEusmPortGrp = ObjectIdentity((1, 3, 6, 1, 4, 1, 629, 202, 2))
if mibBuilder.loadTexts: nbsEusmPortGrp.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortGrp.setDescription('Stage-II Port context featurea for EUSM boards')
nbsEusmTestGrp = ObjectIdentity((1, 3, 6, 1, 4, 1, 629, 202, 3))
if mibBuilder.loadTexts: nbsEusmTestGrp.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTestGrp.setDescription('Testing category of features for EUSM boards. The example items that may go here are the smart loopback traffic generation, loss/gain analysis, performance monitoring, etc.')
nbsEusmSlotTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 1, 1), )
if mibBuilder.loadTexts: nbsEusmSlotTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotTable.setDescription('Contains a description of slot context features applicable for the whole module. There is going to be one row for each slot. All the scalar type objects applicable at the slot context are dumped here.')
nbsEusmSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1), )
nbsCmmcSlotEntry.registerAugmentions(("NBS-EUSM-MIB", "nbsEusmSlotEntry"))
nbsEusmSlotEntry.setIndexNames(*nbsCmmcSlotEntry.getIndexNames())
if mibBuilder.loadTexts: nbsEusmSlotEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotEntry.setDescription('Contains a description of slot context features applicable for the whole module. There is going to be one row for each slot. All the scalar type objects applicable at the slot context are dumped here.')
nbsEusmSlotSupportsEusm = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notSupported", 1), ("supported", 2))).clone('notSupported')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotSupportsEusm.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotSupportsEusm.setDescription('Is EUSM config and status supported for this slot?')
nbsEusmSlotAccControlActionUntag = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("permit", 2), ("deny", 3))).clone('permit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotAccControlActionUntag.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotAccControlActionUntag.setDescription('permit(2) or deny(3) works on all untagged frames')
nbsEusmSlotAccControlActionTag = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notSupported", 1), ("denyAll", 2), ("denyVlan", 3), ("permitVlan", 4), ("permitAll", 5))).clone('permitAll')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotAccControlActionTag.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotAccControlActionTag.setDescription('denyAll(2) filters all tagged frames denyVlan(3) and permitVlan(4) work on the specified list permitAll(5) negates access control of tagged frames')
nbsEusmSlotAccControlVidList = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotAccControlVidList.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotAccControlVidList.setDescription('List of VLAN in a free format, for example 10-12 15 23-43 1000-1050 specifies 3 different ranges of vlan ids and one isolated vlan id')
nbsEusmSlotLinkAggrAdmin = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notSupported", 1), ("off", 2), ("onRandom", 3), ("onXorAll", 4), ("deprecatedonSmac", 5), ("onDmac", 6), ("onXorSd", 7), ("onIp", 8))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotLinkAggrAdmin.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotLinkAggrAdmin.setDescription('Depending on the link status of the trunk ports the Link Aggregation operational status may be different, this is why it calls for both Admin and Oper objects')
nbsEusmSlotLinkAggrOper = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notSupported", 1), ("off", 2), ("onRandom", 3), ("onXorAll", 4), ("onSmac", 5), ("onDmac", 6), ("onXorSd", 7), ("onIp", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotLinkAggrOper.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotLinkAggrOper.setDescription(' ')
nbsEusmSlotStormControlBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotStormControlBroadcast.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotStormControlBroadcast.setDescription('Units is in terms of 991 bytes , or approx 1k')
nbsEusmSlotStormControlMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotStormControlMulticast.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotStormControlMulticast.setDescription('Units is in terms of 991 bytes , or approx 1k')
nbsEusmSlotStormControlUnicast = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotStormControlUnicast.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotStormControlUnicast.setDescription('Units is in terms of 991 bytes , or approx 1k')
nbsEusmSlotStormBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotStormBurstSize.setStatus('deprecated')
if mibBuilder.loadTexts: nbsEusmSlotStormBurstSize.setDescription('**** DEPRECATED ****')
nbsEusmSlotCoSMode = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notSupported", 1), ("dscpOnly", 2), ("tagOnly", 3), ("bothTagDscp", 4), ("none", 5))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotCoSMode.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotCoSMode.setDescription('If the user selects bothTagDscp(4), and a packet arrives with both DSCP and a Vlan tag, the DSCP priority system will take precedence. tagOnly(3) will use Layer 2 Vlan Priority bits to assign a Service Level Class (SLC) to a packet and tagMappingTable information will be used. dscpOnly(2) will use Layer 3 DSCP bits to assign an SL class to a packet. dscpMappingTable information will be used')
nbsEusmSlotDscpRemark = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("enable", 2), ("disable", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotDscpRemark.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotDscpRemark.setDescription('The EUSM can be set to mark egress packets with a new DSCP. The user can set to remark egress DSCP in one of the following modes: AF or CS Remarking only applies to IPv4 or IPv6 packets. The user can define which type of incoming (ingress )DSCP frames will be remarked.Selection includes the combination of EF,AF,CS,Zero DSCP and all others.')
nbsEusmSlotDscpEgressMode = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("afMode", 2), ("csMode", 3))).clone('afMode')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotDscpEgressMode.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotDscpEgressMode.setDescription('The user can set to egress remark DSCP in one of the following modes: a) Map CoS class to AF CPs (call it AF-mode) 0: AF12 1: AF22 2: AF32 3: AF42 b) Map CoS class to Class selectors CPs (call it CS-mode) 0: 000000 1: 001000 2: 010000 3: 110000')
nbsEusmSlotDscpIngressEf = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("enable", 2), ("disable", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressEf.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressEf.setDescription('One of the five ingress options EF,AF,CS,ZERO and OTHER')
nbsEusmSlotDscpIngressAf = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("enable", 2), ("disable", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressAf.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressAf.setDescription('One of the five ingress options EF,AF,CS,ZERO and OTHER')
nbsEusmSlotDscpIngressCs = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("enable", 2), ("disable", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressCs.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressCs.setDescription('One of the five ingress options EF,AF,CS,ZERO and OTHER')
nbsEusmSlotDscpIngressZeroDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("enable", 2), ("disable", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressZeroDscp.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressZeroDscp.setDescription('One of the five ingress options EF,AF,CS,ZERO and OTHER')
nbsEusmSlotDscpIngressAllOther = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("enable", 2), ("disable", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressAllOther.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressAllOther.setDescription('One of the five ingress options EF,AF,CS,ZERO and OTHER')
nbsEusmSlotIometrix = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("off", 2), ("on", 3))).clone('notSupported')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotIometrix.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotIometrix.setDescription('Controls whether or not the EUSM should enable Iometrix Level 1 cNode agent behavior')
nbsEusmSlotManagementVid = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)).clone(4094)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotManagementVid.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotManagementVid.setDescription('VLAN Id reserved for EUSM management activities.')
nbsEusmSlotUserPortIRAdmin = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000)).clone(1000000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotUserPortIRAdmin.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotUserPortIRAdmin.setDescription('Unit is kilobits per second. This applies to all frames incoming on the user port. The actual granularity is a function of line rate: roughly 61 Kbps for 1000 Mbps, 6.1 Kbps for 100 Mbps, and 0.61 Kbps for 10 Mbps')
nbsEusmSlotUserPortIROper = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotUserPortIROper.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotUserPortIROper.setDescription('Unit is kilobits per second. This applies to all frames incoming on the user port. The actual granularity is a function of line rate: roughly 61 Kbps for 1000 Mbps, 6.1 Kbps for 100 Mbps, and 0.61 Kbps for 10 Mbps. It is based on the configured IRAdmin object modified to match the constraints of the device.')
nbsEusmSlotMaxFlowCfgSize = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 23), Integer32().clone(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotMaxFlowCfgSize.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotMaxFlowCfgSize.setDescription('Maximum number of entries in the FlowCfg table. This may vary from slot to slot if different versions of EUSM software support different table sizes.')
nbsEusmSlotMaxVlanTranSize = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 24), Integer32().clone(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotMaxVlanTranSize.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotMaxVlanTranSize.setDescription('Maximum number of entries in the VLAN Translation table. This may vary from slot to slot if different versions of EUSM software support different table sizes.')
nbsEusmSlotMaxDscpMapSize = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 25), Integer32().clone(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotMaxDscpMapSize.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotMaxDscpMapSize.setDescription('Maximum number of entries in the DSCP to SLC Priority Map table. This may vary from slot to slot if different versions of EUSM software support different table sizes.')
nbsEusmSlotMaxCosPrioSize = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 26), Integer32().clone(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotMaxCosPrioSize.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotMaxCosPrioSize.setDescription('Maximum number of entries in the VLAN CoS to SLC Priority table. This may vary from slot to slot if different versions of EUSM software support different table sizes.')
nbsEusmFlowCfgTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 1, 2), )
if mibBuilder.loadTexts: nbsEusmFlowCfgTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgTable.setDescription('A table that describes the Vlan Flow Rate Limits At the moment there is a limit of 32 entries for this table')
nbsEusmFlowCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1), ).setIndexNames((0, "NBS-EUSM-MIB", "nbsEusmFlowCfgChassis"), (0, "NBS-EUSM-MIB", "nbsEusmFlowCfgSlot"), (0, "NBS-EUSM-MIB", "nbsEusmFlowCfgVid"), (0, "NBS-EUSM-MIB", "nbsEusmFlowCfgPriority"))
if mibBuilder.loadTexts: nbsEusmFlowCfgEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgEntry.setDescription('Contains a description of a particular Vlan Flow Rate Limit information')
nbsEusmFlowCfgChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmFlowCfgChassis.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgChassis.setDescription('The index of the table to refer to Chassis')
nbsEusmFlowCfgSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmFlowCfgSlot.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgSlot.setDescription('The index of the table to refer to Slot of this EUSM')
nbsEusmFlowCfgVid = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmFlowCfgVid.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgVid.setDescription('The Vid part of the index.')
nbsEusmFlowCfgPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmFlowCfgPriority.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgPriority.setDescription("Priority part of the VLAN as index. 0(Zero) is don't care and the real priority starts 1 based.")
nbsEusmFlowCfgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmFlowCfgRowStatus.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgRowStatus.setDescription('This table RowStatus object to create, modify and delete the rows')
nbsEusmFlowCfgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmFlowCfgStorageType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgStorageType.setDescription('This table StorageType')
nbsEusmFlowCfgIRAdmin = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000)).clone(1000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmFlowCfgIRAdmin.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgIRAdmin.setDescription('Information Rate (IR) specified for the Vid and priority combo. Unit is kilobits per second. Max possible value is 4,294,967,295 which is large enough even to represent 1 Terabit communication.')
nbsEusmFlowCfgIROper = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmFlowCfgIROper.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgIROper.setDescription('Information Rate (IR) that is actually applied to the flow. Unit is kilobits per second. Max possible value is 4,294,967,295 which is large enough even to represent 1 Terabit communication.')
nbsEusmFlowCfgClearCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("idle", 2), ("inProgress", 3), ("clear", 4))).clone('idle')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmFlowCfgClearCounter.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgClearCounter.setDescription('To clear the counters for selected row')
nbsEusmFlowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 1, 3), )
if mibBuilder.loadTexts: nbsEusmFlowStatusTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowStatusTable.setDescription('A table that describes the Vlan Flow Rate Limits At the moment there is a limit of 32 entries for this table.')
nbsEusmFlowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 1, 3, 1), )
nbsEusmFlowCfgEntry.registerAugmentions(("NBS-EUSM-MIB", "nbsEusmFlowStatusEntry"))
nbsEusmFlowStatusEntry.setIndexNames(*nbsEusmFlowCfgEntry.getIndexNames())
if mibBuilder.loadTexts: nbsEusmFlowStatusEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowStatusEntry.setDescription('Contains status part of the FlowCfgTable')
nbsEusmFlowStatusRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 3, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmFlowStatusRxFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowStatusRxFrames.setDescription('Received Frames counted')
nbsEusmFlowStatusRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmFlowStatusRxOctets.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowStatusRxOctets.setDescription('Received Octets counted')
nbsEusmVidMapTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 1, 4), )
if mibBuilder.loadTexts: nbsEusmVidMapTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapTable.setDescription('A table that describes the Vlan Translation table At the moment there is a limit of 3 or 7 entries for this table')
nbsEusmVidMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 1, 4, 1), ).setIndexNames((0, "NBS-EUSM-MIB", "nbsEusmVidMapChassis"), (0, "NBS-EUSM-MIB", "nbsEusmVidMapSlot"), (0, "NBS-EUSM-MIB", "nbsEusmVidMapFromVid"))
if mibBuilder.loadTexts: nbsEusmVidMapEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapEntry.setDescription('Contains a description of a particular Vlan Translation table feature')
nbsEusmVidMapChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmVidMapChassis.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapChassis.setDescription('The index of the table to refer to Chassis')
nbsEusmVidMapSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmVidMapSlot.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapSlot.setDescription('The index of the table to refer to Slot of this EUSM')
nbsEusmVidMapFromVid = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmVidMapFromVid.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapFromVid.setDescription('The vlanTranslation index.')
nbsEusmVidMapToVid = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(100)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmVidMapToVid.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapToVid.setDescription('The vlanTranslation index.')
nbsEusmVidMapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 4, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmVidMapRowStatus.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapRowStatus.setDescription('This table RowStatus object to create, modify and delete the rows')
nbsEusmVidMapStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 4, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmVidMapStorageType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapStorageType.setDescription('This table StorageType')
nbsEusmCoSDscpMapTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 1, 5), )
if mibBuilder.loadTexts: nbsEusmCoSDscpMapTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapTable.setDescription('Only 7 possible rows in this table.It is possible to make this table without the RowStatus object as there are not going to be variable number of rows in this table. But we could define less than 7 rows. So RowStatus is added on')
nbsEusmCoSDscpMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 1, 5, 1), ).setIndexNames((0, "NBS-EUSM-MIB", "nbsEusmCoSDscpMapChassis"), (0, "NBS-EUSM-MIB", "nbsEusmCoSDscpMapSlot"), (0, "NBS-EUSM-MIB", "nbsEusmCoSDscpMapDscp"))
if mibBuilder.loadTexts: nbsEusmCoSDscpMapEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapEntry.setDescription('Ingress Tag prio is mapped to egress SL class queue or priority')
nbsEusmCoSDscpMapChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmCoSDscpMapChassis.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapChassis.setDescription('The index of the table to refer to Chassis')
nbsEusmCoSDscpMapSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmCoSDscpMapSlot.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapSlot.setDescription('The index of the table to refer to Slot of this EUSM')
nbsEusmCoSDscpMapDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmCoSDscpMapDscp.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapDscp.setDescription('DSCP range is 0..63 and since it is an index we make it 1..64 as the 1 based range')
nbsEusmCoSDscpMapSlcPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("low", 1), ("normal", 2), ("medium", 3), ("high", 4))).clone('low')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmCoSDscpMapSlcPrio.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapSlcPrio.setDescription('Service Level Class Priority has 4 queues. Each ingress packet is assigned a Diffserv Service Level Class as part of the ingress traffic process. A packet can be forwarded to any one of 4 hardware egress packet queues of a port according to the packet SL class.')
nbsEusmCoSDscpMapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 5, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmCoSDscpMapRowStatus.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapRowStatus.setDescription('This table RowStatus object to create, modify and delete the rows')
nbsEusmCoSDscpMapStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 5, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmCoSDscpMapStorageType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapStorageType.setDescription('This table StorageType')
nbsEusmCoSTagPrioMapTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 1, 6), )
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapTable.setDescription('Only 8 rows in this table. It is a fixed size table because rows for all values of the table index Priority object must be defined in the configured device.')
nbsEusmCoSTagPrioMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 1, 6, 1), ).setIndexNames((0, "NBS-EUSM-MIB", "nbsEusmCoSTagPrioMapChassis"), (0, "NBS-EUSM-MIB", "nbsEusmCoSTagPrioMapSlot"), (0, "NBS-EUSM-MIB", "nbsEusmCoSTagPrioMapPriority"))
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapEntry.setDescription('Ingress Tag priority is mapped to egress Service Level class queue or priority.')
nbsEusmCoSTagPrioMapChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapChassis.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapChassis.setDescription('The index of the table to refer to Chassis')
nbsEusmCoSTagPrioMapSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapSlot.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapSlot.setDescription('The index of the table to refer to Slot of this EUSM')
nbsEusmCoSTagPrioMapPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapPriority.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapPriority.setDescription('Tag priority range is 0..7.')
nbsEusmCoSTagPrioMapSlcPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("low", 1), ("normal", 2), ("medium", 3), ("high", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapSlcPrio.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapSlcPrio.setDescription('Service Level Class Priority has 4 queues. Each ingress packet is assigned a Diffserv Service Level Class as part of the ingress traffic process. A packet can be forwarded to any one of 4 hardware egress packet queues of a port according to the packet SL class.')
nbsEusmPortTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 2, 1), )
if mibBuilder.loadTexts: nbsEusmPortTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortTable.setDescription('Contains a description of Port context features applicable There is going to be one row for each port. All the scalar type objects applicable at the port context are dumped here.')
nbsEusmPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1), )
nbsCmmcPortEntry.registerAugmentions(("NBS-EUSM-MIB", "nbsEusmPortEntry"))
nbsEusmPortEntry.setIndexNames(*nbsCmmcPortEntry.getIndexNames())
if mibBuilder.loadTexts: nbsEusmPortEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortEntry.setDescription('Contains a description of slot context features applicable for the whole module. There is going to be one row for each slot. All the scalar type objects applicable at the slot context are dumped here.')
nbsEusmPortSupportsEusm = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notSupported", 1), ("supported", 2))).clone('notSupported')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPortSupportsEusm.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortSupportsEusm.setDescription('Is EUSM config and status supported for this slot?')
nbsEusmPortSmartLoopbackAction = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notSupported", 1), ("off", 2), ("all", 3), ("onDA", 4), ("onVid", 5), ("onBoth", 6), ("mac", 7))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackAction.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackAction.setDescription(' ')
nbsEusmPortSmartLoopbackSwap = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("off", 2), ("on", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackSwap.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackSwap.setDescription(' ')
nbsEusmPortSmartLoopbackMac = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackMac.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackMac.setDescription(' ')
nbsEusmPortSmartLoopbackVid = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackVid.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackVid.setDescription(' ')
nbsEusmPortVlanTagAction = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("add", 2), ("strip", 3), ("ignore", 4))).clone('ignore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmPortVlanTagAction.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortVlanTagAction.setDescription('add(2) need two more arguments s-vlanId and s-vlan-priority strip(3)and ignore(4) does not need any argument')
nbsEusmPortVlanTagVid = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmPortVlanTagVid.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortVlanTagVid.setDescription('need to be specified when VlanTagAction is add(2)')
nbsEusmPortVlanTagPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmPortVlanTagPriority.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortVlanTagPriority.setDescription('need to be specified when VlanTagAction is add(2)')
nbsEusmTgaTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 3, 1), )
if mibBuilder.loadTexts: nbsEusmTgaTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaTable.setDescription('Contains a description of Test context features applicable. There is going to be one row for each port.')
nbsEusmTgaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1), )
nbsCmmcPortEntry.registerAugmentions(("NBS-EUSM-MIB", "nbsEusmTgaEntry"))
nbsEusmTgaEntry.setIndexNames(*nbsCmmcPortEntry.getIndexNames())
if mibBuilder.loadTexts: nbsEusmTgaEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaEntry.setDescription('Contains a description of slot context features applicable for the whole module. There is going to be one row for each port.')
nbsEusmTgaDa = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaDa.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaDa.setDescription('Destination Address - MAC address')
nbsEusmTgaDaType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("random", 2), ("fixed", 3), ("increment", 4))).clone('random')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaDaType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaDaType.setDescription('Different options to specify the Destination Address')
nbsEusmTgaSa = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaSa.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaSa.setDescription('Source Address - MAC address')
nbsEusmTgaSaType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("random", 2), ("fixed", 3), ("increment", 4))).clone('random')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaSaType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaSaType.setDescription('Different options to specify the Source Address')
nbsEusmTgaTag = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4).clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaTag.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaTag.setDescription('VLAN tag or e-type plus initial data If VLAN tagging is not specified (i.e. Tag does not begin as 81-00), then the first two bytes of Tag define the frame type, and the last two Tag bytes are the first two data bytes')
nbsEusmTgaTagType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("random", 2), ("fixed", 3), ("increment", 4))).clone('random')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaTagType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaTagType.setDescription('Different options to specify the Tag')
nbsEusmTgaPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2).clone(hexValue="0000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaPattern.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaPattern.setDescription('The two Pattern bytes are replicated as needed to fill-out the frame to the specified size')
nbsEusmTgaPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("random", 2), ("fixed", 3))).clone('random')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaPatternType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaPatternType.setDescription('Different options to specify the Source Address')
nbsEusmTgaFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 9600)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaFrameSize.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaFrameSize.setDescription('Frame Size range from 64 to 9600')
nbsEusmTgaFrameSizeType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("random", 2), ("fixed", 3))).clone('fixed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaFrameSizeType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaFrameSizeType.setDescription('Different options to specify the Frame Size')
nbsEusmTgaFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967294)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaFrameCount.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaFrameCount.setDescription(' ')
nbsEusmTgaFrameCountType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("continuous", 2), ("fixed", 3))).clone('continuous')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaFrameCountType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaFrameCountType.setDescription('Different options to specify the Frame Size')
nbsEusmTgaInterPacketGap = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(12, 134217727)).clone(1249928)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaInterPacketGap.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaInterPacketGap.setDescription('Rate Control - only option is fixed. Default is 1249928. This sets an approx rate of 100/10/1 fps at 1000/100/10 Mbps. Number of bytes between frames. Controls traffic rate')
nbsEusmTgaAction = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("start", 2), ("stop", 3))).clone('stop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaAction.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaAction.setDescription('Different actions to activate the traffic generation. There are three frame generation activities: specify, start, and stop. Specifying and actually starting traffic may be done together or separately. In fact, it is reasonable to specify once, then start (and stop) many times.')
nbsEusmCableTestTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 3, 2), )
if mibBuilder.loadTexts: nbsEusmCableTestTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCableTestTable.setDescription('Cable testing feature')
nbsEusmCableTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 3, 2, 1), )
nbsCmmcPortEntry.registerAugmentions(("NBS-EUSM-MIB", "nbsEusmCableTestEntry"))
nbsEusmCableTestEntry.setIndexNames(*nbsCmmcPortEntry.getIndexNames())
if mibBuilder.loadTexts: nbsEusmCableTestEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCableTestEntry.setDescription('Cable testing feature')
nbsEusmCableTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notSupported", 1), ("testStart", 2), ("testInProgress", 3), ("testCompleted", 4), ("testIdle", 5))).clone('testIdle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmCableTestStatus.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCableTestStatus.setDescription('To initiate and get the status of the cable test feature. It is applicable only to copper ports. In the future we may have multiple copper ports. A GET on this object will show testIdle if a test has never been run, or testCompleted(4) if it has. When testStart(2) is SET, for a short time of about 3 seconds you would expect to see testInProgress(3). Time-stamp of the test start will be sent by the SNMP agent to the line-card to keep track of the time instance of the test.')
nbsEusmCableTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmCableTestResult.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCableTestResult.setDescription('This string will give out the result of the cable test done with a time stamp that gives the indication as to when the CableTest was initiated. This also gives the result for all the 4 pairs of wire. Possible results status includes invalid, good, mismatch short and open. When the status is mismatch, short or open, there will be length indicating more information about the location of the fault. From the LNXNM point of view it is easy to deal with scalars than tables - so this is made into DisplayString. Since the MVs use it read-only and display anyway, it is probably simpler to deal with scalar display string rather than table. An example TestResult may look like the following <time-stamp>pair-1 good,pair-2 invalid,pair-3 open at 25 meters,pair-4 good.')
nbsEusmLgaTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 3, 3), )
if mibBuilder.loadTexts: nbsEusmLgaTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaTable.setDescription('Contains a description of Traffic discrepancy counters.')
nbsEusmLgaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1), )
nbsCmmcSlotEntry.registerAugmentions(("NBS-EUSM-MIB", "nbsEusmLgaEntry"))
nbsEusmLgaEntry.setIndexNames(*nbsCmmcSlotEntry.getIndexNames())
if mibBuilder.loadTexts: nbsEusmLgaEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaEntry.setDescription('Discrepancy entry')
nbsEusmLgaRdAllFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdAllFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdAllFrames.setDescription('The count of all frames (good+bad) lost/gained (-/+) in the most recent interval. Not supported value: 0x80000000')
nbsEusmLgaRducFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRducFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRducFrames.setDescription('The count of good unicast frames lost/gained (-/+) in the most recent interval. Not supported value: 0x80000000')
nbsEusmLgaRdmcFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdmcFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdmcFrames.setDescription('The count of good multicast frames lost/gained (-/+) in the most recent interval. Not supported value: 0x80000000')
nbsEusmLgaRdbcFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdbcFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdbcFrames.setDescription('The count of good broadcast frames lost/gained (-/+) in the most recent interval. Not supported value: 0x80000000')
nbsEusmLgaRdSize64 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSize64.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSize64.setDescription('The count of all 64 byte frames lost/gained (-/+) in the most recent interval. Not supported value: 0x80000000')
nbsEusmLgaRdSizeMax127 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax127.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax127.setDescription('The count of all 65-127 byte frames lost/gained (-/+) in the most recent interval. Not supported value: 0x80000000')
nbsEusmLgaRdSizeMax255 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax255.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax255.setDescription('The count of all 128-255 byte frames lost/gained (-/+) in the most recent interval. Not supported value: 0x80000000')
nbsEusmLgaRdSizeMax511 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax511.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax511.setDescription('The count of all 256-511 byte frames lost/gained (-/+) in the most recent interval. Not supported value: 0x80000000')
nbsEusmLgaRdSizeMax1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax1023.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax1023.setDescription('The count of all 512-1023 byte frames lost/gained (-/+) in the most recent interval. Not supported value: 0x80000000')
nbsEusmLgaRdSizeMax1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax1518.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax1518.setDescription('The count of all 1024-1518 byte frames lost/gained (-/+) in the most recent interval. Not supported value: 0x80000000')
nbsEusmLgaRdSizeMax2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax2047.setDescription('The count of all 1519-2047 byte frames lost/gained (-/+) in the most recent interval. Not supported value: 0x80000000')
nbsEusmLgaRdSizeOvr2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSizeOvr2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSizeOvr2047.setDescription('The count of all 2048-plus byte frames lost/gained (-/+) in the most recent interval. Not supported value: 0x80000000')
nbsEusmLgaRdFrameDivisor = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdFrameDivisor.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdFrameDivisor.setDescription('The divisor to calculate frame loss/gain ratios for the most recent interval.')
nbsEusmLgaRdAllOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdAllOctets.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdAllOctets.setDescription('The count of all frame octets lost/gained (-/+) in the most recent interval. Not supported value: 0x80000000')
nbsEusmLgaRdOctetDivisor = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdOctetDivisor.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdOctetDivisor.setDescription('The divisor to calculate octet loss/gain ratios for the most recent interval.')
nbsEusmLgaRdTimeSpan = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdTimeSpan.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdTimeSpan.setDescription('The time span (tenths of a sec) for the most recent interval.')
nbsEusmLgaAdAllFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdAllFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdAllFrames.setDescription('The accumulated count of all frames (good+bad) lost/gained (-/+) over all intervals. Not supported value: 0x80000000')
nbsEusmLgaAducFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAducFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAducFrames.setDescription('The accumulated count of good unicast frames lost/gained (-/+) over all intervals. Not supported value: 0x80000000')
nbsEusmLgaAdmcFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdmcFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdmcFrames.setDescription('The accumulated count of good multicast frames lost/gained (-/+) over all intervals. Not supported value: 0x80000000')
nbsEusmLgaAdbcFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdbcFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdbcFrames.setDescription('The accumulated count of good broadcast frames lost/gained (-/+) over all intervals. Not supported value: 0x80000000')
nbsEusmLgaAdSize64 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSize64.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSize64.setDescription('The accumulated count of all 64 byte frames lost/gained (-/+) over all intervals. Not supported value: 0x80000000')
nbsEusmLgaAdSizeMax127 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax127.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax127.setDescription('The accumulated count of all 65-127 byte frames lost/gained (-/+) over all intervals. Not supported value: 0x80000000')
nbsEusmLgaAdSizeMax255 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax255.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax255.setDescription('The accumulated count of all 128-255 byte frames lost/gained (-/+) over all intervals. Not supported value: 0x80000000')
nbsEusmLgaAdSizeMax511 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax511.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax511.setDescription('The accumulated count of all 256-511 byte frames lost/gained (-/+) over all intervals. Not supported value: 0x80000000')
nbsEusmLgaAdSizeMax1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax1023.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax1023.setDescription('The accumulated count of all 512-1023 byte frames lost/gained (-/+) over all intervals. Not supported value: 0x80000000')
nbsEusmLgaAdSizeMax1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax1518.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax1518.setDescription('The accumulated count of all 1024-1518 byte frames lost/gained (-/+) over all intervals. Not supported value: 0x80000000')
nbsEusmLgaAdSizeMax2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax2047.setDescription('The accumulated count of all 1519-2047 byte frames lost/gained (-/+) over all intervals. Not supported value: 0x80000000')
nbsEusmLgaAdSizeOvr2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSizeOvr2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSizeOvr2047.setDescription('The accumulated count of all 2048-plus byte frames lost/gained (-/+) over all intervals. Not supported value: 0x80000000')
nbsEusmLgaAdFrameDivisor = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 29), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdFrameDivisor.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdFrameDivisor.setDescription('The divisor to calculate frame loss/gain ratios over all intervals.')
nbsEusmLgaAdAllOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdAllOctets.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdAllOctets.setDescription('The accumulated count of all frame octets lost/gained (-/+) over all intervals. Not supported value: 0x80000000')
nbsEusmLgaAdOctetDivisor = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 31), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdOctetDivisor.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdOctetDivisor.setDescription('The divisor to calculate octet loss/gain ratios over all intervals.')
nbsEusmLgaAdTimeSpan = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 32), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdTimeSpan.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdTimeSpan.setDescription('The accumulated time span (tenths of a sec) for all intervals.')
nbsEusmSlotLgaInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 86400)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotLgaInterval.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotLgaInterval.setDescription('Traffic Analysis (loss/gain) sampling time interval (sec). Practical range allowed is 10 seconds to 1 day.')
nbsEusmSlotLgaAction = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notSupported", 1), ("inactive", 2), ("start", 3), ("stop", 4), ("inProgress", 5))).clone('notSupported')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotLgaAction.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotLgaAction.setDescription('Traffic Analysis (loss/gain) activity status.')
nbsEusmPmTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 3, 4), )
if mibBuilder.loadTexts: nbsEusmPmTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmTable.setDescription('Contains a description of Traffic discrepancy counters.')
nbsEusmPmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1), )
nbsCmmcSlotEntry.registerAugmentions(("NBS-EUSM-MIB", "nbsEusmPmEntry"))
nbsEusmPmEntry.setIndexNames(*nbsCmmcSlotEntry.getIndexNames())
if mibBuilder.loadTexts: nbsEusmPmEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmEntry.setDescription('Performance Monitoring entry')
nbsEusmPmAvgAllSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvgAllSizes.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvgAllSizes.setDescription('The average transit time (nanosec) for monitored frames.')
nbsEusmPmAvg64 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvg64.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvg64.setDescription('The average transit time (nanosec) for monitored 64 byte frames.')
nbsEusmPmAvg127 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvg127.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvg127.setDescription('The average transit time (nanosec) for monitored 65-127 byte frames.')
nbsEusmPmAvg255 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvg255.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvg255.setDescription('The average transit time (nanosec) for monitored 128-255 byte frames.')
nbsEusmPmAvg511 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvg511.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvg511.setDescription('The average transit time (nanosec) for monitored 256-511 byte frames.')
nbsEusmPmAvg1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvg1023.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvg1023.setDescription('The average transit time (nanosec) for monitored 512-1023 byte frames.')
nbsEusmPmAvg1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvg1518.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvg1518.setDescription('The average transit time (nanosec) for monitored 1024-1518 byte frames.')
nbsEusmPmAvg2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvg2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvg2047.setDescription('The average transit time (nanosec) for monitored 1519-2047 byte frames.')
nbsEusmPmAvgOvr2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvgOvr2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvgOvr2047.setDescription('The average transit time (nanosec) for monitored 2048-plus byte frames.')
nbsEusmPmMinAllSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMinAllSizes.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMinAllSizes.setDescription('The minimum transit time (nanosec) for monitored frames.')
nbsEusmPmMin64 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMin64.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMin64.setDescription('The minimum transit time (nanosec) for monitored 64 byte frames.')
nbsEusmPmMin127 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMin127.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMin127.setDescription('The minimum transit time (nanosec) for monitored 65-127 byte frames.')
nbsEusmPmMin255 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMin255.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMin255.setDescription('The minimum transit time (nanosec) for monitored 128-255 byte frames.')
nbsEusmPmMin511 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMin511.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMin511.setDescription('The minimum transit time (nanosec) for monitored 256-511 byte frames.')
nbsEusmPmMin1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMin1023.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMin1023.setDescription('The minimum transit time (nanosec) for monitored 512-1023 byte frames.')
nbsEusmPmMin1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMin1518.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMin1518.setDescription('The minimum transit time (nanosec) for monitored 1024-1518 byte frames.')
nbsEusmPmMin2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMin2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMin2047.setDescription('The minimum transit time (nanosec) for monitored 1519-2047 byte frames.')
nbsEusmPmMinOvr2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMinOvr2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMinOvr2047.setDescription('The minimum transit time (nanosec) for monitored 2048-plus byte frames.')
nbsEusmPmMaxAllSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMaxAllSizes.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMaxAllSizes.setDescription('The maximum transit time (nanosec) for monitored frames.')
nbsEusmPmMax64 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMax64.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMax64.setDescription('The maximum transit time (nanosec) for monitored 64 byte frames.')
nbsEusmPmMax127 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMax127.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMax127.setDescription('The maximum transit time (nanosec) for monitored 65-127 byte frames.')
nbsEusmPmMax255 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMax255.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMax255.setDescription('The maximum transit time (nanosec) for monitored 128-255 byte frames.')
nbsEusmPmMax511 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMax511.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMax511.setDescription('The maximum transit time (nanosec) for monitored 256-511 byte frames.')
nbsEusmPmMax1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMax1023.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMax1023.setDescription('The maximum transit time (nanosec) for monitored 512-1023 byte frames.')
nbsEusmPmMax1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMax1518.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMax1518.setDescription('The maximum transit time (nanosec) for monitored 1024-1518 byte frames.')
nbsEusmPmMax2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMax2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMax2047.setDescription('The maximum transit time (nanosec) for monitored 1519-2047 byte frames.')
nbsEusmPmMaxOvr2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMaxOvr2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMaxOvr2047.setDescription('The maximum transit time (nanosec) for monitored 2048-plus byte frames.')
nbsEusmPmFramesAllSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 28), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFramesAllSizes.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFramesAllSizes.setDescription('The count of all monitored frames.')
nbsEusmPmFrames64 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 29), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFrames64.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFrames64.setDescription('The count of all monitored 64 byte frames.')
nbsEusmPmFrames127 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 30), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFrames127.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFrames127.setDescription('The count of all monitored 65-127 byte frames.')
nbsEusmPmFrames255 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 31), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFrames255.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFrames255.setDescription('The count of all monitored 128-255 byte frames.')
nbsEusmPmFrames511 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 32), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFrames511.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFrames511.setDescription('The count of all monitored 256-511 byte frames.')
nbsEusmPmFrames1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 33), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFrames1023.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFrames1023.setDescription('The count of all monitored 512-1023 byte frames.')
nbsEusmPmFrames1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 34), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFrames1518.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFrames1518.setDescription('The count of all monitored 1024-1518 byte frames.')
nbsEusmPmFrames2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 35), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFrames2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFrames2047.setDescription('The count of all monitored 1519-2047 byte frames.')
nbsEusmPmFramesOvr2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 36), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFramesOvr2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFramesOvr2047.setDescription('The count of all monitored 2048-plus byte frames.')
nbsEusmPmOctetsAllSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 37), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctetsAllSizes.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctetsAllSizes.setDescription('The count of octets in all monitored frames.')
nbsEusmPmOctets64 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 38), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctets64.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctets64.setDescription('The count of octets in all monitored 64 byte frames.')
nbsEusmPmOctets127 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 39), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctets127.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctets127.setDescription('The count of octets in all monitored 65-127 byte frames.')
nbsEusmPmOctets255 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 40), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctets255.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctets255.setDescription('The count of octets in all monitored 128-255 byte frames.')
nbsEusmPmOctets511 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 41), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctets511.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctets511.setDescription('The count of octets in all monitored 256-511 byte frames.')
nbsEusmPmOctets1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 42), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctets1023.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctets1023.setDescription('The count of octets in all monitored 512-1023 byte frames.')
nbsEusmPmOctets1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 43), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctets1518.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctets1518.setDescription('The count of octets in all monitored 1024-1518 byte frames.')
nbsEusmPmOctets2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 44), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctets2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctets2047.setDescription('The count of octets in all monitored 1519-2047 byte frames.')
nbsEusmPmOctetsOvr2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 45), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctetsOvr2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctetsOvr2047.setDescription('The count of octets in all monitored 2048-plus byte frames.')
nbsEusmSlotPmInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 604800)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotPmInterval.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotPmInterval.setDescription('Performance Monitoring time duration (sec). Practical range allowed is 1 minute to 1 week.')
nbsEusmSlotPmSelector = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notSupported", 1), ("coToCpe", 2), ("cpeToCo", 3), ("cpeTx", 4), ("cpeRx", 5))).clone('notSupported')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotPmSelector.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotPmSelector.setDescription("Performance Monitoring traffic direction selector. coToCpe(2) measures from CO's active trunk port to CPE's active trunk port. cpeToCo(3) measures from CPE's active trunk port to CO's active trunk port. To measure from one CPE to another, the user should designate the source CPE as cpeTx(4) and the destination CPE as cpeRx(5). The reflector CPE must be activated before the source CPE.")
nbsEusmSlotPmAction = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notSupported", 1), ("inactive", 2), ("start", 3), ("stop", 4), ("inProgress", 5), ("complete", 6), ("stopping", 7))).clone('notSupported')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotPmAction.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotPmAction.setDescription('Traffic Analysis (performance monitoring) activity status.')
nbsEusmSlotPmCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 49), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotPmCapabilities.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotPmCapabilities.setDescription('This bitmask indicates which performance monitoring selectors this slot can support. This object is mandatory for all slots in systems where the nbsEusmSlotPmSelector object is supported. Each capability is represented by one bit. Set bit to 1 to advertise capability, 0 to deny it. Capability Bit -------------- --- reserved 0 notSupported 1 coToCpe 2 cpeToCo 3 cpeTx 4 cpeRx 5 OCTET STRING bitmasks count the leftmost bit (MSB) as 0. A zero length OCTET STRING indicates that this object is not supported.')
mibBuilder.exportSymbols("NBS-EUSM-MIB", nbsEusmPortSmartLoopbackMac=nbsEusmPortSmartLoopbackMac, nbsEusmLgaAdTimeSpan=nbsEusmLgaAdTimeSpan, nbsEusmPmFrames511=nbsEusmPmFrames511, nbsEusmLgaAdbcFrames=nbsEusmLgaAdbcFrames, nbsEusmSlotLgaAction=nbsEusmSlotLgaAction, nbsEusmPmEntry=nbsEusmPmEntry, nbsEusmFlowCfgClearCounter=nbsEusmFlowCfgClearCounter, nbsEusmLgaAdAllOctets=nbsEusmLgaAdAllOctets, nbsEusmCoSTagPrioMapEntry=nbsEusmCoSTagPrioMapEntry, nbsEusmFlowStatusEntry=nbsEusmFlowStatusEntry, nbsEusmPmOctetsAllSizes=nbsEusmPmOctetsAllSizes, nbsEusmSlotDscpIngressAllOther=nbsEusmSlotDscpIngressAllOther, nbsEusmVidMapSlot=nbsEusmVidMapSlot, nbsEusmSlotPmAction=nbsEusmSlotPmAction, nbsEusmSlotLinkAggrOper=nbsEusmSlotLinkAggrOper, nbsEusmLgaAdSizeMax255=nbsEusmLgaAdSizeMax255, nbsEusmSlotLgaInterval=nbsEusmSlotLgaInterval, nbsEusmSlotUserPortIROper=nbsEusmSlotUserPortIROper, nbsEusmCoSDscpMapTable=nbsEusmCoSDscpMapTable, nbsEusmPmAvg2047=nbsEusmPmAvg2047, nbsEusmPmMin64=nbsEusmPmMin64, nbsEusmPmMaxAllSizes=nbsEusmPmMaxAllSizes, nbsEusmCoSDscpMapStorageType=nbsEusmCoSDscpMapStorageType, nbsEusmPmMin127=nbsEusmPmMin127, nbsEusmPmMin255=nbsEusmPmMin255, nbsEusmLgaRdAllOctets=nbsEusmLgaRdAllOctets, nbsEusmPmMax127=nbsEusmPmMax127, nbsEusmPmAvg64=nbsEusmPmAvg64, nbsEusmCableTestEntry=nbsEusmCableTestEntry, nbsEusmSlotTable=nbsEusmSlotTable, nbsEusmPmMinOvr2047=nbsEusmPmMinOvr2047, nbsEusmSlotPmInterval=nbsEusmSlotPmInterval, nbsEusmPortVlanTagAction=nbsEusmPortVlanTagAction, nbsEusmPmMin1023=nbsEusmPmMin1023, nbsEusmSlotDscpIngressZeroDscp=nbsEusmSlotDscpIngressZeroDscp, nbsEusmSlotMaxCosPrioSize=nbsEusmSlotMaxCosPrioSize, nbsEusmVidMapEntry=nbsEusmVidMapEntry, nbsEusmTgaTable=nbsEusmTgaTable, nbsEusmCableTestTable=nbsEusmCableTestTable, nbsEusmLgaRducFrames=nbsEusmLgaRducFrames, nbsEusmTgaPattern=nbsEusmTgaPattern, nbsEusmSlotSupportsEusm=nbsEusmSlotSupportsEusm, nbsEusmLgaEntry=nbsEusmLgaEntry, nbsEusmVidMapTable=nbsEusmVidMapTable, nbsEusmPmAvg1518=nbsEusmPmAvg1518, nbsEusmPmFrames1023=nbsEusmPmFrames1023, nbsEusmLgaAdFrameDivisor=nbsEusmLgaAdFrameDivisor, nbsEusmTgaAction=nbsEusmTgaAction, nbsEusmTgaDaType=nbsEusmTgaDaType, nbsEusmLgaAdSizeOvr2047=nbsEusmLgaAdSizeOvr2047, nbsEusmLgaAdSizeMax127=nbsEusmLgaAdSizeMax127, nbsEusmSlotStormBurstSize=nbsEusmSlotStormBurstSize, nbsEusmSlotEntry=nbsEusmSlotEntry, nbsEusmVidMapRowStatus=nbsEusmVidMapRowStatus, nbsEusmCoSDscpMapChassis=nbsEusmCoSDscpMapChassis, nbsEusmPmMax511=nbsEusmPmMax511, nbsEusmPortSmartLoopbackAction=nbsEusmPortSmartLoopbackAction, nbsEusmLgaAdmcFrames=nbsEusmLgaAdmcFrames, nbsEusmPmMin511=nbsEusmPmMin511, PYSNMP_MODULE_ID=nbsEusmMib, nbsEusmLgaRdOctetDivisor=nbsEusmLgaRdOctetDivisor, nbsEusmSlotDscpEgressMode=nbsEusmSlotDscpEgressMode, nbsEusmTgaInterPacketGap=nbsEusmTgaInterPacketGap, nbsEusmCoSTagPrioMapSlcPrio=nbsEusmCoSTagPrioMapSlcPrio, nbsEusmPmMax64=nbsEusmPmMax64, nbsEusmTgaFrameSize=nbsEusmTgaFrameSize, nbsEusmLgaAdSizeMax1518=nbsEusmLgaAdSizeMax1518, nbsEusmSlotDscpIngressEf=nbsEusmSlotDscpIngressEf, nbsEusmPortGrp=nbsEusmPortGrp, nbsEusmSlotDscpIngressAf=nbsEusmSlotDscpIngressAf, nbsEusmCableTestStatus=nbsEusmCableTestStatus, nbsEusmLgaRdSizeMax127=nbsEusmLgaRdSizeMax127, nbsEusmLgaAdOctetDivisor=nbsEusmLgaAdOctetDivisor, nbsEusmPmMax1518=nbsEusmPmMax1518, nbsEusmPmOctets1023=nbsEusmPmOctets1023, nbsEusmPmOctetsOvr2047=nbsEusmPmOctetsOvr2047, nbsEusmLgaRdSizeMax255=nbsEusmLgaRdSizeMax255, nbsEusmTgaDa=nbsEusmTgaDa, nbsEusmPmAvgAllSizes=nbsEusmPmAvgAllSizes, nbsEusmSlotCoSMode=nbsEusmSlotCoSMode, nbsEusmSlotAccControlActionUntag=nbsEusmSlotAccControlActionUntag, nbsEusmPmOctets1518=nbsEusmPmOctets1518, nbsEusmPmOctets2047=nbsEusmPmOctets2047, nbsEusmFlowCfgStorageType=nbsEusmFlowCfgStorageType, nbsEusmTgaFrameCount=nbsEusmTgaFrameCount, nbsEusmPmOctets127=nbsEusmPmOctets127, nbsEusmSlotPmSelector=nbsEusmSlotPmSelector, nbsEusmCoSTagPrioMapTable=nbsEusmCoSTagPrioMapTable, nbsEusmPmTable=nbsEusmPmTable, nbsEusmPmAvg511=nbsEusmPmAvg511, nbsEusmPmFrames127=nbsEusmPmFrames127, nbsEusmMib=nbsEusmMib, nbsEusmTgaTagType=nbsEusmTgaTagType, nbsEusmSlotMaxDscpMapSize=nbsEusmSlotMaxDscpMapSize, nbsEusmLgaAducFrames=nbsEusmLgaAducFrames, nbsEusmTgaEntry=nbsEusmTgaEntry, nbsEusmSlotMaxFlowCfgSize=nbsEusmSlotMaxFlowCfgSize, nbsEusmPmAvg1023=nbsEusmPmAvg1023, nbsEusmLgaAdSizeMax2047=nbsEusmLgaAdSizeMax2047, nbsEusmSlotDscpRemark=nbsEusmSlotDscpRemark, nbsEusmPmFrames2047=nbsEusmPmFrames2047, nbsEusmFlowCfgIROper=nbsEusmFlowCfgIROper, nbsEusmPmFrames1518=nbsEusmPmFrames1518, nbsEusmFlowCfgVid=nbsEusmFlowCfgVid, nbsEusmPmMin2047=nbsEusmPmMin2047, nbsEusmPmFrames255=nbsEusmPmFrames255, nbsEusmSlotIometrix=nbsEusmSlotIometrix, nbsEusmVidMapFromVid=nbsEusmVidMapFromVid, nbsEusmVidMapStorageType=nbsEusmVidMapStorageType, nbsEusmLgaAdSize64=nbsEusmLgaAdSize64, nbsEusmSlotStormControlBroadcast=nbsEusmSlotStormControlBroadcast, nbsEusmPortVlanTagVid=nbsEusmPortVlanTagVid, nbsEusmCoSDscpMapEntry=nbsEusmCoSDscpMapEntry, nbsEusmFlowCfgRowStatus=nbsEusmFlowCfgRowStatus, nbsEusmCableTestResult=nbsEusmCableTestResult, nbsEusmCoSDscpMapSlot=nbsEusmCoSDscpMapSlot, nbsEusmPortVlanTagPriority=nbsEusmPortVlanTagPriority, nbsEusmFlowCfgPriority=nbsEusmFlowCfgPriority, nbsEusmPmMax2047=nbsEusmPmMax2047, nbsEusmCoSTagPrioMapChassis=nbsEusmCoSTagPrioMapChassis, nbsEusmLgaRdSize64=nbsEusmLgaRdSize64, nbsEusmFlowCfgTable=nbsEusmFlowCfgTable, nbsEusmLgaRdAllFrames=nbsEusmLgaRdAllFrames, nbsEusmFlowCfgChassis=nbsEusmFlowCfgChassis, nbsEusmTgaPatternType=nbsEusmTgaPatternType, nbsEusmPmFramesOvr2047=nbsEusmPmFramesOvr2047, nbsEusmPortTable=nbsEusmPortTable, nbsEusmPmFrames64=nbsEusmPmFrames64, nbsEusmVidMapChassis=nbsEusmVidMapChassis, nbsEusmPortSmartLoopbackSwap=nbsEusmPortSmartLoopbackSwap, nbsEusmLgaRdTimeSpan=nbsEusmLgaRdTimeSpan, nbsEusmLgaRdbcFrames=nbsEusmLgaRdbcFrames, nbsEusmSlotLinkAggrAdmin=nbsEusmSlotLinkAggrAdmin, nbsEusmPmOctets255=nbsEusmPmOctets255, nbsEusmTestGrp=nbsEusmTestGrp, nbsEusmSlotAccControlActionTag=nbsEusmSlotAccControlActionTag, nbsEusmCoSTagPrioMapSlot=nbsEusmCoSTagPrioMapSlot, nbsEusmLgaAdSizeMax511=nbsEusmLgaAdSizeMax511, nbsEusmLgaAdAllFrames=nbsEusmLgaAdAllFrames, nbsEusmCoSDscpMapDscp=nbsEusmCoSDscpMapDscp, nbsEusmLgaRdSizeMax511=nbsEusmLgaRdSizeMax511, nbsEusmLgaRdSizeMax1518=nbsEusmLgaRdSizeMax1518, nbsEusmSlotUserPortIRAdmin=nbsEusmSlotUserPortIRAdmin, nbsEusmPmAvg127=nbsEusmPmAvg127, nbsEusmTgaSa=nbsEusmTgaSa, nbsEusmTgaTag=nbsEusmTgaTag, nbsEusmPmMaxOvr2047=nbsEusmPmMaxOvr2047, nbsEusmSlotMaxVlanTranSize=nbsEusmSlotMaxVlanTranSize, nbsEusmSlotStormControlUnicast=nbsEusmSlotStormControlUnicast, nbsEusmSlotManagementVid=nbsEusmSlotManagementVid, nbsEusmCoSTagPrioMapPriority=nbsEusmCoSTagPrioMapPriority, nbsEusmCoSDscpMapSlcPrio=nbsEusmCoSDscpMapSlcPrio, nbsEusmLgaRdSizeMax1023=nbsEusmLgaRdSizeMax1023, nbsEusmPmFramesAllSizes=nbsEusmPmFramesAllSizes, nbsEusmSlotPmCapabilities=nbsEusmSlotPmCapabilities, nbsEusmSlotStormControlMulticast=nbsEusmSlotStormControlMulticast, nbsEusmFlowStatusTable=nbsEusmFlowStatusTable, nbsEusmFlowStatusRxFrames=nbsEusmFlowStatusRxFrames, nbsEusmPmMinAllSizes=nbsEusmPmMinAllSizes, nbsEusmFlowStatusRxOctets=nbsEusmFlowStatusRxOctets, nbsEusmCoSDscpMapRowStatus=nbsEusmCoSDscpMapRowStatus, nbsEusmLgaTable=nbsEusmLgaTable, nbsEusmPmMax1023=nbsEusmPmMax1023, nbsEusmPortSupportsEusm=nbsEusmPortSupportsEusm, nbsEusmPortEntry=nbsEusmPortEntry, nbsEusmTgaFrameSizeType=nbsEusmTgaFrameSizeType, nbsEusmPmMax255=nbsEusmPmMax255, nbsEusmTgaFrameCountType=nbsEusmTgaFrameCountType, nbsEusmPmMin1518=nbsEusmPmMin1518, nbsEusmLgaAdSizeMax1023=nbsEusmLgaAdSizeMax1023, nbsEusmLgaRdSizeMax2047=nbsEusmLgaRdSizeMax2047, nbsEusmSlotGrp=nbsEusmSlotGrp, nbsEusmFlowCfgEntry=nbsEusmFlowCfgEntry, nbsEusmFlowCfgSlot=nbsEusmFlowCfgSlot, nbsEusmSlotAccControlVidList=nbsEusmSlotAccControlVidList, nbsEusmTgaSaType=nbsEusmTgaSaType, nbsEusmPmAvgOvr2047=nbsEusmPmAvgOvr2047, nbsEusmLgaRdSizeOvr2047=nbsEusmLgaRdSizeOvr2047, nbsEusmPmOctets64=nbsEusmPmOctets64, nbsEusmVidMapToVid=nbsEusmVidMapToVid, nbsEusmSlotDscpIngressCs=nbsEusmSlotDscpIngressCs, nbsEusmLgaRdmcFrames=nbsEusmLgaRdmcFrames, nbsEusmPmOctets511=nbsEusmPmOctets511, nbsEusmLgaRdFrameDivisor=nbsEusmLgaRdFrameDivisor, nbsEusmPortSmartLoopbackVid=nbsEusmPortSmartLoopbackVid, nbsEusmFlowCfgIRAdmin=nbsEusmFlowCfgIRAdmin, nbsEusmPmAvg255=nbsEusmPmAvg255)
